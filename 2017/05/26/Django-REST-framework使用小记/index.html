<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Django_REST_framework使用小记 · Lucky4</title><meta name="description" content="Django_REST_framework使用小记 - Lucky4"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Lucky4"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Django_REST_framework使用小记</h1><div class="post-info">May 26, 2017</div><div class="post-content"><h2 id="何为REST"><a href="#何为REST" class="headerlink" title="何为REST"></a>何为REST</h2><p>即”Representational State Transfer”，翻译为”表现层状态转化”，该概念来源于作者Roy Thomas Fielding在其<a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="external">博士论文</a>中的内容，我们根据其中的几句话大概理解下：</p>
<blockquote>
<p>REST is a hybrid style derived from several of the network-based architectural styles and combined with additional constraints that define a uniform connector interface.</p>
</blockquote>
<p>大概意为REST是一种的软件（这里即WEB）架构风格，它提供了一个唯一的连接接口。</p>
<blockquote>
<p>REST provides a set of architectural constraints that, when applied as a whole, emphasizes scalability of component interactions, generality of interfaces, independent deployment of components, and intermediary components to reduce interaction latency, enforce security, and encapsulate legacy systems.</p>
</blockquote>
<p>大概意为REST这种架构风格提供了一些限制，包括可控制的交互、一般的接口、独立的开发环境、中间件、安全性、封装性等功能。</p>
<p>所有以上说的目的就是要实现一种前后端分离的架构模式，后端只负责提业务需要用到的数据API，前端只负责调用后端提供的API数据作展示，这些行为都要遵守REST风格。</p>
<h2 id="设计RESTful-API"><a href="#设计RESTful-API" class="headerlink" title="设计RESTful API"></a>设计RESTful API</h2><p>本人借鉴了<a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="external">阮一峰的文章</a>，摘抄了以下几点，都为暂时遇到的，以后可能会更新。</p>
<ol>
<li>路径（Endpoint）： 路径又称”终点”，表示API的具体网址。在RESTful架构中，每个网址代表一种资源。</li>
<li>HTTP动词：对于资源的具体操作类型，由HTTP动词表示。常用的HTTP动词有下面五个。<ul>
<li>GET：从服务器取出资源。</li>
<li>POST：在服务器新建一个资源。</li>
<li>PUT：在服务器更新资源（客户端提供改变后的完整资源）。</li>
<li>PATCH：在服务器更新资源（客户端提供改变的属性）。</li>
<li>DELETE：从服务器删除资源。</li>
</ul>
</li>
<li>状态码（Status Codes）:服务器向用户返回的状态码和提示信息，常见的有以下一些。<ul>
<li>200 OK - 服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>
<li>201 CREATED - 用户新建或修改数据成功。</li>
<li>403 Forbidden - 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>
<li>404 NOT FOUND - 用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>
<li>415 UNSUPPORTED_MEDIA_TYPE - 请求的格式不受请求页面的支持。</li>
<li>500 INTERNAL SERVER ERROR - 服务器发生错误，用户将无法判断发出的请求是否成功。</li>
</ul>
</li>
</ol>
<p>理解以上几点我们便可以写一些普通的RESTful API了。</p>
<h2 id="Django-REST-framework-使用"><a href="#Django-REST-framework-使用" class="headerlink" title="Django REST framework 使用"></a>Django REST framework 使用</h2><h3 id="Serializers"><a href="#Serializers" class="headerlink" title="Serializers"></a>Serializers</h3><p>所谓serializing目的就是要将后端返回给前端的querysets 或者 model instances（模型实例）转化Python的数据类型然后渲染为JSON、XML等数据格式返回给前端，而deserializing目的就是将前端提交的数据转化为后端的格式进行操作。有多种声明serializer的方式我这里介绍2种。</p>
<p>我们的Model模型：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</div><div class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfile</span><span class="params">(models.Model)</span>:</span></div><div class="line">    user = models.OneToOneField(User, related_name=<span class="string">'profile'</span>)</div><div class="line">    birthday = models.DateField(<span class="string">u'生日'</span>, blank=<span class="keyword">True</span>, null=<span class="keyword">True</span>)</div></pre></td></tr></table></figure></p>
<p>第一种：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></div><div class="line">    email = serializers.ReadOnlyField()</div><div class="line">    profile = UserProfileSerializer()</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></div><div class="line">        model = User</div><div class="line">        fields = (<span class="string">'id'</span>, <span class="string">'email'</span>, <span class="string">'username'</span>, <span class="string">'first_name'</span>, <span class="string">'last_name'</span>, <span class="string">'profile'</span>)</div></pre></td></tr></table></figure></p>
<p>serializer与Django的forms有很大地方是很类似的但是有几个地方是值得说明的：</p>
<ol>
<li>serializer会默认提供一个字段，根据继承的父类，若是Serializer则提供id，若继承HyperlinkedSerializer则会提供类似于url形式的主键字段。</li>
<li>serializer提供了多重字段，比如ReadOnlyField表示只读。</li>
<li>erializer还提供了表示模型之间关系的字段如PrimaryKeyRelatedField，我们这里不作详细说明，以后遇到补充。</li>
</ol>
<p>第二种：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</div><div class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> UserProfile</div><div class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserSerializer</span><span class="params">(serializers.Serializer)</span>:</span></div><div class="line">    email = serializers.ReadOnlyField()</div><div class="line">    username = serializers.CharField()</div><div class="line">    first_name = serializers.CharField()</div><div class="line">    last_name = serializers.CharField()</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfileSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></div><div class="line">    model = UserProfile</div><div class="line">         fields = (<span class="string">'id'</span>, <span class="string">'birthday'</span>, <span class="string">'code_language'</span>, <span class="string">'challenge_default'</span>)</div></pre></td></tr></table></figure></p>
<p>采用继承ModelSerializer的方式比上面的方式更加简洁，它会自动的将生命的model字段转化为serializer字段，值得注意的是我们profile这个字段，其以嵌套的方式声明了调用UserProfileSerializer，这样就可以在update的时候在一个serializer中序列两个模型的字段。</p>
<h3 id="Permissions"><a href="#Permissions" class="headerlink" title="Permissions"></a>Permissions</h3><p>所谓的Permissions其作用就是对请求request做出限制，它有两个方法has_permission和has_obj_permission，需要先满足has_permission才能在执行has_obj_permission，我们一般就用一个就行了。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> permissions</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">IsOwnerOrReadOnly</span><span class="params">(permissions.BasePermission)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">has_object_permission</span><span class="params">(self, request, view, obj)</span>:</span></div><div class="line">        <span class="keyword">if</span> request.method <span class="keyword">in</span> permissions.SAFE_METHODS:</div><div class="line">            <span class="keyword">return</span> <span class="keyword">True</span></div><div class="line"></div><div class="line">        <span class="keyword">return</span> obj.owner == request.user</div></pre></td></tr></table></figure>
<p>这个限制了，若请求类型属于SAFE_METHODS元组中，则可以访问，若不在，只有是对象的拥有者才可以进行PUT、POST等非SAFE_METHODS中类型的请求。</p>
<h3 id="Class-based-Views"><a href="#Class-based-Views" class="headerlink" title="Class-based Views"></a>Class-based Views</h3><p>基于类的视图，每个类继承类一些基础类，获得继承的基础类的包含的方法，可继承的基础类有APIView、mixins.<em>(</em>代表各种操作的类)、viewsets.<em>(</em>包括各种viewset，每种viewset都包含特定的方法)等，我们这里介绍第二种。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.contrib.auth.models <span class="keyword">import</span> User</div><div class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> mixins</div><div class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> viewsets</div><div class="line"><span class="keyword">from</span> accounts.permissions <span class="keyword">import</span> UserProfilePermission</div><div class="line"><span class="keyword">from</span> accounts.serializers <span class="keyword">import</span> UserSerializer</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserProfileViewSet</span><span class="params">(mixins.RetrieveModelMixin,</span></span></div><div class="line">                         mixins.UpdateModelMixin,</div><div class="line">                         viewsets.GenericViewSet):</div><div class="line">    queryset = User.objects.all()</div><div class="line">    serializer_class = UserSerializer</div><div class="line">    permission_classes = (UserProfilePermission,)</div></pre></td></tr></table></figure>
<p>类中的三个属性是缺一不可，分别代表返回特定model的queryset、要使用的serializer以及使用该API需要的权限。继承的GenericViewSet只包含get_object, get_queryset两个方法，不包含其他方法，使用该类可自由的继承实现特定的方法。mixins.RetrieveModelMixin类包括了GET操作的方法，UpdateModelMixin类包括了PUT操作方法所以这里我们只实现了以上两种操作，对于访问该API的其他方法，我们都会返回404或405状态码。</p>
<h3 id="Routers"><a href="#Routers" class="headerlink" title="Routers"></a>Routers</h3><p>由于我们使用了第二种方式定义了视图，所以我们使用Routers定义url资源，其他方式我们暂且不表。</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.conf.urls <span class="keyword">import</span> patterns, include, url</div><div class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</div><div class="line"><span class="keyword">from</span> accounts.api <span class="keyword">import</span> UserProfileViewSet</div><div class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</div><div class="line"></div><div class="line">router = routers.DefaultRouter()</div><div class="line">router.register(<span class="string">r'profile'</span>, UserProfileViewSet)</div><div class="line"></div><div class="line">urlpatterns = patterns(</div><div class="line">  	<span class="string">'api'</span>,</div><div class="line">  	url(<span class="string">r'^'</span>, include(router.urls)),</div><div class="line">  	url(<span class="string">r'^auth/'</span>, include(<span class="string">'rest_framework.urls'</span>, namespace=<span class="string">'rest_framework'</span>)),</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到这里我们就完成了一个API的设计，总体来说使用框架来实现API还是很方便的，通过对这个框架的使用我觉的自己还有一些知识需要巩固，包括HTTP协议、Python的面向对象设计等。只会使用框架还是很单薄的，对自己的成长还是帮助甚微的。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2017/06/16/Git操作小记/" class="prev">上一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Lucky4</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>