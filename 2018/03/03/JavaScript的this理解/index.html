<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> JavaScript的this理解 · Lucky4</title><meta name="description" content="JavaScript的this理解 - Lucky4"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Lucky4"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">JavaScript的this理解</h1><div class="post-info">Mar 3, 2018</div><div class="post-content"><h2 id="this理解"><a href="#this理解" class="headerlink" title="this理解"></a>this理解</h2><p>this对象是在运行时基于函数的执行环境的定的。</p>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在浏览器中, window 对象同时也是全局对象：</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line">a = <span class="number">37</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.b = <span class="string">"MDN"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// "MDN"</span></div></pre></td></tr></table></figure></p>
<p>在全局上下文下调用函数，函数中的this，在严格模式下为全局对象，在非严格模式下为undefined。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//在浏览器中：</span></div><div class="line">f1() === <span class="built_in">window</span>;   <span class="comment">//在浏览器中，全局对象是window</span></div><div class="line"></div><div class="line"><span class="comment">//在Node中：</span></div><div class="line">f1() === global;</div></pre></td></tr></table></figure></p>
<h4 id="函数作为对象的一个属性"><a href="#函数作为对象的一个属性" class="headerlink" title="函数作为对象的一个属性"></a>函数作为对象的一个属性</h4><p>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getName() <span class="comment">// "My Object"</span></div></pre></td></tr></table></figure></p>
<p>匿名函数的this略有不同，通常指向window。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getNameFunc()(); <span class="comment">// "The Window"</span></div></pre></td></tr></table></figure></p>
<p>匿名函数的在搜索活动对象的时候会在作用域链上搜索，匿名函数外的执行环境为getNameFunc的执行环境getNameFunc的执行环境中的活动对象并没有this.name，所以会继续搜索全局上下文中的name。</p>
<p>解决这种问题的方式是把this保存作为活动对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getNameFunc()(); <span class="comment">// "My Object"</span></div></pre></td></tr></table></figure></p>
<h4 id="函数用call或者apply调用"><a href="#函数用call或者apply调用" class="headerlink" title="函数用call或者apply调用"></a>函数用call或者apply调用</h4><p>如果要想把 this 的值从一个上下文传到另一个，就要用 call 或者apply 方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个对象可以作为call和apply的第一个参数，并且this会被绑定到这个对象。</span></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Custom'</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这个属性是在global对象定义的。</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'Global'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsThis</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;  <span class="comment">// this的值取决于函数的调用方式</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">whatsThis();          <span class="comment">// 'Global'</span></div><div class="line">whatsThis.call(obj);  <span class="comment">// 'Custom'</span></div><div class="line">whatsThis.apply(obj); <span class="comment">// 'Custom'</span></div></pre></td></tr></table></figure></p>
<h4 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h4><p>通过new Foo()一个对象的方式调用构造函数，那么在函数中访问this的时候，this指向的是新对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'lucky4'</span>;</div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1993</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Foo &#123; name: "lucky4", year: 1993 &#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p>
<p>this指向新创造对象的原因是，在使用new操作符后，调用构造函数会经历一下4个步骤：</p>
<ol>
<li>创建一个新对象。</li>
<li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。</li>
<li>执行构造函数中的代码。</li>
<li>返回新对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'lucky4'</span>;</div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1993</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window &#123;...&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo();</div></pre></td></tr></table></figure>
<p>如果未通过new的方式访问构造函数，那么this将指向Window。</p>
<h4 id="arrow-function-中的this"><a href="#arrow-function-中的this" class="headerlink" title="arrow function 中的this"></a>arrow function 中的this</h4><p>在箭头函数中，this与封闭词法上下文的this保持一致。在全局代码中，它将被设置为全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globalObject = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</div><div class="line"><span class="built_in">console</span>.log(foo() === globalObject); <span class="comment">// true</span></div></pre></td></tr></table></figure></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个含有bar方法的obj对象，</span></div><div class="line"><span class="comment">// bar返回一个函数，</span></div><div class="line"><span class="comment">// 这个函数返回this，</span></div><div class="line"><span class="comment">// 这个返回的函数是以箭头函数创建的，</span></div><div class="line"><span class="comment">// 所以它的this被永久绑定到了它外层函数的this。</span></div><div class="line"><span class="comment">// bar的值可以在调用中设置，这反过来又设置了返回函数的值。</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span></div><div class="line"><span class="comment">// 将返回的函数的引用赋值给fn。</span></div><div class="line"><span class="keyword">var</span> fn = obj.bar();</div><div class="line"></div><div class="line"><span class="comment">// 直接调用fn而不设置this，</span></div><div class="line"><span class="comment">// 通常(即不使用箭头函数的情况)默认为全局对象</span></div><div class="line"><span class="comment">// 若在严格模式则为undefined</span></div><div class="line"><span class="built_in">console</span>.log(fn() === obj); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 但是注意，如果你只是引用obj的方法，</span></div><div class="line"><span class="comment">// 而没有调用它</span></div><div class="line"><span class="keyword">var</span> fn2 = obj.bar;</div><div class="line"><span class="comment">// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span></div><div class="line"><span class="built_in">console</span>.log(fn2()() == <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="JavaScript中的this与Java、C-中的this有什么区别"><a href="#JavaScript中的this与Java、C-中的this有什么区别" class="headerlink" title="JavaScript中的this与Java、C++中的this有什么区别?"></a>JavaScript中的this与Java、C++中的this有什么区别?</h2><p>首先看一段Java的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">peel</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaPeel</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[], args)</span> </span>&#123;</div><div class="line">    Banana a = <span class="keyword">new</span> Banana(),</div><div class="line">           b = <span class="keyword">new</span> Banana();</div><div class="line">    a.peel(<span class="number">1</span>);</div><div class="line">    b.peel(<span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在执行代码的时候，编译器做了一些幕后工作，它把所操作对象的应用作为第一个参数传递给了peel()，上面的两个方法的调用变成了这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Banana.peel(a, <span class="number">1</span>);</div><div class="line">Banana.peel(b, <span class="number">2</span>);</div></pre></td></tr></table></figure></p>
<p>假设你希望在方法内部获得对当前对象的引用。由于上面引用是由编译器传入的，所以没有表示符可用，为此有个专门的关键字：this。this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。</p>
<p>Java中this的用处有很多包括，返回对当前对象的引用，方便链式调用；将当前对象传递给其他方法；在一个构造器中调用另一个构造器等。</p>
<p>我认为Java的this和JavaScript的this主要有以下几个区别：</p>
<ol>
<li>在调用位置的区别，Java只能在类方法里调用this，JavaScript除可以在方法内外，还可以全局作用域内调用。</li>
<li>this的值，Java中的this是一个引用，JavaScript中的this是一个类数组对象。</li>
<li>Java中的this创建后不可改变，JavaScript中的this可以通过使用call，apply，bind等方式改变。</li>
</ol>
<p>参考：<br><a href="http://www.cnblogs.com/wangfupeng1988/p/3988422.html" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/3988422.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this</a><br>《JavaScript高级程序设计》<br>《Java编程思想》</p>
</div></article></div></main><footer><div class="paginator"><a href="/2018/03/08/JavaScript创建对象的几种方式/" class="prev">PREV</a><a href="/2018/02/27/DOM学习/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Lucky4</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>