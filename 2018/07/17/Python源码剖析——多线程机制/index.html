<!DOCTYPE html><html lang="zh-Hans"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Python源码剖析——多线程机制 · Lucky4</title><meta name="description" content="Python源码剖析——多线程机制 - Lucky4"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://yoursite.com/atom.xml" title="Lucky4"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="http://weibo.com/sunchongsheng" target="_blank" class="nav-list-link">WEIBO</a></li><li class="nav-list-item"><a href="https://github.com/pinggod" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">Python源码剖析——多线程机制</h1><div class="post-info">Jul 17, 2018</div><div class="post-content"><p>Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对虚拟机的使用。</p>
<h2 id="GIL与线程调度"><a href="#GIL与线程调度" class="headerlink" title="GIL与线程调度"></a>GIL与线程调度</h2><p>在一个线程拥有了GIL，获得解释器的访问权之后，其他线程必须等待它释放解释器的访问权。</p>
<p>Python的多线程在于拥有一套线程调度机制，默认执行100条指令后启动线程调度机制挂起线程，选择处于等待的下一个线程时，借用底层操作系统提供的线程调度机制决定下一个进入解释器的线程。<br><br></p>
<h2 id="Python中的Thread"><a href="#Python中的Thread" class="headerlink" title="Python中的Thread"></a>Python中的Thread</h2><p>Python提供两个多线程机制接口：</p>
<ul>
<li>thread</li>
<li>threading</li>
</ul>
<p>thread 模块提供方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//threadmodule.c</span></div><div class="line"><span class="keyword">static</span> PyMethodDef thread_methods[] = &#123;</div><div class="line">    &#123;<span class="string">"start_new_thread"</span>,        (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">    &#123;<span class="string">"start_new"</span>,               (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">    &#123;<span class="string">"allocate_lock"</span>,           (PyCFunction)thread_PyThread_allocate_lock,</div><div class="line">     METH_NOARGS, allocate_doc&#125;,</div><div class="line">    &#123;<span class="string">"allocate"</span>,                (PyCFunction)thread_PyThread_allocate_lock,</div><div class="line">     METH_NOARGS, allocate_doc&#125;,</div><div class="line">    &#123;<span class="string">"exit_thread"</span>,             (PyCFunction)thread_PyThread_exit_thread,</div><div class="line">     METH_NOARGS, exit_doc&#125;,</div><div class="line">    &#123;<span class="string">"exit"</span>,                    (PyCFunction)thread_PyThread_exit_thread,</div><div class="line">     METH_NOARGS, exit_doc&#125;,</div><div class="line">    &#123;<span class="string">"interrupt_main"</span>,          (PyCFunction)thread_PyThread_interrupt_main,</div><div class="line">     METH_NOARGS, interrupt_doc&#125;,</div><div class="line">    &#123;<span class="string">"get_ident"</span>,               (PyCFunction)thread_get_ident,</div><div class="line">     METH_NOARGS, get_ident_doc&#125;,</div><div class="line">    &#123;<span class="string">"_count"</span>,                  (PyCFunction)thread__count,</div><div class="line">     METH_NOARGS, _count_doc&#125;,</div><div class="line">    &#123;<span class="string">"stack_size"</span>,              (PyCFunction)thread_stack_size,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            stack_size_doc&#125;,</div><div class="line">    &#123;<span class="literal">NULL</span>,                      <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p>
<p><br></p>
<h2 id="Python线程创建"><a href="#Python线程创建" class="headerlink" title="Python线程创建"></a>Python线程创建</h2><h4 id="通过start-new-thread创建一个新线程。"><a href="#通过start-new-thread创建一个新线程。" class="headerlink" title="通过start_new_thread创建一个新线程。"></a>通过start_new_thread创建一个新线程。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></div><div class="line"><span class="title">thread_PyThread_start_new_thread</span><span class="params">(PyObject *self, PyObject *fargs)</span></div><div class="line">&#123;</div><div class="line">    PyObject *func, *args, *keyw = <span class="literal">NULL</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span>;</span></div><div class="line">    <span class="keyword">long</span> ident;</div><div class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(fargs, <span class="string">"start_new_thread"</span>, <span class="number">2</span>, <span class="number">3</span>,</div><div class="line">                           &amp;func, &amp;args, &amp;keyw))</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (!PyCallable_Check(func)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"first arg must be callable"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!PyTuple_Check(args)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"2nd arg must be a tuple"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (keyw != <span class="literal">NULL</span> &amp;&amp; !PyDict_Check(keyw)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"optional 3rd arg must be a dictionary"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1. 创建并初始化bootstate结构, 在boot中保存关于线程的一切信息, </span></div><div class="line">    boot = PyMem_NEW(struct bootstate, <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (boot == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">    boot-&gt;interp = PyThreadState_GET()-&gt;interp;  <span class="comment">//保存PyInterpreterState对象</span></div><div class="line">    boot-&gt;func = func;</div><div class="line">    boot-&gt;args = args;</div><div class="line">    boot-&gt;keyw = keyw;</div><div class="line">    boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp);</div><div class="line">    <span class="keyword">if</span> (boot-&gt;tstate == <span class="literal">NULL</span>) &#123;</div><div class="line">        PyMem_DEL(boot);</div><div class="line">        <span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">    &#125;</div><div class="line">    Py_INCREF(func);</div><div class="line">    Py_INCREF(args);</div><div class="line">    Py_XINCREF(keyw);</div><div class="line">    <span class="comment">//2. 初始化多线程环境</span></div><div class="line">    PyEval_InitThreads(); <span class="comment">/* Start the interpreter's thread-awareness */</span></div><div class="line">    <span class="comment">//3. 创建操作系统原生线程</span></div><div class="line">    ident = PyThread_start_new_thread(t_bootstrap, (<span class="keyword">void</span>*) boot);</div><div class="line">    <span class="keyword">if</span> (ident == <span class="number">-1</span>) &#123;</div><div class="line">        PyErr_SetString(ThreadError, <span class="string">"can't start new thread"</span>);</div><div class="line">        Py_DECREF(func);</div><div class="line">        Py_DECREF(args);</div><div class="line">        Py_XDECREF(keyw);</div><div class="line">        PyThreadState_Clear(boot-&gt;tstate);</div><div class="line">        PyMem_DEL(boot);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> PyInt_FromLong(ident);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>在Python虚拟机启动时，多线程机制并没有被激活，它只支持单线程，调用thread.start_new_thread，明确指示Python虚拟机创建新的线程，Python就能意识到用户需要多线程的支持，Python虚拟机会自动建立多线程机制需要的数据机构、环境以及GIL。</li>
</ul>
<h4 id="建立多线程环境"><a href="#建立多线程环境" class="headerlink" title="建立多线程环境"></a>建立多线程环境</h4><p>多线程环境的建立，主要就是创建GIL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pythread.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *PyThread_type_lock;</div><div class="line"></div><div class="line"><span class="comment">//ceval.c</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock interpreter_lock = <span class="number">0</span>; <span class="comment">/* This is the GIL */</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock pending_lock = <span class="number">0</span>; <span class="comment">/* for pending calls */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> main_thread = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">PyEval_InitThreads</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (interpreter_lock)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    interpreter_lock = PyThread_allocate_lock(); <span class="comment">//创建GIL(PNRMUTEX aLock)thread_nt.h</span></div><div class="line">    PyThread_acquire_lock(interpreter_lock, <span class="number">1</span>);</div><div class="line">    main_thread = PyThread_get_thread_ident();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">PyThread_type_lock</span></div><div class="line"><span class="title">PyThread_allocate_lock</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    PNRMUTEX aLock;</div><div class="line"></div><div class="line">    dprintf((<span class="string">"PyThread_allocate_lock called\n"</span>));</div><div class="line">    <span class="keyword">if</span> (!initialized)</div><div class="line">        PyThread_init_thread();</div><div class="line">    aLock = AllocNonRecursiveMutex() ;</div><div class="line">    dprintf((<span class="string">"%ld: PyThread_allocate_lock() -&gt; %p\n"</span>, PyThread_get_thread_ident(), aLock));</div><div class="line">    <span class="keyword">return</span> (PyThread_type_lock) aLock;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//thread_nt.c</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NRMUTEX</span> &#123;</span></div><div class="line">    LONG   owned ;</div><div class="line">    DWORD  thread_id ;</div><div class="line">    HANDLE hevent ; <span class="comment">//event内核对象</span></div><div class="line">&#125; NRMUTEX, *PNRMUTEX ;</div></pre></td></tr></table></figure></p>
<ul>
<li>在PyEval_InitThreads通过PyThread_allocate_lock成功地创建了GIL之后，当前线程就开始遵循Python的多线程机制的规则；调用任何Python C API之前，必须首先获得GIL。因此PyEval_InitThreads紧接着通过PyThread_acquire_lock尝试获得GIL。最后调用PyThead_get_thread_ident()，获得当前Python主线程id，并将其赋给main_thread。</li>
</ul>
<h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">long</div><div class="line">PyThread_start_new_thread(void (*func)(void *), void *arg)</div><div class="line">&#123;</div><div class="line">    HANDLE hThread;</div><div class="line">    unsigned threadID;</div><div class="line">    callobj *obj;</div><div class="line"></div><div class="line">    dprintf(("%ld: PyThread_start_new_thread called\n",</div><div class="line">             PyThread_get_thread_ident()));</div><div class="line">    if (!initialized)</div><div class="line">        PyThread_init_thread();</div><div class="line"></div><div class="line">    obj = (callobj*)HeapAlloc(GetProcessHeap(), 0, sizeof(*obj));</div><div class="line">    if (!obj)</div><div class="line">        return -1;</div><div class="line">    obj-&gt;func = func;</div><div class="line">    obj-&gt;arg = arg;</div><div class="line">#if defined(MS_WINCE)</div><div class="line">    hThread = CreateThread(NULL,</div><div class="line">                           Py_SAFE_DOWNCAST(_pythread_stacksize, Py_ssize_t, SIZE_T),</div><div class="line">                           bootstrap, obj, 0, &amp;threadID);</div><div class="line">#else</div><div class="line">    hThread = (HANDLE)_beginthreadex(0,</div><div class="line">                      Py_SAFE_DOWNCAST(_pythread_stacksize,</div><div class="line">                                       Py_ssize_t, unsigned int),</div><div class="line">                      bootstrap, obj,</div><div class="line">                      0, &amp;threadID);</div><div class="line">#endif</div><div class="line">    if (hThread == 0) &#123;</div><div class="line">#if defined(MS_WINCE)</div><div class="line">        /* Save error in variable, to prevent PyThread_get_thread_ident</div><div class="line">           from clobbering it. */</div><div class="line">        unsigned e = GetLastError();</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread failed, win32 error code %u\n",</div><div class="line">                 PyThread_get_thread_ident(), e));</div><div class="line">#else</div><div class="line">        /* I've seen errno == EAGAIN here, which means "there are</div><div class="line">         * too many threads".</div><div class="line">         */</div><div class="line">        int e = errno;</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread failed, errno %d\n",</div><div class="line">                 PyThread_get_thread_ident(), e));</div><div class="line">#endif</div><div class="line">        threadID = (unsigned)-1;</div><div class="line">        HeapFree(GetProcessHeap(), 0, obj);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread succeeded: %p\n",</div><div class="line">                 PyThread_get_thread_ident(), (void*)hThread));</div><div class="line">        CloseHandle(hThread);</div><div class="line">    &#125;</div><div class="line">    return (long) threadID;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>主线程为执行程序时操作系统创建，主线程调用PyThread_start_new_thread创建子线程（CreateThread）。Win32下thread的API：_beginThread完成线程创建，bootstrap调用子线程定义（如函数），_beginThreadz在子线程中发生，顺利返回后，主线程挂起，等待obj.done。</li>
<li>主线程调用用PyThread_start_new_thread需要返回子线程的线程id，这个id只有在子线程被激活后在子线程获取，一旦子线程设置obj-&gt;id，就会设法唤醒主线程。主线程获得id后继续执行之后的字节码，主线程掌握GIL，子线程进入等待GIL状态，等待线程调度。</li>
<li>子线程创建自身线程状态对象后, 通过_PyGILState_NotrThreadState将这个对象放入线程状态对象链表。当前活动的Python线程不一定是获得了GIL的线程，主线程和子线程都是win32原生线程，操作系统可能在主线程和子线程之间切换。当所有的线程都完成了初始化之后，操作系统线程调度和Python线程调度才会统一，Python线程调度迫使当前活动线程释放GIL，并通知所有等待GIL event内核对象的线程，触发操作系统线程调度。<br><br></li>
</ul>
<h2 id="Python线程调度"><a href="#Python线程调度" class="headerlink" title="Python线程调度"></a>Python线程调度</h2><h4 id="标准调度"><a href="#标准调度" class="headerlink" title="标准调度"></a>标准调度</h4><p>Python的线程之间切换由线程调度机制掌握，python线程调度机制内建在python解释器的核心PyEval_EvalFrameEx中。</p>
<p>主线程先获得GIL, 并执行PyEval_EvalFrameEx函数代码, 这是子线程在t_bootstrap中调用PyEval_AcquireThread, 通过调用PyThread_acquire_lock申请GIL, 但由于GIL被主线程调用, 子线程被挂起. 主线程不断执行字节码, _Py_Ticker不断减一, 当减到0, 将当前维护线程状态置NULL, 然后释放GIL,此时子线程被操作系统的线程调度唤醒, 从而进入PyEval_EvalFrameEx. 对于主线程虽然失去了GIL, 但是没被挂起, 所以可以被再次切换为活动线程, 再次申请GIL, 由于被子线程占有, 主线程将自身挂起.</p>
<h4 id="阻塞调度"><a href="#阻塞调度" class="headerlink" title="阻塞调度"></a>阻塞调度</h4><p>线程A通过某些操作(如等待输入), 将自身阻塞, python应将等待GIL的线程B唤醒。</p>
<h4 id="Python子线程的销毁"><a href="#Python子线程的销毁" class="headerlink" title="Python子线程的销毁"></a>Python子线程的销毁</h4><p>主线程销毁必须要销毁python的运行时环境, 子线程的销毁不需要进行这些动作，对线程状态对象中维护的东西进行引用计数的维护，随后Python释放GIL。</p>
<h4 id="Python线程的用户级互斥和同步"><a href="#Python线程的用户级互斥和同步" class="headerlink" title="Python线程的用户级互斥和同步"></a>Python线程的用户级互斥和同步</h4><p>Python的线程在GIL的控制之下，线程之间，对整个Python解释器，对Python提供的C API的访问，都是互斥的，这可以看作是Python内核级互斥机制。但这种互斥我们不能控制的，我们还需要另一种可控的互斥机制————用户级互斥。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//threadmodule.c</div><div class="line">/* Lock objects */</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    PyThread_type_lock lock_lock;  //Event内核对象</div><div class="line">    PyObject *in_weakreflist;</div><div class="line">&#125; lockobject;</div><div class="line">static PyObject *</div><div class="line">thread_PyThread_allocate_lock(PyObject *self)</div><div class="line">&#123;</div><div class="line">    return (PyObject *) newlockobject();</div><div class="line">&#125;</div><div class="line">static lockobject *</div><div class="line">newlockobject(void)</div><div class="line">&#123;</div><div class="line">    lockobject *self;</div><div class="line">    self = PyObject_New(lockobject, &amp;Locktype);</div><div class="line">    if (self == NULL)</div><div class="line">        return NULL;</div><div class="line">    self-&gt;lock_lock = PyThread_allocate_lock();</div><div class="line">    self-&gt;in_weakreflist = NULL;</div><div class="line">    if (self-&gt;lock_lock == NULL) &#123;</div><div class="line">        Py_DECREF(self);</div><div class="line">        PyErr_SetString(ThreadError, "can't allocate lock");</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>对thread.allocate的调用仅仅通过newlockobject创建了一个lockobject对象，Python整个用户级线程同步机制就在这个对象基础上实现。</li>
</ul>
<p>实现：</p>
<ul>
<li>同步锁 <a href="https://www.cnblogs.com/xuanan/p/7202492.html" target="_blank" rel="external">参考</a></li>
<li>可重入锁 <a href="https://segmentfault.com/a/1190000014769953" target="_blank" rel="external">参考</a></li>
</ul>
</div></article></div></main><footer><div class="paginator"><a href="/2018/08/03/数组与链表/" class="prev">PREV</a><a href="/2018/07/15/大疆创新2019届秋招前端笔试题/" class="next">NEXT</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://yoursite.com">Lucky4</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;e=o.createElement(i);r=o.getElementsByTagName(i)[0];e.src='//www.google-analytics.com/analytics.js';r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));ga('create',"UA-65933410-1",'auto');ga('send','pageview');</script></body></html>