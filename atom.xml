<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucky4</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-23T16:41:07.303Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lucky4</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>《MySQL必知必会》阅读笔记</title>
    <link href="http://yoursite.com/2020/05/22/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/05/22/《MySQL必知必会》阅读笔记/</id>
    <published>2020-05-22T15:22:36.000Z</published>
    <updated>2020-05-23T16:41:07.303Z</updated>
    
    <content type="html"><![CDATA[<p>目录：</p><ul><li><a href="#4-检索数据">4 检索数据</a><ul><li><a href="#检索不同的行">检索不同的行</a></li><li><a href="#限制结果">限制结果</a></li><li><a href="#完全限定表名">完全限定表名</a></li></ul></li><li><a href="#5-排序检索数据">5 排序检索数据</a></li><li><a href="#6-过滤数据">6 过滤数据</a><ul><li><a href="#空值检查">空值检查</a></li></ul></li><li><a href="#7-数据过滤">7 数据过滤</a><ul><li><a href="#组合-WHERE-子句">组合 WHERE 子句</a></li><li><a href="#IN-操作符">IN 操作符</a></li><li><a href="#NOT-操作符">NOT 操作符</a></li></ul></li><li><a href="#8-用通配符进行过滤">8 用通配符进行过滤</a><ul><li><a href="#LIKE-操作符">LIKE 操作符</a></li><li><a href="#使用通配符的技巧">使用通配符的技巧</a></li></ul></li><li><a href="#9-用正则表达式进行搜索">9 用正则表达式进行搜索</a></li><li><a href="#12-汇总数据">12 汇总数据</a><ul><li><a href="#聚集函数">聚集函数</a></li><li><a href="#聚集不同值">聚集不同值</a></li><li><a href="#组合聚集函数">组合聚集函数</a></li></ul></li><li><a href="#13-分组数据">13 分组数据</a><ul><li><a href="#创建分组">创建分组</a></li><li><a href="#过滤分组">过滤分组</a></li><li><a href="#分组和排序">分组和排序</a></li><li><a href="#SELECT-子句顺序">SELECT 子句顺序</a></li></ul></li><li><a href="#14-使用子查询">14 使用子查询</a><ul><li><a href="#利用子查询进行过滤">利用子查询进行过滤</a></li><li><a href="#作为计算字段使用子查询">作为计算字段使用子查询</a></li></ul></li><li><a href="#15-联结">15 联结</a><ul><li><a href="#创建联结">创建联结</a></li></ul></li><li><a href="#22-使用视图">22 使用视图</a><ul><li><a href="#视图">视图</a></li><li><a href="#使用视图">使用视图</a></li></ul></li><li><a href="#26-管理事务处理">26 管理事务处理</a><ul><li><a href="#事务处理">事务处理</a></li><li><a href="#控制事务处理">控制事务处理</a></li></ul></li><li><a href="#30-改善性能">30 改善性能</a><br><br></li></ul><h2 id="4-检索数据"><a href="#4-检索数据" class="headerlink" title="4 检索数据"></a>4 检索数据</h2><h4 id="检索不同的行"><a href="#检索不同的行" class="headerlink" title="检索不同的行"></a>检索不同的行</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> vend_id</div><div class="line"><span class="keyword">FROM</span> products;</div></pre></td></tr></table></figure><p><code>DISTINCT</code> 应用所有的列，不能不分指定。</p><h4 id="限制结果"><a href="#限制结果" class="headerlink" title="限制结果"></a>限制结果</h4><p>使用 <code>LIMIT</code> 限定输出的结果数量：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> prod_name</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">LIMIT</span> <span class="number">5</span>, <span class="number">5</span>;</div></pre></td></tr></table></figure></p><p>第一个数为开始的位置，第二个数为检索的行数。</p><h4 id="完全限定表名"><a href="#完全限定表名" class="headerlink" title="完全限定表名"></a>完全限定表名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> products.prod_name</div><div class="line"><span class="keyword">FROM</span> products;</div></pre></td></tr></table></figure><p><br></p><h2 id="5-排序检索数据"><a href="#5-排序检索数据" class="headerlink" title="5 排序检索数据"></a>5 排序检索数据</h2><p>子句：SQL 语句由子句构成，包括一个关键字和所提供的的数据。子句如 SELECT 子句，FROM 子句。</p><p>可以使用 <code>ORDER BY</code> 子句取一个或多个列名字,对输出进行排序。</p><p>SQL 的输出结果默认是升序 <code>ASC</code>，可以使用 <code>DESC</code>进行降序输出。</p><p>一个例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> prod_id, prod_price, prod_name</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_price <span class="keyword">DESC</span>, prod_name;</div></pre></td></tr></table></figure></p><p>对 prod_price 降序，对 prod_name 升序。</p><p>ORDER BY 位于 FROM 之后，LIMIT 之前。</p><p><br></p><h2 id="6-过滤数据"><a href="#6-过滤数据" class="headerlink" title="6 过滤数据"></a>6 过滤数据</h2><p>WHERE 子句的操作符：<br><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- =</div><div class="line">- &lt;&gt;</div><div class="line">- != </div><div class="line">- &lt;</div><div class="line">- &lt;=</div><div class="line">- BETWEEN</div></pre></td></tr></table></figure></p><h4 id="空值检查"><a href="#空值检查" class="headerlink" title="空值检查"></a>空值检查</h4><p>在建表时,表设计人员可以指定其中的列是否可以不包含。在一个列不包含值时,称其为包含空值 <code>NULL</code>。</p><p>可以使用 IS NULL 子句来判断：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> prod_name</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">WHERE</span> prod_price <span class="keyword">IS</span> <span class="literal">NULL</span>;</div></pre></td></tr></table></figure></p><p><br></p><h2 id="7-数据过滤"><a href="#7-数据过滤" class="headerlink" title="7 数据过滤"></a>7 数据过滤</h2><p>操作符：用来联结或改变 WHERE 子句中的子句的关键字,也称逻辑操作符。</p><h4 id="组合-WHERE-子句"><a href="#组合-WHERE-子句" class="headerlink" title="组合 WHERE 子句"></a>组合 WHERE 子句</h4><p>使用的操作符包括 <code>AND</code> ，<code>OR</code>，它们的计算次序是 AND 高于 OR ，可以使用括号来明确执行顺序。</p><h4 id="IN-操作符"><a href="#IN-操作符" class="headerlink" title="IN 操作符"></a>IN 操作符</h4><p><code>IN</code> 操作符与 OR 有相似的功能，但是有如下优点：</p><ul><li>比 OR 执行的更快。</li><li>可以包含其他 SELECT 子句，能够动态的建立 WHERE 子句。</li></ul><h4 id="NOT-操作符"><a href="#NOT-操作符" class="headerlink" title="NOT 操作符"></a>NOT 操作符</h4><p><code>NOT</code>支持对 OR、AND、IN、BETWEEN 取反。</p><p><br></p><h2 id="8-用通配符进行过滤"><a href="#8-用通配符进行过滤" class="headerlink" title="8 用通配符进行过滤"></a>8 用通配符进行过滤</h2><p>通配符：用来匹配值的一部分的特殊字符。<br>搜索模式：由字面值、通配符组合而成。</p><p>在子句中使用通配符，需使用 <code>LIKE</code> 操作符，指示 MySQL 根据后端的通配符进行匹配而不是等值匹配。</p><h4 id="LIKE-操作符"><a href="#LIKE-操作符" class="headerlink" title="LIKE 操作符"></a>LIKE 操作符</h4><p><code>%</code> 表示任意字符出现的次数。<br><code>_</code> 表示只匹配单个字符。</p><p>例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> prod_id, prod_name</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">WHERE</span> prod_name <span class="keyword">LIKE</span> <span class="string">'_ ton anvil'</span>;</div></pre></td></tr></table></figure></p><h4 id="使用通配符的技巧"><a href="#使用通配符的技巧" class="headerlink" title="使用通配符的技巧"></a>使用通配符的技巧</h4><p>通配符效率较低，有以下技巧：</p><ul><li>不要放在搜索的开始位置，因为会令后面的索引失效。</li></ul><p><br></p><h2 id="9-用正则表达式进行搜索"><a href="#9-用正则表达式进行搜索" class="headerlink" title="9 用正则表达式进行搜索"></a>9 用正则表达式进行搜索</h2><p>随着过滤条件的复杂性增加，WHERE 子句的复杂性也会增加，可以使用正则表达式。</p><p>使用 <code>REGEXP</code> 操作符进行基本的字符匹配:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> prod_name</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">WHERE</span> prod_name REGEXP <span class="string">'1000'</span></div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> prod_name;</div></pre></td></tr></table></figure></p><p>一个区分：LIKE 是匹配整个列，REGEXP 是在列值内进行匹配，详细请看书解释。</p><p><br></p><h2 id="12-汇总数据"><a href="#12-汇总数据" class="headerlink" title="12 汇总数据"></a>12 汇总数据</h2><p>聚集函数：运行在行组上，计算和返回单个值的函数。</p><h4 id="聚集函数"><a href="#聚集函数" class="headerlink" title="聚集函数"></a>聚集函数</h4><ul><li><code>AVG()</code></li><li><code>COUNT()</code></li><li><code>MAX()</code></li><li><code>MIN()</code></li><li><code>SUM()</code></li></ul><h4 id="聚集不同值"><a href="#聚集不同值" class="headerlink" title="聚集不同值"></a>聚集不同值</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> prod_price) <span class="keyword">AS</span> avg_price</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">WHERE</span> vend_id = <span class="number">1003</span>;</div></pre></td></tr></table></figure><h4 id="组合聚集函数"><a href="#组合聚集函数" class="headerlink" title="组合聚集函数"></a>组合聚集函数</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_items,</div><div class="line">       <span class="keyword">MIN</span>(prod_price) <span class="keyword">AS</span> price_min,</div><div class="line">       <span class="keyword">MAX</span>(prod_price) <span class="keyword">AS</span> price_max,</div><div class="line">       <span class="keyword">AVG</span>(prod_price) <span class="keyword">AS</span> price_avg</div><div class="line"><span class="keyword">FROM</span> products;</div></pre></td></tr></table></figure><p><br></p><h2 id="13-分组数据"><a href="#13-分组数据" class="headerlink" title="13 分组数据"></a>13 分组数据</h2><p>如果要查询每个产品的供应商供应数目，WHERE 子句不能满足要求，可以使用分组，把数据分成多个逻辑组，对每个组进行计算。</p><h4 id="创建分组"><a href="#创建分组" class="headerlink" title="创建分组"></a>创建分组</h4><p>分组使用 <code>GROUP BY</code> 子句。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id;</div></pre></td></tr></table></figure></p><p>使用 GROUP BY 子句的一些重要规定：</p><ul><li>GROUP BY 子句中列出的每个列必须是检索列或有效表达式。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式，不能使用别名。</li><li>除聚集计算外，SELECT 语句中的每个列都必须在 GROUP BY 子句给出。</li><li>如果分组中具有 NULL 值，则 NULL 将作为一个分组返回，如果列中有多行 NULL 值，它们将分为一组。</li><li>GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。</li></ul><h4 id="过滤分组"><a href="#过滤分组" class="headerlink" title="过滤分组"></a>过滤分组</h4><p>使用 <code>HAVING</code> 过滤分组。WHERE 过滤行，HAVING 过滤分组。</p><p>HAVING 和 WHERE 的区别，WHERE 在分组前进行过滤，HAVING 在分组后进行过滤。</p><p>一个例子，过滤 12 个月内两个以上的订单的顾客：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> vend_id, <span class="keyword">COUNT</span>(*) <span class="keyword">AS</span> num_prods</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">WHERE</span> prod_price &gt;= <span class="number">10</span></div><div class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> vend_id</div><div class="line"><span class="keyword">HAVING</span> <span class="keyword">COUNT</span>(*) &gt;=<span class="number">2</span>;</div></pre></td></tr></table></figure></p><h4 id="分组和排序"><a href="#分组和排序" class="headerlink" title="分组和排序"></a>分组和排序</h4><p>GROUP BY 具有排序功能，但如果是有排序需求的话，必须加上 ORDER BY。</p><h4 id="SELECT-子句顺序"><a href="#SELECT-子句顺序" class="headerlink" title="SELECT 子句顺序"></a>SELECT 子句顺序</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">1. <span class="keyword">SELECT</span></div><div class="line"><span class="number">2.</span> <span class="keyword">FROM</span></div><div class="line"><span class="number">3.</span> <span class="keyword">WHERE</span></div><div class="line"><span class="number">4.</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span></div><div class="line"><span class="number">5.</span> <span class="keyword">HAVING</span></div><div class="line"><span class="number">6.</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span></div><div class="line"><span class="number">7.</span> <span class="keyword">LIMIT</span></div></pre></td></tr></table></figure><p><br></p><h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><p>子查询即嵌套在其他查询中的查询。</p><h4 id="利用子查询进行过滤"><a href="#利用子查询进行过滤" class="headerlink" title="利用子查询进行过滤"></a>利用子查询进行过滤</h4><p>一个例子，列出订购物品 TNT2 的所有客户：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> cust_id</div><div class="line"><span class="keyword">FROM</span> orders</div><div class="line"><span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num</div><div class="line">                    <span class="keyword">FROM</span> orderitems</div><div class="line">                    <span class="keyword">WHERE</span> prod_id = <span class="string">'TNT2'</span>);</div></pre></td></tr></table></figure></p><p>查询由内向外进行处理。</p><h4 id="作为计算字段使用子查询"><a href="#作为计算字段使用子查询" class="headerlink" title="作为计算字段使用子查询"></a>作为计算字段使用子查询</h4><p>一个例子，求 customers 表中每个客户的订单总数。订单与客户id 存储在 order 表中。</p><p>首先对客户 10001 的订单进行计数：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</div><div class="line"><span class="keyword">FROM</span> orders</div><div class="line"><span class="keyword">WHERE</span> cust_id = <span class="number">10001</span>;</div></pre></td></tr></table></figure></p><p>为了对每个客户执行 COUNT(<em>) 计算,应该将 COUNT(</em>) 作为一个字查询:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> cust_name,</div><div class="line">       cust_state,</div><div class="line">       (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</div><div class="line">        <span class="keyword">FROM</span> orders</div><div class="line">        <span class="keyword">WHERE</span> orders.cust_id = customers.cust_id) <span class="keyword">AS</span> orders</div><div class="line"><span class="keyword">FROM</span> customers</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</div></pre></td></tr></table></figure></p><p><br></p><h2 id="联结表"><a href="#联结表" class="headerlink" title="联结表"></a>联结表</h2><p>联结是一种机制，用来在一条 SELECT 语句中关联表，可以联结多个表返回一组输出。</p><p>联结在实际的数据库表中不存在，存在于查询的执行当中。</p><h4 id="创建联结"><a href="#创建联结" class="headerlink" title="创建联结"></a>创建联结</h4><p>创建一个简单联结：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</div><div class="line"><span class="keyword">FROM</span> vendors, products</div><div class="line"><span class="keyword">WHERE</span> vendors.vend_id = products.vend_id</div><div class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> vend_name, prod_name;</div></pre></td></tr></table></figure></p><p>注意 SQL 语句中 WHERE 子句的重要性，如果没有 WHERE 子句，那么将会导致笛卡尔积数量的结果。</p><p>内联结：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> vend_name, prod_name, prod_price</div><div class="line"><span class="keyword">FROM</span> vendors <span class="keyword">INNER</span> <span class="keyword">JOIN</span> products</div><div class="line"><span class="keyword">ON</span> vendors.vend_id = products.vend_id;</div></pre></td></tr></table></figure></p><p>相比上面的查询，具有明确的语法，联结条件使用 ON 子句而不是使用 WHERE。</p><p><em>表联结和子查询可以实现相同的功能。</em></p><p><br></p><h2 id="创建高级联结"><a href="#创建高级联结" class="headerlink" title="创建高级联结"></a>创建高级联结</h2><h4 id="自联结"><a href="#自联结" class="headerlink" title="自联结"></a>自联结</h4><p>使用表别名的原因是能在单条 SELECT 语句中不止一次引用相同的表。</p><p>如果物品（ID 为 DTNTR）存在问题，想知道该供应商的其它物品是否有问题。可以使用如下子查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> prod_id, prod_name</div><div class="line"><span class="keyword">FROM</span> products</div><div class="line"><span class="keyword">WHERE</span> vend_id = (<span class="keyword">SELECT</span> vend_id</div><div class="line">                 <span class="keyword">FROM</span> products</div><div class="line">                 <span class="keyword">WHERE</span> prod_id = <span class="string">'DTNTR'</span>);</div></pre></td></tr></table></figure></p><p>使用自联结同样可以实现该查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> p1.prod_id, p1.prod_name</div><div class="line"><span class="keyword">FROM</span> products <span class="keyword">AS</span> p1, products <span class="keyword">AS</span> p2</div><div class="line"><span class="keyword">WHERE</span> p1.vend_id = p2.vend_id</div><div class="line">  <span class="keyword">AND</span> p2.prod_id = <span class="string">'DTNTR'</span>;</div></pre></td></tr></table></figure></p><p><br></p><h2 id="22-使用视图"><a href="#22-使用视图" class="headerlink" title="22 使用视图"></a>22 使用视图</h2><p>视图是虚拟的表。只包含使用时动态检索数据的查询。</p><h4 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h4><p>一个例子，可以把如下查询：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</div><div class="line"><span class="keyword">FROM</span> customers, orders, orderitems</div><div class="line"><span class="keyword">WHERE</span> customers.cust_id = orders.cust_id</div><div class="line">  <span class="keyword">AND</span> orderitems.order_num = order.order_num</div><div class="line">  <span class="keyword">AND</span> prod_id = <span class="string">'abc'</span>;</div></pre></td></tr></table></figure></p><p>包装为一个名为 productcustomers 的虚拟表：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> cust_name, cust_contact</div><div class="line"><span class="keyword">FROM</span> productcustomers</div><div class="line"><span class="keyword">WHERE</span> prod_id = <span class="string">'abc'</span>;</div></pre></td></tr></table></figure></p><p>productcustomers 是一个视图，它不包含表中应该有的任何列或数据，它包含的是一个 SQL 查询（与上面用以正确联结表的相同的查询）。</p><p>视图的常见应用：</p><ul><li>重用 SQL 语句。</li><li>使用表的组成部分而不是整个表。</li><li>保护数据。只给予表的特定部分的访问权限。</li><li>更改数据格式和表示。</li><li>极客时间里的，事务的隔离级别的实现。</li></ul><p>可以用与表的相同的方式利用它们，SELECT、INSERT、UPDATE。</p><p>重要的是知道，视图仅仅是查看存储在别处的数据的一种设施，它们的数据都是从别的表检索出来的。</p><p>视图的规则和限制：</p><ul><li>唯一命名。</li><li>可以嵌套。</li><li>视图的检索 SELECT 中也有 ORDER BY ，那么视图的 ORDER BY 将被覆盖。</li><li>视图不能索引。</li><li>可以和表一起使用。</li></ul><h4 id="使用视图"><a href="#使用视图" class="headerlink" title="使用视图"></a>使用视图</h4><p>使用视图与计算字段：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> orderitemsexpanded <span class="keyword">AS</span></div><div class="line"><span class="keyword">SELECT</span> order_num,</div><div class="line">       prod_id,</div><div class="line">       quantity,</div><div class="line">       item_price,</div><div class="line">       quantity * item_price <span class="keyword">AS</span> expanded_price</div><div class="line"><span class="keyword">FROM</span> orderitems;</div></pre></td></tr></table></figure></p><p>使用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> *</div><div class="line"><span class="keyword">FROM</span> orderitemsexpanded</div><div class="line"><span class="keyword">WHERE</span> order_num = <span class="number">25</span>;</div></pre></td></tr></table></figure></p><p>更新视图，视图可更新，会对基表进行操作。</p><p><br></p><h2 id="26-管理事务处理"><a href="#26-管理事务处理" class="headerlink" title="26 管理事务处理"></a>26 管理事务处理</h2><p>事务是一种机制，事务处理可以用来维护数据库的完整性，它保证成批处理的 MySQL 操作要么完全执行，要么完全不执行。</p><h4 id="事务处理"><a href="#事务处理" class="headerlink" title="事务处理"></a>事务处理</h4><p>事务涉及的几个术语：</p><ul><li>事务（transaction）：指一组 SQL 语句。</li><li>回退（rollback）：指撤销指定 SQL 语句的过程。</li><li>提交（commit）：指将未存储的 SQL 语句结果写入数据库表。</li><li>保留点（savepoint）：指事务处理中设置的临时占位符，你可以对它发布回退。</li></ul><h4 id="控制事务处理"><a href="#控制事务处理" class="headerlink" title="控制事务处理"></a>控制事务处理</h4><p>事务开始语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span></div></pre></td></tr></table></figure></p><p>事务回退语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">ROLLBACK</span></div></pre></td></tr></table></figure></p><p>例子：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</div><div class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</div><div class="line"><span class="keyword">ROLLBACK</span>;</div><div class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> ordertotals;</div></pre></td></tr></table></figure></p><p>哪些语句可以回退？<br>可以回退 INSERT、DELETE、UPDATE 语句。但是不可以回退 SELECT、CREATE、DROP 语句。</p><p>一般的 MySQL 语句都是直接针对数据库表执行，会进行隐含提交。而事务必须明确使用 <code>COMMIT</code> 语句进行提交。<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</div><div class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orderitems <span class="keyword">WHERE</span> order_num = <span class="number">20010</span>;</div><div class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> orders <span class="keyword">WHERE</span> order_num =<span class="number">20010</span>;</div><div class="line"><span class="keyword">COMMIT</span>;</div></pre></td></tr></table></figure></p><p>如果其中一条 DELETE 执行失败，则另一条会被自动撤销。</p><p>隐含事务关闭：当 <code>COMMIT</code> 或 <code>ROLLBACK</code> 语句执行后，事务会自动关闭。</p><p>使用保留点：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SAVEPOINT</span> <span class="keyword">delete</span>;</div><div class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1;</div></pre></td></tr></table></figure></p><p>为指示 MySQL 不自动提交更改，可以使用以下语句：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SET</span> autocommit =<span class="number">0</span>;</div></pre></td></tr></table></figure></p><p><code>autocommit</code> 针对的是每个连接而不是服务器。</p><p><br></p><h2 id="30-改善性能"><a href="#30-改善性能" class="headerlink" title="30 改善性能"></a>30 改善性能</h2><p>MySQL 是用一系列的默认设置预先配置的，但使用过程中需要经常调整内存、缓冲区大小等。为查看当前设置，可使用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SHOW</span> <span class="keyword">VARIABLES</span>;</div></pre></td></tr></table></figure></p><p>或<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span>;</div></pre></td></tr></table></figure></p><p>MySQL 是一个多用户多线程的 DBMS，经常同时执行多个任务，如果某一个执行缓慢，则所有都会执行缓慢，可使用：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">SHOW</span> <span class="keyword">PROCESSLIST</span>;</div></pre></td></tr></table></figure></p><p>显示所有活动进程，还可使用 KILL 命令终结特定进程。</p><p>使用 <code>EXPLAIN</code> 语句让 MySQL 解释它将如何执行一条 SELECT 语句。</p><p>决不要检索比需求还多的数据，如 SELECT *。</p><p>使用正确的数据类型。</p><p>导入数据时应该关闭自动提交。</p><p>可以使用 UNION 代替 OR。</p><p>索引改善查询的性能，伤害插入、删除的性能，不经常被搜索不需加索引。</p><p>最重要，每条规则都在某些条件下会打破。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目录：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#4-检索数据&quot;&gt;4 检索数据&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#检索不同的行&quot;&gt;检索不同的行&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#限制结果&quot;&gt;限制结果&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#完
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《Linux命令行大全》阅读笔记2</title>
    <link href="http://yoursite.com/2020/05/04/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B02/"/>
    <id>http://yoursite.com/2020/05/04/《Linux命令行大全》阅读笔记2/</id>
    <published>2020-05-04T03:30:13.000Z</published>
    <updated>2020-05-04T03:30:13.591Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Linux命令行大全》阅读笔记3</title>
    <link href="http://yoursite.com/2020/05/03/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B03/"/>
    <id>http://yoursite.com/2020/05/03/《Linux命令行大全》阅读笔记3/</id>
    <published>2020-05-03T14:07:52.000Z</published>
    <updated>2020-05-17T04:18:55.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、软件包管理"><a href="#一、软件包管理" class="headerlink" title="一、软件包管理"></a>一、软件包管理</h2><p>软件包管理是一种在系统上安装、维护软件的方法。可以通过 Lunux 经销商发布的软件包来安装，也可通过自行下载源代码，进行编译安装。<br><br></p><h5 id="软件包系统"><a href="#软件包系统" class="headerlink" title="软件包系统"></a>软件包系统</h5><p>不同的 Linux 发行版用的是不同的软件包系统，不同的软件包系统使用了不同的技术，即 Debian 的 .deb 技术和 Red Hat 的 .rpm 技术。下面列出了两个基本软件包系统：</p><ul><li>Debian 类（.deb 技术）：发行版本包括 ubuntu 等。</li><li>Red Hat 类（.rpm 技术）：发行版本包括 CentOS、Fedora、Red Hat 等。<br><br></li></ul><h4 id="软件包的工作方式"><a href="#软件包的工作方式" class="headerlink" title="软件包的工作方式"></a>软件包的工作方式</h4><p>软件包文件<br>一个压缩文件，包括安装文件、文本说明以及安装脚本等文件。</p><p>库<br>一个中心库或者第三方库包含了成千上万个软件包。</p><p>高级和低级软件工具<br>软件包管理系统通常包含两类工具————执行安装、删除软件包文件等任务的高级工具和进行元数据搜索及提供依赖性解决的低级工具。低级如 dpkg，rpm；高级如 apt-get，yum。<br><br></p><h4 id="常见软件包管理任务"><a href="#常见软件包管理任务" class="headerlink" title="常见软件包管理任务"></a>常见软件包管理任务</h4><p>在库里面查找软件包（下面的代码例子都以 Debian 系统为例）。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; apt-get update</div><div class="line">&gt; apt-cache search search_string</div></pre></td></tr></table></figure><p>安装库中的软件包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; apt-get update</div><div class="line">&gt; apt-get install package_name</div></pre></td></tr></table></figure></p><p>安装软件包文件中的软件包，如果软件包文件并不是从库源中下载的，那么我们就可用低级工具直接安装。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; dpkg --install package_file</div></pre></td></tr></table></figure><p>例如，先下载第三方 MySQL 的 .deb 文件，然后在安装。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; sudo dpkg -i /路径/mysql-apt-config_w.x.y-z_all.deb</div></pre></td></tr></table></figure></p><p>删除软件包，删除软件包可利用高级工具，也可利用低级工具，高级命令如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; apt-get remove package_name</div></pre></td></tr></table></figure></p><p>更新库中的软件包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; apt-get update</div><div class="line">&gt; apt-get upgrade</div></pre></td></tr></table></figure></p><p>更新软件包文件的软件包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; dpkg --install package_name</div></pre></td></tr></table></figure></p><p>列出已安装的软件包列表<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; dpkg --list</div></pre></td></tr></table></figure></p><p>判断软件包是否已安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; dpkg --status package_name</div></pre></td></tr></table></figure></p><p>显示已安装软件包的相关信息<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; apt-cache show package_name</div></pre></td></tr></table></figure></p><p><br></p><h2 id="二、编译程序"><a href="#二、编译程序" class="headerlink" title="二、编译程序"></a>二、编译程序</h2><p>介绍如何通过源代码生成可执行程序。为什么要编译软件？有如下两个原因：</p><ul><li>库中的程序不能够满足用户的所有需求。</li><li>库中的版本不一定存在最新的版本。<br><br></li></ul><h4 id="什么是编译"><a href="#什么是编译" class="headerlink" title="什么是编译"></a>什么是编译</h4><p>编译是一个将源代码翻译成计算机处理器能够识别的语言的过程。</p><p>计算机的发展过程中经历了一下几个变化：</p><ol><li>机器语言（数值代码）</li><li>汇编语言</li><li>高级编程语言</li></ol><p>高级语言编写的程序通过编译器转换为机器语言，有些编译器将高级语言先转换为汇编语言，然后在把汇编语言转换为机器语言。</p><p>链接器程序可以实现编译器的输出与编译程序所需要的库之间的链接。该操作可以生成一个可执行文件。<br><br></p><h4 id="编译一个-C-程序"><a href="#编译一个-C-程序" class="headerlink" title="编译一个 C 程序"></a>编译一个 C 程序</h4><p>1.获取程序，如：diction-1.11.tar.gz<br>2.解压<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; tar -xzf diction-1.11.tar.gz</div></pre></td></tr></table></figure></p><p>3.生成程序<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; ./configure</div><div class="line">&gt; make</div><div class="line">&gt; sudo make install</div></pre></td></tr></table></figure></p><p>4.查看程序是否可执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; which diction</div></pre></td></tr></table></figure></p><p>在上面的步骤中，每个步骤都做了什么呢，我们具体分析一下。</p><ol><li>configure 程序其实是源代码树下的一个 shell 脚本，它的任务就是分析生成环境，适应不同的环境来生成可执行程序，同时还会校验当前系统是否安装了必要的外部工具和组件。</li><li>Makefile 是 configure 在源目录生成的文件，描述了生成最后可执行程序时的各部件之间的联系及依赖关系，它的作用是指导 make 命令如何生成可执行成的配置文件, make 是 Linux 提供的一个程序，该程序的作用其实就是输入 Makefile 编译最终的程序。</li><li>打包好的源代码一般包含一个特殊的 make 目标程序，它便是 install（install 是在当前 make 文件夹下生成的目标文件），该目标程序将会在系统目录下安装最后生成的可执行程序，通常会主动安装在 /usr/local/bin 目录下，为了获得执行权限，需要使用 sudo 命令来运行安装可执行程序。</li></ol><p>补充：make 会生成需要生成的文件，如果没有改动，就不会执行任何操作。可用于维护目标文件的更新。<br><br></p><h2 id="三、文件搜索和grep"><a href="#三、文件搜索和grep" class="headerlink" title="三、文件搜索和grep"></a>三、文件搜索和grep</h2><p>在日常的 Linux 操作中，常常需要搜索文件或者匹配一些文件或内容，这就需要几个常用的搜索命令，主要包括 find、grep 等，接下来详细介绍下使用。<br><br></p><h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><p><code>locate</code> 命令，通过快速搜索数据库，寻找路径名与给定字符串相匹配的文件。</p><p>查找 bin 目录下，以 zip 开头的程序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; locate bin/zip</div></pre></td></tr></table></figure></p><p>补充：locate 的数据库的内容是通过每天的定时任务获得，不保证实时性，为了实时更新，可以手动执行 updatedb 程序。</p><p>locate 程序仅仅是依据文件名进行查找，而 <code>find</code> 程序则是依据文件的各种数属性在既定的目录里查找。find 程序有两个比较重要的选项，<code>test</code> 选项和 action 选项。首先介绍 test 选项。</p><p>限制文件类型搜索，在当前目录下搜索文类型文件，并统计数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; find ~ -type f | wc -l</div></pre></td></tr></table></figure></p><p>find 支持的常用文件类型：</p><ul><li>f：普通文件。</li><li>l：符号链接。</li><li>d：目录。</li><li>b：块设备。</li><li>c：字符设备文件。</li></ul><p>find 命令支持多种 test 参数：</p><ul><li>-name pattern：匹配特定通配符模式的文件或目录。</li><li>-newer file：匹配内容的修改时间比 file 更近的文件或目录。</li><li>-pern mode：寻找权限与模式匹配的目录或文件。</li><li>-size n：匹配 n 大小的文件。</li><li>type c：匹配 c 类型的文件。<br>更多的选项还是通过 find 的 man 命令查看。</li></ul><p>test 选项之间的可以使用操作符，可以建立复杂的匹配条件。</p><p>查找访问权限不是 0600 的文件和访问权限不是0700 的目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; find ~ \( -type f -not -perm 0600 \) -or \( -type d -not -perm 0700 \)</div></pre></td></tr></table></figure></p><p>上述命令中使用了 -or ，-not 和 () 操作符，还存在一种另外一种未使用过的 -and 操作符。命令中由于括号在 shell 环境下有特殊含义，所有要对它进行转义，使用反斜杠。</p><p>action 选项可以对搜索的结果执行动作。以下是预定义动作：</p><ul><li>-delete：删除匹配文件。</li><li>-print：输入。</li></ul><p>一个例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; find ~ type f -name &quot;*.bak&quot; -delete</div></pre></td></tr></table></figure></p><p>用户也可以自定义动作，有两种方式，第一种方式是使用 exec 操作，另一种是使用 xargs 处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; find ~ -type f -name &quot;foo*&quot; -ok ls -l &apos;&#123;&#125;&apos; &apos;;&apos;</div></pre></td></tr></table></figure><p>其中，{} 花括号代表的是当前路径，分号为必须得分隔符表示命令结束。该例子中每次找到匹配的文件后执行 ls -l 命令，-ok 会在执行前询问。</p><p>该命令的缺点就是匹配到文件后就会执行一次命令，用户更希望只调用一次就完成所有操作。可以使用 xargs 来提高效率。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&gt; find ~ -type f -name &quot;foo*&quot; -print | xargs ls -l</div></pre></td></tr></table></figure></p><p>find 命令执行结果直接作为 xargs 输入，xargs 将其转化为 ls 命令的输入参数列表，执行 ls 操作。在 xargs 命令后添加 –show-limits 可查看最大输入参数数量。<br><br></p><h4 id="grep文本搜索"><a href="#grep文本搜索" class="headerlink" title="grep文本搜索"></a>grep文本搜索</h4><p><code>grep</code>名字源于“global regular expression print”，grep 搜索文本文件中与指定正则表达式匹配的行，并将结果送至标准输出。</p><p>语法：<br>grep [optins] regex [file…]</p><p>grep 常用选：</p><ul><li>-c：输出匹配项数目。</li><li>-n：匹配行前加上行号。</li><li>-r：递归搜索。</li><li>-l：只输出匹配文件名。</li></ul><p>例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; grep bzip dirlist*.txt</div><div class="line">dirlist-bin.txt:bzip2</div><div class="line">dirlist-bin.txt:bzip2recover</div></pre></td></tr></table></figure></p><p>命令在文件中搜索到了两个匹配项。</p><p>只展示匹配的文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; grep -l bzip dirlist*.txt</div><div class="line">dirlist-bin.txt</div></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、软件包管理&quot;&gt;&lt;a href=&quot;#一、软件包管理&quot; class=&quot;headerlink&quot; title=&quot;一、软件包管理&quot;&gt;&lt;/a&gt;一、软件包管理&lt;/h2&gt;&lt;p&gt;软件包管理是一种在系统上安装、维护软件的方法。可以通过 Lunux 经销商发布的软件包来安装，也可通
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>MySQL学习（一）安装环境</title>
    <link href="http://yoursite.com/2020/05/03/MySQL%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%AE%89%E8%A3%85%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/05/03/MySQL学习（一）安装环境/</id>
    <published>2020-05-03T06:00:30.000Z</published>
    <updated>2020-05-03T06:05:11.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://dev.mysql.com/doc/refman/5.7/en/" target="_blank" rel="external">https://dev.mysql.com/doc/refman/5.7/en/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;h1 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h1&gt;&lt;p&gt;&lt;a 
      
    
    </summary>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>《Linux命令行大全》阅读笔记</title>
    <link href="http://yoursite.com/2020/04/25/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%A4%A7%E5%85%A8%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/04/25/《Linux命令行大全》阅读笔记/</id>
    <published>2020-04-24T20:31:36.000Z</published>
    <updated>2020-04-28T15:52:11.425Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h1><h2 id="学习shell"><a href="#学习shell" class="headerlink" title="学习shell"></a>学习shell</h2><h3 id="shell是什么"><a href="#shell是什么" class="headerlink" title="shell是什么"></a>shell是什么</h3><p>shell 是一个接收由键盘输入的命令，并将其传递给操作系统来执行的程序。sh是最初的 UNIX shell 程序，bash 是 sh 的增强版本，在 Linux 系统中使用 terminal 与 shell 进行交互。</p><p>几个简单的命令：</p><ul><li>date：显示系统当前日志。</li><li>cal：显示当月的日志。</li><li>df：查看磁盘驱动器的当前可用空间。</li><li>free：显示可用内存。</li></ul><h2 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h2><p>Linux 系统中无论多少驱动器或存储设备与计算机相连，只有一个目录树，存储设备挂载到文件系统树的不同位置。</p><p>几个常用的目录命令：</p><ul><li>pwd：显示当前工作目录。</li><li>ls：列出工作目录的文件和目录。</li><li>cd：切换目录。</li><li>cd - ：切换到当前的工作目录。</li><li>cd ~username：切换到其他用户的目录。</li></ul><h2 id="Linux-系统"><a href="#Linux-系统" class="headerlink" title="Linux 系统"></a>Linux 系统</h2><h3 id="ls-命令的乐趣"><a href="#ls-命令的乐趣" class="headerlink" title="ls 命令的乐趣"></a>ls 命令的乐趣</h3><p>ls 可以指定多个问题的目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ ls ~ /usr</div></pre></td></tr></table></figure></p><p>选项和参数：</p><ul><li>-a：列出所有文件，包括隐藏的文件。</li><li>-l：使用长格式显示结果。</li><li>-r：字母降序。</li><li>-t：按修改时间排序。</li><li>-S：按照文件大小对结果排序。</li></ul><p>格式内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">-rw-r--r-- 1 root root 47584 2012-04-03 11:05 xxx.png</div><div class="line">drwxrwxr-x 1 root root 47584 2012-04-03 11:05 xxx.png</div></pre></td></tr></table></figure></p><p>第一列，”-“ 表示是不同文件，”d” 表示目录。第二列，”1” 文件硬链接数目。47584 表示字节数的文件大小。</p><h3 id="file-确定文件类型"><a href="#file-确定文件类型" class="headerlink" title="file 确定文件类型"></a>file 确定文件类型</h3><p>file 命令可以用来确定文件类型；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ file picture.jpg</div></pre></td></tr></table></figure></p><p>类 UNIX 系统中，所有的东西都是一个文件。</p><h3 id="less-查看文本文件内容"><a href="#less-查看文本文件内容" class="headerlink" title="less 查看文本文件内容"></a>less 查看文本文件内容</h3><p>使用 less 命令查看文本文件内容，文件内容按页查看。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ less /etc/passwd</div></pre></td></tr></table></figure></p><p>less 程序的常用的键盘命令：</p><ul><li>b：后翻一页。</li><li>space：前翻一页。</li><li>G：文件末尾。</li><li>g：文件开头。</li><li>/char：查找文件内容。</li><li>n：下一个出现的字符。</li><li>q：退出。</li></ul><h3 id="Linux-系统中的一些目录"><a href="#Linux-系统中的一些目录" class="headerlink" title="Linux 系统中的一些目录"></a>Linux 系统中的一些目录</h3><ul><li>/：根目录。</li><li>/bin：系统启动和运行所必须的二进制文件（程序）。</li><li>/boot：内核启动相关文件。</li><li>/dev：包含设备节点的目录。</li><li>/etc：</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;第一部分&quot;&gt;&lt;a href=&quot;#第一部分&quot; class=&quot;headerlink&quot; title=&quot;第一部分&quot;&gt;&lt;/a&gt;第一部分&lt;/h1&gt;&lt;h2 id=&quot;学习shell&quot;&gt;&lt;a href=&quot;#学习shell&quot; class=&quot;headerlink&quot; title=&quot;学习s
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>绩效反思</title>
    <link href="http://yoursite.com/2020/04/13/%E7%BB%A9%E6%95%88%E5%8F%8D%E6%80%9D/"/>
    <id>http://yoursite.com/2020/04/13/绩效反思/</id>
    <published>2020-04-13T15:05:44.000Z</published>
    <updated>2020-04-13T15:20:22.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="惨不忍睹"><a href="#惨不忍睹" class="headerlink" title="惨不忍睹"></a>惨不忍睹</h2><h4 id="反映问题"><a href="#反映问题" class="headerlink" title="反映问题"></a>反映问题</h4><ul><li>定位问题要精确到前端还是后端</li><li>沟通专业一点</li><li>测试效率和质量有待提升</li><li>责任意识，有敷衍的情况发生</li><li>加强提取有效信息的能力</li><li>业务和技术加强主动</li><li>需求评审要主动</li><li>对于复杂的功能需求没法独立完成</li><li>希望多问问题，不了解的问题积极咨询</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;惨不忍睹&quot;&gt;&lt;a href=&quot;#惨不忍睹&quot; class=&quot;headerlink&quot; title=&quot;惨不忍睹&quot;&gt;&lt;/a&gt;惨不忍睹&lt;/h2&gt;&lt;h4 id=&quot;反映问题&quot;&gt;&lt;a href=&quot;#反映问题&quot; class=&quot;headerlink&quot; title=&quot;反映问题&quot;&gt;&lt;/a
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>networkx-初探</title>
    <link href="http://yoursite.com/2018/12/17/networkx-%E5%88%9D%E6%8E%A2/"/>
    <id>http://yoursite.com/2018/12/17/networkx-初探/</id>
    <published>2018-12-17T08:35:46.000Z</published>
    <updated>2018-12-18T02:44:05.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="networkx-初探"><a href="#networkx-初探" class="headerlink" title="networkx 初探"></a>networkx 初探</h2><ul><li><a href="#创建一个图">创建一个图</a></li><li><a href="#节点">节点</a></li><li><a href="#边">边</a></li><li><a href="#访问边">访问边</a></li><li><a href="#添加属性">添加属性</a></li><li><a href="#有向图">有向图</a><br><br></li></ul><p>在撰写论文的时候经常需要画类似网络连接图，networkx 是一个常用的网络分析包，我们使用它结合 matplotlib 来完成画图任务，下面介绍 networkx 的一些基本概念。</p><h3 id="创建一个图"><a href="#创建一个图" class="headerlink" title="创建一个图"></a>创建一个图</h3><p>创建一个没有节点和边的图：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> networkx <span class="keyword">as</span> nx</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G=nx.Graph()</div></pre></td></tr></table></figure></p><p>在 networkx 中 nodes 可以是任何可哈希的对象，包括 string/image/xml/graph等。</p><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><p>向图中添加，读取节点有多种方式。</p><p>常用的方式添加节点：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_node(<span class="number">1</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_nodes_from([<span class="number">2</span>,<span class="number">3</span>])</div></pre></td></tr></table></figure></p><p>通过载入 nbunchd 可迭代对象方式添加节点:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>H=nx.path_graph(<span class="number">10</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_nodes_from(H)</div></pre></td></tr></table></figure></p><p>将图作为节点添加：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_node(H)</div></pre></td></tr></table></figure></p><p>删除节点：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remove_node(H)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.remove_nodes_from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div></pre></td></tr></table></figure></p><h3 id="边"><a href="#边" class="headerlink" title="边"></a>边</h3><p>向图里添加边：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edge(<span class="number">1</span>,<span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>e=(<span class="number">2</span>,<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edge(*e) <span class="comment"># unpack edge tuple*</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">1</span>,<span class="number">3</span>)])</div></pre></td></tr></table></figure></p><p>通过载入 nbunchd 可迭代对象方式添加边:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edges_from(H.edges())</div></pre></td></tr></table></figure></p><p>删除边：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>Graph.remove_edge(<span class="number">1</span>, <span class="number">2</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>Graph.remove_edges_from([(<span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.clear() <span class="comment"># 删除所有边</span></div></pre></td></tr></table></figure></p><p>查看边和节点：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.nodes()</div><div class="line">[<span class="string">'a'</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">'spam'</span>, <span class="string">'m'</span>, <span class="string">'p'</span>, <span class="string">'s'</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.edges()</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">1</span>, <span class="number">3</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.neighbors(<span class="number">1</span>)</div><div class="line">[<span class="number">2</span>, <span class="number">3</span>]</div></pre></td></tr></table></figure></p><p>查看节点和边的个数：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.number_of_nodes()</div><div class="line"><span class="number">8</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.number_of_edges()</div><div class="line"><span class="number">2</span></div></pre></td></tr></table></figure></p><p>通过其他图的边创建图：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>H=nx.DiGraph(G)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H.edges()</div><div class="line">[(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">2</span>, <span class="number">1</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>edgelist=[(<span class="number">0</span>,<span class="number">1</span>),(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">2</span>,<span class="number">3</span>)]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>H=nx.Graph(edgelist)</div></pre></td></tr></table></figure></p><h3 id="访问边"><a href="#访问边" class="headerlink" title="访问边"></a>访问边</h3><p>访问邻边：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G[<span class="number">1</span>]</div><div class="line">&#123;<span class="number">2</span>: &#123;&#125;&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G[<span class="number">1</span>][<span class="number">2</span>]</div><div class="line">&#123;&#125;</div></pre></td></tr></table></figure></p><p>设置边属性:<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edge(<span class="number">1</span>,<span class="number">3</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G[<span class="number">1</span>][<span class="number">3</span>][<span class="string">'color'</span>]=<span class="string">'blue'</span></div></pre></td></tr></table></figure></p><h3 id="添加属性"><a href="#添加属性" class="headerlink" title="添加属性"></a>添加属性</h3><p>为图添加属性：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G = nx.Graph(day=<span class="string">"Friday"</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.graph</div><div class="line">&#123;<span class="string">'day'</span>: <span class="string">'Friday'</span>&#125;</div></pre></td></tr></table></figure></p><p>为节点添加属性：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_node(<span class="number">1</span>, time=<span class="string">'5pm'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_nodes_from([<span class="number">3</span>], time=<span class="string">'2pm'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.node[<span class="number">1</span>]</div><div class="line">&#123;<span class="string">'time'</span>: <span class="string">'5pm'</span>&#125;</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.node[<span class="number">1</span>][<span class="string">'room'</span>] = <span class="number">714</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.nodes(data=<span class="keyword">True</span>)</div><div class="line">[(<span class="number">1</span>, &#123;<span class="string">'room'</span>: <span class="number">714</span>, <span class="string">'time'</span>: <span class="string">'5pm'</span>&#125;), (<span class="number">3</span>, &#123;<span class="string">'time'</span>: <span class="string">'2pm'</span>&#125;)]</div></pre></td></tr></table></figure></p><p>为边添加属性：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edge(<span class="number">1</span>, <span class="number">2</span>, weight=<span class="number">4.7</span> )</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edges_from([(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">4</span>,<span class="number">5</span>)], color=<span class="string">'red'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.add_edges_from([(<span class="number">1</span>,<span class="number">2</span>,&#123;<span class="string">'color'</span>:<span class="string">'blue'</span>&#125;), (<span class="number">2</span>,<span class="number">3</span>,&#123;<span class="string">'weight'</span>:<span class="number">8</span>&#125;)])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G[<span class="number">1</span>][<span class="number">2</span>][<span class="string">'weight'</span>] = <span class="number">4.7</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>G.edge[<span class="number">1</span>][<span class="number">2</span>][<span class="string">'weight'</span>] = <span class="number">4</span></div></pre></td></tr></table></figure></p><h3 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h3><p>networkx 提供了查看出度、入度、邻接节点等方法处理有向图。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>DG=nx.DiGraph()</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>DG.add_weighted_edges_from([(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0.5</span>), (<span class="number">3</span>,<span class="number">1</span>,<span class="number">0.75</span>)]) <span class="comment">#构建有向图</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>DG.out_degree(<span class="number">1</span>,weight=<span class="string">'weight'</span>) <span class="comment"># 查看出度</span></div><div class="line"><span class="number">0.5</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>DG.degree(<span class="number">1</span>,weight=<span class="string">'weight'</span>) <span class="comment"># 查看出度入度之和</span></div><div class="line"><span class="number">1.25</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>DG.successors(<span class="number">1</span>) <span class="comment"># 查看临界节点</span></div><div class="line">[<span class="number">2</span>]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>DG.neighbors(<span class="number">1</span>)</div><div class="line">[<span class="number">2</span>]</div></pre></td></tr></table></figure></p><p>参考：<a href="https://networkx.github.io/documentation/stable/tutorial.html#" target="_blank" rel="external">networkx 官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;networkx-初探&quot;&gt;&lt;a href=&quot;#networkx-初探&quot; class=&quot;headerlink&quot; title=&quot;networkx 初探&quot;&gt;&lt;/a&gt;networkx 初探&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#创建一个图&quot;&gt;创建一个图&lt;/a&gt;&lt;/
      
    
    </summary>
    
    
      <category term="networkx Python" scheme="http://yoursite.com/tags/networkx-Python/"/>
    
  </entry>
  
  <entry>
    <title>Pro Git 阅读笔记</title>
    <link href="http://yoursite.com/2018/11/28/Pro-Git-%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2018/11/28/Pro-Git-阅读笔记/</id>
    <published>2018-11-28T11:03:29.000Z</published>
    <updated>2018-11-28T11:14:26.868Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ProGit-阅读笔记"><a href="#ProGit-阅读笔记" class="headerlink" title="ProGit 阅读笔记"></a>ProGit 阅读笔记</h2><ul><li><a href="#git-由来">Git 由来</a><ul><li><a href="#版本控制">版本控制</a></li><li><a href="#集中化的版本控制系统">集中化的版本控制系统</a></li><li><a href="#分布式版本控制系统">分布式版本控制系统</a></li><li><a href="#git-相比于-svn-等的特点">Git 相比于 svn 等的特点</a></li><li><a href="#三种状态">三种状态</a></li></ul></li><li><a href="#git-基础">Git 基础</a><ul><li><a href="#取得项目的-git-仓库">取得项目的 Git 仓库</a></li><li><a href="#记录每次更新到仓库">记录每次更新到仓库</a></li><li><a href="#查看历史提交">查看历史提交</a></li><li><a href="#撤销操作">撤销操作</a></li><li><a href="#远程仓库的使用">远程仓库的使用</a></li></ul></li><li><a href="#git-分支">Git 分支</a><ul><li><a href="#何谓分支">何谓分支</a></li><li><a href="#基本的分支与合并">基本的分支与合并</a></li><li><a href="#分支管理">分支管理</a></li><li><a href="#远程分支">远程分支</a></li><li><a href="#衍合">衍合</a></li></ul></li><li><a href="#服务器上的-git">服务器上的 Git</a><ul><li><a href="#协议">协议</a><ul><li><a href="#ssh-协议">SSH 协议</a></li><li><a href="#git-协议">Git 协议</a></li><li><a href="#https-协议">HTTP/S 协议</a></li></ul></li></ul></li><li><a href="#分布式-git">分布式 Git</a><ul><li><a href="#储藏">储藏</a></li><li><a href="#重写历史">重写历史</a></li><li><a href="#衍合与挑拣">衍合与挑拣</a><br><br></li></ul></li></ul><h1 id="Git-由来"><a href="#Git-由来" class="headerlink" title="Git 由来"></a>Git 由来</h1><h2 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h2><p>版本控制是一种记录若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p><h2 id="集中化的版本控制系统"><a href="#集中化的版本控制系统" class="headerlink" title="集中化的版本控制系统"></a>集中化的版本控制系统</h2><p>如 CVS, Subversion 等，都有一个单一的集中管理的服务器,保存所有文件的修订版本,客户端通过客户端连接到服务器,取出最新文件或者提交更新。</p><img src="/2018/11/28/Pro-Git-阅读笔记/1.jpg" alt="1.jpg" title=""><h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>如 Git, Bazaar 等，客户端并不只是提取最新版本的文件快照,而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的<br>本地仓库恢复。因为每一次的提取操作，实际上都是一次对代码仓库的完整备份）。</p><img src="/2018/11/28/Pro-Git-阅读笔记/2.jpg" alt="2.jpg" title=""><h2 id="Git-相比于-svn-等的特点"><a href="#Git-相比于-svn-等的特点" class="headerlink" title="Git 相比于 svn 等的特点"></a>Git 相比于 svn 等的特点</h2><ul><li>直接快照，而非比较差异，为提高性能。</li></ul><img src="/2018/11/28/Pro-Git-阅读笔记/3.jpg" alt="3.jpg" title=""><img src="/2018/11/28/Pro-Git-阅读笔记/4.jpg" alt="4.jpg" title=""><ul><li><p>近乎所有操作都可本地执行。</p><p>  由于其分布式的特点，每个客户端都保存着仓库的备份，在 Git 中的绝大多数操作都只需要访问本地文件和资源，不用连网，如提交更新。</p></li><li><p>时刻保持数据完整性。</p><p>  在保存到Git 之前，所有数据都要进行内容的校验和（checksum）计算，并将此结果作为数据的唯一标识和索引。如果文件在传输时变得不完整，或者磁盘损坏导致文件数据缺失，Git 都能立即察觉。Git 使用SHA-1 算法计算数据的校验和，通过对文件的内容或目录的结构计算出一个SHA-1 哈希值，作为指纹字符串。</p></li></ul><h2 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h2><p>对于任何一个文件，在 Git 内都只有三种状态：已提交<br>（committed），已修改（modified）和已暂存（staged）。</p><p>Git 管理项目时，文件流转的三个工作区域：Git 的本地数据目录，工作目录以􀷽暂存区<br>域。</p><img src="/2018/11/28/Pro-Git-阅读笔记/5.jpg" alt="5.jpg" title=""><h1 id="Git-基础"><a href="#Git-基础" class="headerlink" title="Git 基础"></a>Git 基础</h1><h2 id="取得项目的-Git-仓库"><a href="#取得项目的-Git-仓库" class="headerlink" title="取得项目的 Git 仓库"></a>取得项目的 Git 仓库</h2><p>从当前目录初始化:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git init</div></pre></td></tr></table></figure></p><p>从现有仓库克隆：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone git://github.com/schacon/grit.git</div></pre></td></tr></table></figure></p><p>克隆某个分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone -b breach-name git://github.com/schacon/grit.git</div></pre></td></tr></table></figure></p><h2 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h2><p>工作目录下面的所有文件都不外乎这两种状态：已跟踪或未跟踪。</p><p>已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是未更新，已修改或者已放入暂存区。而所有其他文件都属于未跟踪文件。它们既没有上次更新时的快照，也不在当前的暂存区域。</p><img src="/2018/11/28/Pro-Git-阅读笔记/6.jpg" alt="6.jpg" title=""><p>检查当前文件状态：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git status</div></pre></td></tr></table></figure></p><p>跟踪新文件以及将跟踪后更新后暂存：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git add README</div></pre></td></tr></table></figure></p><p>要暂存这次更新，需要运行git add 命令（这是个多功能命令，根据目标文件的状态不同，此命令的效果也不同：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时<br>把有冲突的文件标记为已解决状态等）</p><p>忽略某些文件，编辑 .gitignore 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ cat .gitignore</div><div class="line">*.[oa]</div><div class="line">*~</div></pre></td></tr></table></figure></p><p>查看已暂存和未暂存的更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">$ git diff</div><div class="line"></div><div class="line">修改之后还没有暂存起来的变化内</div><div class="line">容</div><div class="line"></div><div class="line">$ git diff --cached</div><div class="line"></div><div class="line">看已经暂存起来的文件和上次提交时的快照之间的差异</div></pre></td></tr></table></figure></p><p>提交更新:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit</div></pre></td></tr></table></figure></p><p>移除文件，即从已跟踪文件清除：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git rm grit.gemspec</div></pre></td></tr></table></figure></p><p>如果删除之前修改过并且已经放到暂存区域的话，则必须<br>要用强制删除选项-f（译注：即force 的首字母），以防误删除文件后丢失修改的内容。</p><p>把文件从Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。用–cached 选项即可。</p><h2 id="查看历史提交"><a href="#查看历史提交" class="headerlink" title="查看历史提交"></a>查看历史提交</h2><p>回顾提交历史：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log</div></pre></td></tr></table></figure></p><p>-2 仅显示最近的两次更新：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git log -2</div></pre></td></tr></table></figure></p><p>git log 还有其他一些选项，方便查看内容。</p><h2 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h2><p>撤消刚才的提交操作，重新提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend</div></pre></td></tr></table></figure></p><p>取消已经暂存的文件，不小心用 git add * 全加到了暂存区域。该如何撤消暂存其中的一个文件呢？取消暂存benchmarks.rb 文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git add *</div><div class="line"></div><div class="line">git reset HEAD benchmarks.rb</div></pre></td></tr></table></figure></p><p>取消对文件的修改，回到之前的状态，与上面的相比，该命令取消了未暂存的文件修改：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout -- benchmarks.rb</div></pre></td></tr></table></figure></p><h2 id="远程仓库的使用"><a href="#远程仓库的使用" class="headerlink" title="远程仓库的使用"></a>远程仓库的使用</h2><p>查看当前的远程库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote -v</div></pre></td></tr></table></figure></p><p>添加远程仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git remote add pb git://github.com/paulboone/ticgit.git</div></pre></td></tr></table></figure></p><p>从远程仓库抓取数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git fetch [remote-name]</div></pre></td></tr></table></figure></p><p>有一点很重要，<br>需要记住，fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好<br>了，才能手工合并，git pull 相当于 git fetch 和 git merge。</p><p>推送数据到远程仓库:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push [remote-name] [branch-name]</div></pre></td></tr></table></figure></p><p>重命名远端仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rename [remote-name] [new-name]</div></pre></td></tr></table></figure></p><p>删除远端仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git remote rm [remote-name]</div></pre></td></tr></table></figure></p><h1 id="Git-分支"><a href="#Git-分支" class="headerlink" title="Git 分支"></a>Git 分支</h1><h2 id="何谓分支"><a href="#何谓分支" class="headerlink" title="何谓分支"></a>何谓分支</h2><p>在Git 中提交时，会保存一个提交（commit）对象，它包含一个指向暂存内容快照的指针，作者和相关附属信息，以􀷽一定数量（也可能没有）指向该提交对象直接祖先的指针：第一次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p><img src="/2018/11/28/Pro-Git-阅读笔记/7.jpg" alt="7.jpg" title=""><img src="/2018/11/28/Pro-Git-阅读笔记/8.jpg" alt="8.jpg" title=""><blockquote><p>Git 中的分支，其实本质上仅仅是个指向 commit 对象的可变指针。</p></blockquote><p><br></p><p>创建 test 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git branch testing</div></pre></td></tr></table></figure></p><p>会在当前 commit 对象上新建一个分支指针。</p><img src="/2018/11/28/Pro-Git-阅读笔记/9.jpg" alt="9.jpg" title=""><p>切换到新建的 testing 分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git checkout testing</div></pre></td></tr></table></figure></p><h2 id="基本的分支与合并"><a href="#基本的分支与合并" class="headerlink" title="基本的分支与合并"></a>基本的分支与合并</h2><p>在 master 上与 hotfix 分支合并：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge hotfix</div></pre></td></tr></table></figure></p><img src="/2018/11/28/Pro-Git-阅读笔记/12.jpg" alt="12.jpg" title=""><p>上述方式的合并叫快进。</p><p>master 和 iss53 的合并叫合并提交:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ git checkout master</div><div class="line">$ git merge iss53</div></pre></td></tr></table></figure></p><img src="/2018/11/28/Pro-Git-阅读笔记/13.jpg" alt="13.jpg" title=""><p>有时合并的时候可能会遇到冲突，任何包含未解决冲突的文件都会以未合并（unmerged）状态列出。</p><img src="/2018/11/28/Pro-Git-阅读笔记/14.jpg" alt="14.jpg" title=""><p>可以看到======= 隔开的上半部分，是 HEAD （即 master 分支，在运行 merge 命令时检出的分支）中的内容，下半部分是在 iss53 分支中的内容。解决冲突的办法无非是二者选其一或者由你亲自整合到一起。</p><p>解决了所有文件里的所有冲突后，运行 git add 将把它们标记为已解决（resolved）。因为一旦暂存，就表示冲突已经解决。</p><h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p>给出当前所有分支的清单：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git branch</div><div class="line">  iss53</div><div class="line">* master</div><div class="line">  testing</div></pre></td></tr></table></figure></p><p>要从该清单中筛选出你已经（或尚未）与当前分支合并的分支，可以用–merge 和–no-merged 选项，比如git branch -merge 查看哪些分支已被并入当前分支：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ git branch --merged</div><div class="line">  iss53</div><div class="line">* master</div></pre></td></tr></table></figure></p><h2 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h2><p>远程分支（remote branch）是对远程仓库状态的索引。它们是一些无法移动的本地分支；只有在进行 Git 的网络活动时才会更新。</p><p>(远程仓库名)/(分支名) 这样的形式表示远程分支。</p><img src="/2018/11/28/Pro-Git-阅读笔记/15.jpg" alt="15.jpg" title=""><p>可以运行 git fetch origin 来进行同步。该命令首先找到origin 是哪个服务器，从上面获取你尚未拥有的数据，更新你本地的数据库，然后把 origin/master 的指针移到它最新的位置。</p><img src="/2018/11/28/Pro-Git-阅读笔记/16.jpg" alt="16.jpg" title=""><p>如果你有个叫 serverfix 的分支需要和他人一起开发，可以运行git push (远程仓库名) (分支名)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin serverfix:serferfix</div></pre></td></tr></table></figure><p>它的意思是“提取我的 serverfix 并更新到远程仓库的serverfix”。通过此语法，你可以把本地分支推送到某个命名不同的远程分支：若想把远程分支叫作 awesomebranch，可以用git push origin serverfix:awesomebranch 来推送数据。</p><p>删除远程分支，git push [远程名] :[分支名]。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git push origin :serverfix</div></pre></td></tr></table></figure></p><h2 id="衍合"><a href="#衍合" class="headerlink" title="衍合"></a>衍合</h2><p>把一个分支整合到另一个分支的办法有两种：merge（合并） 和 rebase（衍合）。</p><p>衍合（rebase）,有了rebase 命令，就可以把在一个分支里提交的改变在另一个分支里重放一遍。</p><p>它的原理是回到两个分支（你所在的分支和你想要衍合进去的分支）的共同祖先，提取你所在分支每次提交时产生的差异（diff），把这些差异分别保存到临时文件里，然后从当前分支转换到你需要衍合入的分支，依序施用每一个差异补丁文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git checkout experiment</div><div class="line">$ git rebase master</div><div class="line">$ git checkout master</div><div class="line">$ git merge experiment</div></pre></td></tr></table></figure><img src="/2018/11/28/Pro-Git-阅读笔记/17.jpg" alt="17.jpg" title=""><p>衍合的风险:永远不要衍合那些已经推送到公共仓库的更新。</p><h1 id="服务器上的-Git"><a href="#服务器上的-Git" class="headerlink" title="服务器上的 Git"></a>服务器上的 Git</h1><h2 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h2><p>Git 可以使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和HTTP 协议。</p><h3 id="SSH-协议"><a href="#SSH-协议" class="headerlink" title="SSH 协议"></a>SSH 协议</h3><p>SSH 是唯一一个同时便于读和写操作的网络协议。SSH 同<br>时也是一个验证授权的网络协议。</p><p>通过SSH 克隆一个Git 仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone ssh://user@server:project.git</div></pre></td></tr></table></figure></p><p>Git 默认使用 SSH。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone user@server:project.git</div></pre></td></tr></table></figure></p><p>优点：</p><pre><code>* 首先，如果你想拥有对网络仓库的写权限，基本上不可能不使用 SSH 。* 再次，通过 SSH 进行访问是安全的——所有数据传输都是加密和授权的。</code></pre><p>缺点：</p><pre><code>* SSH 的限制在于你不能通过它实现仓库的匿名访问。即使仅为读取数据，人们也必须在能通过 SSH 访问主机的前提下才能访问仓库，这使得 SSH 不利于开源的项目。</code></pre><h3 id="Git-协议"><a href="#Git-协议" class="headerlink" title="Git 协议"></a>Git 协议</h3><p>这是一个包含在 Git 软件包中的特殊守护进程； 它会监听一个提供类似于 SSH 服务的特定端口（9418）</p><p>优点：</p><pre><code>* Git 协议是现存最快的传输协议，因为省去了加密和授权的开销。</code></pre><p>缺点：</p><pre><code>* Git 协议消极的一面是缺少授权机制。用 Git 协议作为访问项目的唯一方法通常是不可取的。一般做法是，同时提供SSH 接口，让几个开发者拥有推送（写）权限，其他人通过git:// 拥有只读权限。</code></pre><h3 id="HTTP-S-协议"><a href="#HTTP-S-协议" class="headerlink" title="HTTP/S 协议"></a>HTTP/S 协议</h3><p>HTTP 或 HTTPS 协议的优美之处在于架设的简便性。基本上， 只需要把 Git 的纯仓库文件放在 HTTP 的文件根目录下，配置一个特定的 post-update 挂钩（hook），就搞定了。</p><p>克隆仓库：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git clone http://example.com/gitproject.git</div></pre></td></tr></table></figure></p><p>优点：</p><pre><code>* 使用 HTTP 协议的好处是易于架设。几条必要的命令就可以让全世界读取到仓库的内容。</code></pre><p>缺点：</p><pre><code>* 相对来说客户端效率更低。克隆或者下载仓库内容可能会花费更多时间，而且 HTTP 传输的体积和网络开销比其他任何一个协议都大。因为它没有按需供应的能力——传输过程中没有服务端的动态计算——因而 HTTP 协议经常会被称为傻瓜(dumb) 协议。</code></pre><h1 id="分布式-Git"><a href="#分布式-Git" class="headerlink" title="分布式 Git"></a>分布式 Git</h1><h2 id="储藏"><a href="#储藏" class="headerlink" title="储藏"></a>储藏</h2><p>经常有这样的事情发生，当你正在进行项目中某一部分的工作，里面的东西处于一个比较杂乱的状态，而你想转到其他分支上进行一些工作。问题是，你不想提交进行了一半的工作，否则以后你无法回到这个工作点。解决这个问题的办法就是git stash命令。</p><p>现在你想切换分支，但是你还不想提交你正在进行中的工作；所以你储藏这些变更。为了往堆栈推送一个新的储藏，只要运行git stash：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash</div></pre></td></tr></table></figure><p>要查看现有的储藏，你可以使用git stash list：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git stash list</div><div class="line">stash@&#123;0&#125;: WIP on master: 049d078 added the index file</div><div class="line">stash@&#123;1&#125;: WIP on master: c264051... Revert &quot;added file_size&quot;</div><div class="line">stash@&#123;2&#125;: WIP on master: 21d80a5... added number to log</div></pre></td></tr></table></figure></p><p>你可以重新应用你刚刚实施的储藏:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">$ git stash apply</div><div class="line"></div><div class="line">or</div><div class="line"></div><div class="line">$ git stash apply stash@2</div></pre></td></tr></table></figure></p><p>apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。要移除它，你可以运行git stash drop：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git stash drop stash@&#123;0&#125;</div></pre></td></tr></table></figure></p><p>你也可以运行git stash pop 来重新应用储藏，同时立刻将其从堆栈中移走。</p><h2 id="重写历史"><a href="#重写历史" class="headerlink" title="重写历史"></a>重写历史</h2><p>改变最近一次提交:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ git commit --amend</div></pre></td></tr></table></figure></p><p>修改多个提交说明:</p><p>如果你想修改或改变说明、增加文件、删除文件或任何其他事情。你可以通过给 git rebase 增加 -i 选项来以交互方式地运行 rebase。你必须通过告诉命令衍合到哪次提交，来指明你需要重写的提交的回溯深度。</p><p>修改最近三次提交，范围内的每一次提交都会被重写，无论你是否修改说明：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">$ git rebase -i HEAD~3</div><div class="line"></div><div class="line">pick f7f3f6d changed my name a bit</div><div class="line">pick 310154e updated README formatting and added blame</div><div class="line">pick a5f4a0d added cat-file</div><div class="line"></div><div class="line"># Rebase 710f0f8..a5f4a0d onto 710f0f8</div><div class="line">#</div><div class="line"># Commands:</div><div class="line"># p, pick = use commit</div><div class="line"># e, edit = use commit, but stop for amending</div><div class="line"># s, squash = use commit, but meld into previous commit</div><div class="line">#</div><div class="line"># If you remove a line here THAT COMMIT WILL BE LOST.</div><div class="line"># However, if you remove everything, the rebase will be aborted.</div><div class="line">#</div></pre></td></tr></table></figure></p><p>可以使用交互式的衍合来彻底重排或删除提交。</p><p>重排提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pick f7f3f6d changed my name a bit</div><div class="line">pick 310154e updated README formatting and added blame</div><div class="line">pick a5f4a0d added cat-file</div></pre></td></tr></table></figure></p><p>改为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pick 310154e updated README formatting and added blame</div><div class="line">pick f7f3f6d changed my name a bit</div></pre></td></tr></table></figure></p><p>压制(Squashing)提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pick f7f3f6d changed my name a bit</div><div class="line">squash 310154e updated README formatting and added blame</div><div class="line">squash a5f4a0d added cat-file</div></pre></td></tr></table></figure></p><p>当你保存并退出编辑器，Git 会应用全部三次变更然后将你送回编辑器来归并三次提交说明。</p><p>拆分提交就是撤销一次提交，然后多次部分地暂存或提交直到结束。</p><p>将“updated README formatting and added blame”拆分成两次提交：第一次为“updated<br>README formatting”，第二次为“added blame”。你可以在rebase -i脚本中修改你想拆分的提交前的指令<br>为“edit”。</p><p>拆分提交：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pick f7f3f6d changed my name a bit</div><div class="line">edit 310154e updated README formatting and added blame</div><div class="line">pick a5f4a0d added cat-file</div></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$ git reset HEAD^</div><div class="line">$ git add README</div><div class="line">$ git commit -m &apos;updated README formatting&apos;</div><div class="line">$ git add lib/simplegit.rb</div><div class="line">$ git commit -m &apos;added blame&apos;</div><div class="line">$ git rebase --continue</div></pre></td></tr></table></figure><h2 id="衍合与挑拣"><a href="#衍合与挑拣" class="headerlink" title="衍合与挑拣"></a>衍合与挑拣</h2><p>另一个引入代码的方法是挑拣。挑拣类似于针对某次特定提交的衍合。它首先提取某次提交的补丁，然后试着应用在当前分支上。如果某个特性分支上有多个 commits，但你只想引入其中之一就可以使用这种方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf</div><div class="line">Finished one cherry-pick.</div><div class="line">[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;</div><div class="line">3 files changed, 17 insertions(+), 3 deletions(-)</div></pre></td></tr></table></figure><img src="/2018/11/28/Pro-Git-阅读笔记/18.jpg" alt="18.jpg" title="">]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ProGit-阅读笔记&quot;&gt;&lt;a href=&quot;#ProGit-阅读笔记&quot; class=&quot;headerlink&quot; title=&quot;ProGit 阅读笔记&quot;&gt;&lt;/a&gt;ProGit 阅读笔记&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#git-由来&quot;&gt;Git 由来&lt;/a&gt;
      
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>二叉平衡树——B-树，B+树与MySQL数据库B-Tree索引</title>
    <link href="http://yoursite.com/2018/09/02/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E2%80%94%E2%80%94B-%E6%A0%91%EF%BC%8CB-%E6%A0%91%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/09/02/二叉平衡树——B-树，B-树与MySQL数据库索引/</id>
    <published>2018-09-01T22:44:45.000Z</published>
    <updated>2018-09-07T17:58:16.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><blockquote><p>AVL树是带有平衡条件的二叉查找树，该平衡条件是每个节点的左子树和右子树的高度最多差1的二叉查找树。（空树的高度定义为-1。）</p></blockquote><p>在该树上的所有操作的时间复杂度为O(logN)。插入过程中涉及到了单旋转和双旋转，具体实现<a href="https://github.com/Lucky4/Data-Structures-and-Algorithm-Analysis-in-C/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.cpp" target="_blank" rel="external">请看</a>。<br><br></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>阶为M的B-树是一棵有下列结构特性的树：</p><ul><li>树的根的儿子数在2和M之间。</li><li>除根外，所有非树叶节点的儿子树在M/2（向上取整）和M之间。</li><li>所有的树叶都在相同的深度上。</li><li>每个节点存放至少2个，至多M个关键字。<br><br></li></ul><p>B-树深度最多是logM/2(N)向上取整，Insert和Delete操作复杂度为O(MlogM(N))，Find操作复杂度为O(logN)。<br><br></p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>B+树与B-树向比，增加了以下特性：</p><ul><li>非叶子结点的子树指针与关键字个数相同。每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>为所有叶子结点增加一个链指针。</li><li>所有关键字都在叶子结点出现。<br><br></li></ul><h2 id="MySQL数据库B-Tree索引"><a href="#MySQL数据库B-Tree索引" class="headerlink" title="MySQL数据库B-Tree索引"></a>MySQL数据库B-Tree索引</h2><p><a href="https://blog.csdn.net/no_endless/article/details/77073549" target="_blank" rel="external">MySQL 聚集索引/非聚集索引简述</a><br><a href="https://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="external">MyISAM和InnoDB的索引实现</a><br><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="external">参考1</a><br><a href="https://blog.csdn.net/no_endless/article/details/77073549" target="_blank" rel="external">参考2</a><br><a href="https://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="external">参考3</a><br>参考4《数据结构与算法分析：C语言描述》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉平衡树&quot;&gt;&lt;a href=&quot;#二叉平衡树&quot; class=&quot;headerlink&quot; title=&quot;二叉平衡树&quot;&gt;&lt;/a&gt;二叉平衡树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;AVL树是带有平衡条件的二叉查找树，该平衡条件是每个节点的左子树和右子树的高度最多差1的二
      
    
    </summary>
    
    
      <category term="二叉平衡树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——Dict对象</title>
    <link href="http://yoursite.com/2018/08/28/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94Dict%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/08/28/Python源码剖析——Dict对象/</id>
    <published>2018-08-28T02:02:32.000Z</published>
    <updated>2018-08-28T22:04:07.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现代的编程语言都在语言级或标准库中提供某种<code>关联式的容器</code>，容器中的元素通常是以(key,value)的形式存在的。</p><p>关联式容器总会极大地关注键的搜索效率，其实现都会基于良好的数据结构，如C++中的map的实现基于红黑树，搜索时间复杂度为O(logN)。</p><p>Python中的关联容器<code>PyDictObject</code>即dict是基于<code>散列表</code>实现的。Dict对搜索的效率要求很高，因为Python本身的实现中dict被大量的使用，如Python字节码的运行环境，其中存放变量名和变量值，通过查找变量名获得变量值。因此dict的实现没有采用平衡二叉树，而是采用了散列表，最优情况下散列表的搜索复杂度为O(1)。<br><br></p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>Python在处理哈希冲突的时候采用<code>开放地址法</code>，在删除散列表中的元素的时候，不能进行真正的删除，因为会导致冲突探测链的探测过早的结束，所以Python采用一种<code>伪删除</code>的方式。<br><br></p><h2 id="PyDictObject"><a href="#PyDictObject" class="headerlink" title="PyDictObject"></a>PyDictObject</h2><h4 id="关联容器的entry"><a href="#关联容器的entry" class="headerlink" title="关联容器的entry"></a>关联容器的entry</h4><p>关联容器中的一个(key,value)元素称为一个<code>entry</code>或slot。Python中，一个entry定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dictobject.h</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="comment">/* Cached hash code of me_key.  Note that hash codes are C longs.</span></div><div class="line">     * We have to use Py_ssize_t instead because dict_popitem() abuses</div><div class="line">     * me_hash to hold a search finger.</div><div class="line">     */</div><div class="line">    Py_ssize_t me_hash;</div><div class="line">    PyObject *me_key;</div><div class="line">    PyObject *me_value;</div><div class="line">&#125; PyDictEntry;</div></pre></td></tr></table></figure><p>PyDictObject存放的是PyObject*，可以存放任何Python对象。<code>me_hash</code>域存储的是<code>me_key</code>的散列值。</p><p>PyDictObject中entry可以在3种状态间转换：</p><ul><li><code>Unused态</code>：该entry从现在到之前都没有存储过(key,value)对。</li><li><code>Active态</code>：存储了一个(key,value)对entry便传化为Active态。</li><li><code>Dummy态</code> ： entry中的(key,value)对被“伪删除”后，进入Dummy态。</li></ul><img src="/2018/08/28/Python源码剖析——Dict对象/pic1.jpg" alt="entry三种状态" title="entry三种状态"><p><br></p><h4 id="关联容器的实现"><a href="#关联容器的实现" class="headerlink" title="关联容器的实现"></a>关联容器的实现</h4><p>关联容器PyDictObject是一大堆entry的集合，集合结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dictobject.j</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictobject</span> &#123;</span></div><div class="line">    PyObject_HEAD</div><div class="line">    Py_ssize_t ma_fill;  <span class="comment">/* # Active + # Dummy */</span></div><div class="line">    Py_ssize_t ma_used;  <span class="comment">/* # Active */</span></div><div class="line"></div><div class="line">    <span class="comment">/* The table contains ma_mask + 1 slots, and that's a power of 2.</span></div><div class="line">     * We store the mask instead of the size because the mask is more</div><div class="line">     * frequently needed.</div><div class="line">     */</div><div class="line">    Py_ssize_t ma_mask;</div><div class="line"></div><div class="line">    <span class="comment">/* ma_table points to ma_smalltable for small tables, else to</span></div><div class="line">     * additional malloc'ed memory.  ma_table is never NULL!  This rule</div><div class="line">     * saves repeated runtime null-tests in the workhorse getitem and</div><div class="line">     * setitem calls.</div><div class="line">     */</div><div class="line">    PyDictEntry *ma_table;</div><div class="line">    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class="keyword">long</span> hash);</div><div class="line">    PyDictEntry ma_smalltable[PyDict_MINSIZE];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>当PyDictObject中的entry数量超过<code>8</code>个时，Python会认为这是一个大dict了，将会申请额外内存空间，并将<code>ma_table</code>指向这块空间。</p><img src="/2018/08/28/Python源码剖析——Dict对象/pic2.jpg" alt="entry三种状态" title="entry三种状态"><p><br></p><h4 id="PyDictObject中元素搜索"><a href="#PyDictObject中元素搜索" class="headerlink" title="PyDictObject中元素搜索"></a>PyDictObject中元素搜索</h4><p>PyDictObject提供两种搜索策略，<code>lookdict</code>和<code>lookdict_string</code>，Python默认搜索方式为<code>lookdict_string<code>。</code></code></p><p>Python获取冲突链上的第一个entry的过程采用，将hash值（我认为是元素序号）与entry的数量做一个与操作，结果自然会落在entry的数量之下。</p><p><code>freeslot</code>正是用来指向探测序列中第一个处于Dummy态的entry，如果搜索失败，freeslot会提供一个处于Dummy态的entry。<br><br></p><p>根据hash值获得的冲突探测链上<code>第一个entry</code>与待查找的元素的比较：</p><ol><li>根据hash值获得entry的索引，是冲突探测链上的第一个entry的索引。</li><li>在两种情况下搜索结束：<ul><li>entry处于Unused态，表明冲突探测链搜索完成，搜索失败；</li><li>ep-&gt;me_key == key，表明entry的key与待搜索的key匹配，搜索成功。</li></ul></li><li>若当前entry处于Dummy态，这是freeslot。</li><li>检查Active态entry中的key与待查找的key是否“值相同”，若成立，搜索成功。</li></ol><p><code>遍历探测链</code>时发生的lookdict所进行的操作：</p><ol><li>根据Python所采用的探测函数，获得探测链中的下一个待检查的entry。</li><li>检查到一个Unused态entry，表明搜索失败，这时有两种结果：<ul><li>如果freeslot不为空，则返回freeslot所指entry。</li><li>如果freeslot为空，则返回该Unused态entry。</li></ul></li><li>检查entry中的key与带查找的key是否符合“引用相同”规则。</li><li>检查entry中的key与待查找的key是否符合“值相同”规则。</li><li>遍历过程中，如果发现Dummy态entry，且freeslot未设置，则设置freeslot。<br><br></li></ol><h4 id="PyDictObject插入"><a href="#PyDictObject插入" class="headerlink" title="PyDictObject插入"></a>PyDictObject插入</h4><p>搜索成功，返回处于Active的entry，直接替换me_value。<br>搜索失败，返回Unused或Dummy的entry，完整设置me_key、me_hash和me_value。</p><p>如果table的装载率大于<code>2/3</code>时，后续的插入动作遭遇到冲突的可能性会非常大，在装载率大于或等于<code>2/3</code>时需要改变table的大小。<br><br></p><h4 id="PyDictObject的删除"><a href="#PyDictObject的删除" class="headerlink" title="PyDictObject的删除"></a>PyDictObject的删除</h4><p>先计算hash值，搜索相应的entry，删除entry维护的元素，将entry从Active态变换为Dummy态，调整PyDictObject对象中维护table使用情况的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现代的编程语言都在语言级或标准库中提供某种&lt;code&gt;关联式的容器&lt;/code&gt;，容器中的元素通常是以(key,value)的形式存在的。&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>堆和栈的区别</title>
    <link href="http://yoursite.com/2018/08/21/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/21/堆和栈的区别/</id>
    <published>2018-08-21T01:44:57.000Z</published>
    <updated>2018-08-26T19:55:24.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存分配中堆和栈的区别"><a href="#内存分配中堆和栈的区别" class="headerlink" title="内存分配中堆和栈的区别"></a>内存分配中堆和栈的区别</h2><p>管理方式：</p><ul><li>栈由编译器自动管理。</li><li>堆由程序员手工管理。</li></ul><p>空间大小：</p><ul><li>栈一般有1~2M。</li><li>32位操作系统堆可以达到4G。</li></ul><p>碎片问题：</p><ul><li>栈的先进后出的方式导致它不会产生碎片。</li><li>堆频繁的malloc/free会产生不连续的空间，造成碎片。</li></ul><p>生长方向不同：</p><ul><li>栈向下生长。</li><li>堆向上生长。</li></ul><p>分配效率：</p><ul><li>栈由于有就是那几底层支持，效率较高。</li><li>堆需要一定算法分配可用内存空间，效率较低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存分配中堆和栈的区别&quot;&gt;&lt;a href=&quot;#内存分配中堆和栈的区别&quot; class=&quot;headerlink&quot; title=&quot;内存分配中堆和栈的区别&quot;&gt;&lt;/a&gt;内存分配中堆和栈的区别&lt;/h2&gt;&lt;p&gt;管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈由编译器自动管理。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——Python内建对象</title>
    <link href="http://yoursite.com/2018/08/15/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94Python%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/08/15/Python源码剖析——Python内建对象/</id>
    <published>2018-08-14T23:18:29.000Z</published>
    <updated>2018-08-15T16:05:29.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在Python的世界中，一切都是对象，包括面向对象中的“类”也是通过Python内的对象来实现的。</p></blockquote><h2 id="Python内的对象"><a href="#Python内的对象" class="headerlink" title="Python内的对象"></a>Python内的对象</h2><p>在Python中，对象就是C的结构体在堆上申请的一块内存。</p><ul><li>Python中所有的内建的类型对象(int, str等对象)都是被静态初始化的。</li><li>对象一旦创建, 内存大小就是不变的(变长的对象内部维护一个指向可变内存的指针)</li></ul><h3 id="对象的基石——PyObject"><a href="#对象的基石——PyObject" class="headerlink" title="对象的基石——PyObject"></a>对象的基石——PyObject</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Python的世界中，一切都是对象，包括面向对象中的“类”也是通过Python内的对象来实现的。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——垃圾回收机制</title>
    <link href="http://yoursite.com/2018/08/08/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/08/Python源码剖析——垃圾回收机制/</id>
    <published>2018-08-08T05:31:30.000Z</published>
    <updated>2018-08-28T22:03:23.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h4><p>在Python中，内存管理机制被抽象成一种层次似的结果。</p><ul><li><code>第0层</code>，是操作系统提供的内存管理接口，比如C运行时所提供的malloc和free接口。这一层由操作系统实现并管理。</li><li><code>第1层</code>，是Python基于第0层操作系统的内存管理接口包装而成的，因为虽然操作系统都提供了ANSI C标准所定义的内存管理接口，但是对于某些特殊的情况不同的操作系统有不同的行为。</li><li><code>第2层</code>，第一层所提供的内存管理接口其功能是有限的，加入要创建一个PyIntObject对象，还需要许多额外的工作，如设置对象的类型，初始化对象的引用计数值等。为了简化Python自身的开发，Python在比第一层更高的抽象层次上提供了第二层管理接口，主要提供了创建Python对象的接口。</li><li><code>第3层</code>，主要是对象缓冲池机制。<br><br></li></ul><h4 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h4><p>在Python中，许多时候申请的内存都是小块的内存，申请后很快又会被释放，它们不是为了创建对象，没有对象一级的内存池机制。意味着会大量执行malloc和free操作，影响Python的执行效率。</p><p>为了提高执行效率，Python引入一个<code>内存池机制</code>，管理小块内存的申请和释放。</p><p>Python默认小块内存与大块内存的分界点定在256个字节，也就是说，当申请的内存小于256字节时PyObject_Malloc会在内存池中申请内存；当申请内存大于256字节时PyObject_Malloc的行为蜕化为malloc的行为。<br><br></p><h2 id="垃圾收集机制"><a href="#垃圾收集机制" class="headerlink" title="垃圾收集机制"></a>垃圾收集机制</h2><p>在Python中，大多数对象的声明周期都是通过对象的<code>引用计数</code>来管理的。但循环引用这种状态不同通过引用计数来回收内存，需要配合另外两种垃圾收集技术，<code>标记——清除</code>和<code>分代收集</code>。<br><br></p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁（退出作用域、被del删除）时，对象的引用计数减1。如果对象的引用计数为0，那么释放其所占用的内存。</p><p>引用计数有一个问题，就是可能会产生<code>循环引用</code>，看一段代码：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(l2)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2.append(l1)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1</div><div class="line">[[[...]]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2</div><div class="line">[[[...]]]</div></pre></td></tr></table></figure></p><p>要想回收l1的内存需要先将其引用计数置为0，其引用为l2即需要先释放l2的内存。同时，回收l2的内存需要先将其引用计数置为0，其引用为l1即需要先释放l1的内存，此时造成了循环引用的状态，这些对象所占用内存永远不会被回收。</p><p>Python 中的循环引用总是发发生在container对象之间，所谓container对象即是内部可持有对其他对象引用的对象，比如list、dict、class、instance等等。当Python垃圾回收机制运行时，只会去检查container对象。</p><p>为了解决循环引用这个问题Python引用了标记-清除和分代回收技术。<br><br></p><h4 id="标记——清除"><a href="#标记——清除" class="headerlink" title="标记——清除"></a>标记——清除</h4><p>其简要工作过程如下：</p><ol><li>寻找根对象（root object）的集合，<code>root object</code>即是一些全局引用和函数栈中的引用。这些引用所用的对象是不可被删除的。</li><li>从root object集合出发，沿着root object集合中的每一个引用，如果能到达某个对象A，则A称为<code>可达的</code>，可达的对象也不可删除。这个阶段就是垃圾检测阶段。</li><li>当垃圾检测阶段结束后，所有的对象分为了可达的和<code>不可达的</code>两部分，对所有不可达的对象占用的内存将被回收，这就是垃圾回收阶段。<br><br></li></ol><p>Python中的循环引用总是发生在<code>container</code>对象之间，所谓container对象即是内部可持有对其他对象的引用的对象，如list、dict、class、instance等。Python的垃圾收集机制运行时，只需要去检查这些container对象。</p><p>Python中使用链表来存储可收集对象。<br><br></p><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合称为一个<code>“代”</code>，代的存活时间越长，就越可能不是垃圾，应该越少去收集。衡量存活时间的标准就是经过了几次垃圾收集动作。每一个“代”用链表实现。</p><img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc1.jpg" alt="分代清除" title="分代清除"><p><br></p><h4 id="Python中的标记——清除方法"><a href="#Python中的标记——清除方法" class="headerlink" title="Python中的标记——清除方法"></a>Python中的标记——清除方法</h4><p>一个垃圾回收的例子：<br><img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc2.jpg" alt="分代清除" title="分代清除"></p><ol><li>Python采用三代的分代收集机制，如收集第一代，会将比其“年轻”的所有代的内存链表整个连接到当前代链表之后，则会将比其年轻的第0代放在第1代之后。</li><li>寻找root object集合。通过<code>有效引用计数</code>方法将循环引用标记清除<img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc3.jpg" alt="分代清除" title="分代清除"></li><li>垃圾标记。获得不可达的链表。<img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc4.jpg" alt="分代清除" title="分代清除"></li><li>垃圾回收。将不可达的链表中的对象销毁。<br><br></li></ol><h2 id="Python中的垃圾回收机制为什么使用链表数据结构？"><a href="#Python中的垃圾回收机制为什么使用链表数据结构？" class="headerlink" title="Python中的垃圾回收机制为什么使用链表数据结构？"></a>Python中的垃圾回收机制为什么使用链表数据结构？</h2><ul><li>垃圾回收的过程中必然要涉及到频繁的插入（分代回收，如第0代放在第1代之后）、删除（标记清除，删除不可达节点）的过程，使用双向链表等结构可以使插入、删除等操作时间复杂度达到为O(1)；相比于链表，如果使用树型的数据结构，那么插入和删除的时间复杂度会达到O(logN),同时由于树的父子间的复杂关系，在删除的时候会进行大量操作。</li><li>container对象的内存分布中有三部分，一块用于垃圾回收机制，一块是PyObject_HEAD和自身数据，Python使用双向链表结构将container对象连接起来。在标记的过程中，根据链表结构一对一的对关系，一次完全遍历和一次简答的遍历就可以完成标记任务；如果使用树型结构，由于树的性质，每个节点需要保存2个至多个子代信息，需要保存额外的信息，浪费资源。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;内存管理架构&quot;&gt;&lt;a href=&quot;#内存管理架构&quot; class=&quot;headerlink&quot; title=&quot;内存管理架构&quot;&gt;&lt;/a&gt;内
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解析Python的lambda表达式</title>
    <link href="http://yoursite.com/2018/08/08/%E8%A7%A3%E6%9E%90Python%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/08/解析Python的lambda表达式/</id>
    <published>2018-08-08T01:23:16.000Z</published>
    <updated>2018-08-08T03:34:52.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是lambda表达式？"><a href="#什么是lambda表达式？" class="headerlink" title="什么是lambda表达式？"></a>什么是lambda表达式？</h2><p>lambda表达式也叫匿名函数，返回可调用的函数对象。</p><p>匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算，可以配合其他高阶函数使用如map、reduce、filter。<br><br></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>lambda表达式的定义体必须和声明放在同一行。<br><br></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>使用lambda可以省去定义函数的过程，减少了一个污染环境的函数名，让代码更加精简。</p><p>在非多次调用的函数的情况下，lambda表达式即用既得，提高性能<br><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.douban.com/note/311252412/" target="_blank" rel="external">https://www.douban.com/note/311252412/</a><br><a href="https://www.zhihu.com/question/20125256" target="_blank" rel="external">https://www.zhihu.com/question/20125256</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是lambda表达式？&quot;&gt;&lt;/a&gt;什么是lambda表达式？&lt;/h2&gt;&lt;p&gt;lambda表达式也叫匿名函数，返回可调用的函数对象
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数组与链表</title>
    <link href="http://yoursite.com/2018/08/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/08/03/数组与链表/</id>
    <published>2018-08-02T18:12:08.000Z</published>
    <updated>2018-08-08T00:03:35.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>数组与链表都属于数据结构中线性表结构。同一线性表中的元素必定具有相同特性，且相邻数据元素之间存在着一对一关系（前驱，后继）。</p></blockquote><p>我认为存在线性表这种数据结构的意义是，它可以以一定的顺序进行遍历，方便迭代所有的数据，且在查找的时候可以轻松的利用邻居元素一对一的关系，获取到某个数据。</p><p>动态查找表：不仅仅是顺序查找，动态查找表的特点是表结构本身在查找过程中动态生成,即对给定的关键字key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于key的记录。<br><br></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C中的数组是一种将标量类型数据聚集成更大数据类型的方式。</p><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><p>对于数据类型T和整数N，声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T A[N]</div></pre></td></tr></table></figure></p><p>有两个效果。</p><ul><li>首先，在存储器中分配了L*N字节的连续区域（L是数据类型T的大小），我们用a来表示起始位置。</li><li>其次，引入标识符A，作为指向数组开头的指针，指针的值是a。数组元素i的地址为a+L*i。</li></ul><h4 id="动态分配的数组"><a href="#动态分配的数组" class="headerlink" title="动态分配的数组"></a>动态分配的数组</h4><p>在许多应用程序中，我们需要代码能够对动态分配的任意大小的数组进行操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * var_matrix;</div><div class="line"><span class="function">var matrix <span class="title">new_var_matrix</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (var_matrix)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>), n * n)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意：在C中，堆（一个可以用来存放数据结构的存储池）中的存储分配是用的库函数malloc或calloc。它们要求程度用free函数来释放已分配的空间。在Java中是由gc的进程自动完成的。<br><br></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>C中的struct声明创建一个结构数据类型，将可能不同类型的对象聚合到一个对象中。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">3</span>];</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个结构包含四个域————两个整数、一个数组和一个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">4</span>    <span class="number">8</span>                <span class="number">20</span></div><div class="line">-----------------------------------</div><div class="line">|  i |  j | a[<span class="number">0</span>] a[<span class="number">1</span>] a[<span class="number">2</span>] |  p   |</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure><p>指向结构的指针就是结构第一个字节的地址，为了访问结构中的域，编译器产生的代码要将结构的地址加上适当的偏移。<br><br></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是由一系列不必在内存中相连的结构组成，每一个结构包含表元素和指向包含该元素后继的结构的指针。</p><p>链表在许多语言的内存管理、垃圾回收策略中有着广泛的应用，如Python的内存管理、标记-清除垃圾回收策略、分代收集策略。<br><br></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>分配内存：</p><ul><li>数组：静态数组内存的分配是由栈完成的，它的内存的分配和释放都是有计算机自己处理。</li><li>链表：链表的内存的分配是由堆完成的，它的内存的分配和释放都是有程序员手动处理。</li></ul><p>内存中的状态：</p><ul><li>数组：在内存中是一段连续的区域。</li><li>链表：在内存中是非连续的。</li></ul><p>大小：</p><ul><li>数组：固定。</li><li>链表：不固定。</li></ul><p>操作：</p><ul><li>数组：查找O(1)，增加、删除O(n)。</li><li>链表：查找O(n)，增加、删除O(1)。<br><br></li></ul><h2 id="跳跃链表"><a href="#跳跃链表" class="headerlink" title="跳跃链表"></a>跳跃链表</h2><p><a href="https://lfkdsk.github.io/2017/09/11/quick-learn-skip-list/" target="_blank" rel="external">https://lfkdsk.github.io/2017/09/11/quick-learn-skip-list/</a><br><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据结构——C语言版》严蔚敏<br>《数据机构与算法分析——C语言描述》韦斯<br>《深入理解计算机系统》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数组与链表都属于数据结构中线性表结构。同一线性表中的元素必定具有相同特性，且相邻数据元素之间存在着一对一关系（前驱
      
    
    </summary>
    
    
      <category term="数组 链表" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——多线程机制</title>
    <link href="http://yoursite.com/2018/07/17/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/07/17/Python源码剖析——多线程机制/</id>
    <published>2018-07-17T04:46:24.000Z</published>
    <updated>2018-09-21T18:27:23.425Z</updated>
    
    <content type="html"><![CDATA[<p>Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对虚拟机的使用。</p><h2 id="GIL与线程调度"><a href="#GIL与线程调度" class="headerlink" title="GIL与线程调度"></a>GIL与线程调度</h2><p>在一个线程拥有了GIL，获得解释器的访问权之后，其他线程必须等待它释放解释器的访问权。</p><p>Python的多线程在于拥有一套线程调度机制，默认执行100条指令后启动线程调度机制挂起线程，选择处于等待的下一个线程时，借用底层操作系统提供的线程调度机制决定下一个进入解释器的线程。<br><br></p><h2 id="Python中的Thread"><a href="#Python中的Thread" class="headerlink" title="Python中的Thread"></a>Python中的Thread</h2><p>Python提供两个多线程机制接口：</p><ul><li>thread</li><li>threading</li></ul><p>thread 模块提供方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//threadmodule.c</span></div><div class="line"><span class="keyword">static</span> PyMethodDef thread_methods[] = &#123;</div><div class="line">    &#123;<span class="string">"start_new_thread"</span>,        (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">    &#123;<span class="string">"start_new"</span>,               (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">    &#123;<span class="string">"allocate_lock"</span>,           (PyCFunction)thread_PyThread_allocate_lock,</div><div class="line">     METH_NOARGS, allocate_doc&#125;,</div><div class="line">    &#123;<span class="string">"allocate"</span>,                (PyCFunction)thread_PyThread_allocate_lock,</div><div class="line">     METH_NOARGS, allocate_doc&#125;,</div><div class="line">    &#123;<span class="string">"exit_thread"</span>,             (PyCFunction)thread_PyThread_exit_thread,</div><div class="line">     METH_NOARGS, exit_doc&#125;,</div><div class="line">    &#123;<span class="string">"exit"</span>,                    (PyCFunction)thread_PyThread_exit_thread,</div><div class="line">     METH_NOARGS, exit_doc&#125;,</div><div class="line">    &#123;<span class="string">"interrupt_main"</span>,          (PyCFunction)thread_PyThread_interrupt_main,</div><div class="line">     METH_NOARGS, interrupt_doc&#125;,</div><div class="line">    &#123;<span class="string">"get_ident"</span>,               (PyCFunction)thread_get_ident,</div><div class="line">     METH_NOARGS, get_ident_doc&#125;,</div><div class="line">    &#123;<span class="string">"_count"</span>,                  (PyCFunction)thread__count,</div><div class="line">     METH_NOARGS, _count_doc&#125;,</div><div class="line">    &#123;<span class="string">"stack_size"</span>,              (PyCFunction)thread_stack_size,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            stack_size_doc&#125;,</div><div class="line">    &#123;<span class="literal">NULL</span>,                      <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><br></p><h2 id="Python线程创建"><a href="#Python线程创建" class="headerlink" title="Python线程创建"></a>Python线程创建</h2><h4 id="通过start-new-thread创建一个新线程。"><a href="#通过start-new-thread创建一个新线程。" class="headerlink" title="通过start_new_thread创建一个新线程。"></a>通过start_new_thread创建一个新线程。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></div><div class="line"><span class="title">thread_PyThread_start_new_thread</span><span class="params">(PyObject *self, PyObject *fargs)</span></div><div class="line">&#123;</div><div class="line">    PyObject *func, *args, *keyw = <span class="literal">NULL</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span>;</span></div><div class="line">    <span class="keyword">long</span> ident;</div><div class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(fargs, <span class="string">"start_new_thread"</span>, <span class="number">2</span>, <span class="number">3</span>,</div><div class="line">                           &amp;func, &amp;args, &amp;keyw))</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (!PyCallable_Check(func)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"first arg must be callable"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!PyTuple_Check(args)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"2nd arg must be a tuple"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (keyw != <span class="literal">NULL</span> &amp;&amp; !PyDict_Check(keyw)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"optional 3rd arg must be a dictionary"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1. 创建并初始化bootstate结构, 在boot中保存关于线程的一切信息, </span></div><div class="line">    boot = PyMem_NEW(struct bootstate, <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (boot == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">    boot-&gt;interp = PyThreadState_GET()-&gt;interp;  <span class="comment">//保存PyInterpreterState对象</span></div><div class="line">    boot-&gt;func = func;</div><div class="line">    boot-&gt;args = args;</div><div class="line">    boot-&gt;keyw = keyw;</div><div class="line">    boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp);</div><div class="line">    <span class="keyword">if</span> (boot-&gt;tstate == <span class="literal">NULL</span>) &#123;</div><div class="line">        PyMem_DEL(boot);</div><div class="line">        <span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">    &#125;</div><div class="line">    Py_INCREF(func);</div><div class="line">    Py_INCREF(args);</div><div class="line">    Py_XINCREF(keyw);</div><div class="line">    <span class="comment">//2. 初始化多线程环境</span></div><div class="line">    PyEval_InitThreads(); <span class="comment">/* Start the interpreter's thread-awareness */</span></div><div class="line">    <span class="comment">//3. 创建操作系统原生线程</span></div><div class="line">    ident = PyThread_start_new_thread(t_bootstrap, (<span class="keyword">void</span>*) boot);</div><div class="line">    <span class="keyword">if</span> (ident == <span class="number">-1</span>) &#123;</div><div class="line">        PyErr_SetString(ThreadError, <span class="string">"can't start new thread"</span>);</div><div class="line">        Py_DECREF(func);</div><div class="line">        Py_DECREF(args);</div><div class="line">        Py_XDECREF(keyw);</div><div class="line">        PyThreadState_Clear(boot-&gt;tstate);</div><div class="line">        PyMem_DEL(boot);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> PyInt_FromLong(ident);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在Python虚拟机启动时，多线程机制并没有被激活，它只支持单线程，调用thread.start_new_thread，明确指示Python虚拟机创建新的线程，Python就能意识到用户需要多线程的支持，Python虚拟机会自动建立多线程机制需要的数据机构、环境以及GIL。</li></ul><h4 id="建立多线程环境"><a href="#建立多线程环境" class="headerlink" title="建立多线程环境"></a>建立多线程环境</h4><p>多线程环境的建立，主要就是创建GIL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pythread.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *PyThread_type_lock;</div><div class="line"></div><div class="line"><span class="comment">//ceval.c</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock interpreter_lock = <span class="number">0</span>; <span class="comment">/* This is the GIL */</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock pending_lock = <span class="number">0</span>; <span class="comment">/* for pending calls */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> main_thread = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">PyEval_InitThreads</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (interpreter_lock)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    interpreter_lock = PyThread_allocate_lock(); <span class="comment">//创建GIL(PNRMUTEX aLock)thread_nt.h</span></div><div class="line">    PyThread_acquire_lock(interpreter_lock, <span class="number">1</span>);</div><div class="line">    main_thread = PyThread_get_thread_ident();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">PyThread_type_lock</span></div><div class="line"><span class="title">PyThread_allocate_lock</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    PNRMUTEX aLock;</div><div class="line"></div><div class="line">    dprintf((<span class="string">"PyThread_allocate_lock called\n"</span>));</div><div class="line">    <span class="keyword">if</span> (!initialized)</div><div class="line">        PyThread_init_thread();</div><div class="line">    aLock = AllocNonRecursiveMutex() ;</div><div class="line">    dprintf((<span class="string">"%ld: PyThread_allocate_lock() -&gt; %p\n"</span>, PyThread_get_thread_ident(), aLock));</div><div class="line">    <span class="keyword">return</span> (PyThread_type_lock) aLock;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//thread_nt.c</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NRMUTEX</span> &#123;</span></div><div class="line">    LONG   owned ;</div><div class="line">    DWORD  thread_id ;</div><div class="line">    HANDLE hevent ; <span class="comment">//event内核对象</span></div><div class="line">&#125; NRMUTEX, *PNRMUTEX ;</div></pre></td></tr></table></figure></p><ul><li>在PyEval_InitThreads通过PyThread_allocate_lock成功地创建了GIL之后，当前线程就开始遵循Python的多线程机制的规则；调用任何Python C API之前，必须首先获得GIL。因此PyEval_InitThreads紧接着通过PyThread_acquire_lock尝试获得GIL。最后调用PyThead_get_thread_ident()，获得当前Python主线程id，并将其赋给main_thread。</li></ul><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">long</div><div class="line">PyThread_start_new_thread(void (*func)(void *), void *arg)</div><div class="line">&#123;</div><div class="line">    HANDLE hThread;</div><div class="line">    unsigned threadID;</div><div class="line">    callobj *obj;</div><div class="line"></div><div class="line">    dprintf(("%ld: PyThread_start_new_thread called\n",</div><div class="line">             PyThread_get_thread_ident()));</div><div class="line">    if (!initialized)</div><div class="line">        PyThread_init_thread();</div><div class="line"></div><div class="line">    obj = (callobj*)HeapAlloc(GetProcessHeap(), 0, sizeof(*obj));</div><div class="line">    if (!obj)</div><div class="line">        return -1;</div><div class="line">    obj-&gt;func = func;</div><div class="line">    obj-&gt;arg = arg;</div><div class="line">#if defined(MS_WINCE)</div><div class="line">    hThread = CreateThread(NULL,</div><div class="line">                           Py_SAFE_DOWNCAST(_pythread_stacksize, Py_ssize_t, SIZE_T),</div><div class="line">                           bootstrap, obj, 0, &amp;threadID);</div><div class="line">#else</div><div class="line">    hThread = (HANDLE)_beginthreadex(0,</div><div class="line">                      Py_SAFE_DOWNCAST(_pythread_stacksize,</div><div class="line">                                       Py_ssize_t, unsigned int),</div><div class="line">                      bootstrap, obj,</div><div class="line">                      0, &amp;threadID);</div><div class="line">#endif</div><div class="line">    if (hThread == 0) &#123;</div><div class="line">#if defined(MS_WINCE)</div><div class="line">        /* Save error in variable, to prevent PyThread_get_thread_ident</div><div class="line">           from clobbering it. */</div><div class="line">        unsigned e = GetLastError();</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread failed, win32 error code %u\n",</div><div class="line">                 PyThread_get_thread_ident(), e));</div><div class="line">#else</div><div class="line">        /* I've seen errno == EAGAIN here, which means "there are</div><div class="line">         * too many threads".</div><div class="line">         */</div><div class="line">        int e = errno;</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread failed, errno %d\n",</div><div class="line">                 PyThread_get_thread_ident(), e));</div><div class="line">#endif</div><div class="line">        threadID = (unsigned)-1;</div><div class="line">        HeapFree(GetProcessHeap(), 0, obj);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread succeeded: %p\n",</div><div class="line">                 PyThread_get_thread_ident(), (void*)hThread));</div><div class="line">        CloseHandle(hThread);</div><div class="line">    &#125;</div><div class="line">    return (long) threadID;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>主线程为执行程序时操作系统创建，主线程调用PyThread_start_new_thread创建子线程（CreateThread）。Win32下thread的API：_beginThread完成线程创建，bootstrap调用子线程定义（如函数），_beginThreadz在子线程中发生，顺利返回后，主线程挂起，等待obj.done。</li><li>主线程调用用PyThread_start_new_thread需要返回子线程的线程id，这个id只有在子线程被激活后在子线程获取，一旦子线程设置obj-&gt;id，就会设法唤醒主线程。主线程获得id后继续执行之后的字节码，主线程掌握GIL，子线程进入等待GIL状态，等待线程调度。</li><li>子线程创建自身线程状态对象后, 通过_PyGILState_NotrThreadState将这个对象放入线程状态对象链表。当前活动的Python线程不一定是获得了GIL的线程，主线程和子线程都是win32原生线程，操作系统可能在主线程和子线程之间切换。当所有的线程都完成了初始化之后，操作系统线程调度和Python线程调度才会统一，Python线程调度迫使当前活动线程释放GIL，并通知所有等待GIL event内核对象的线程，触发操作系统线程调度。<br><br></li></ul><h2 id="Python线程调度"><a href="#Python线程调度" class="headerlink" title="Python线程调度"></a>Python线程调度</h2><h4 id="标准调度"><a href="#标准调度" class="headerlink" title="标准调度"></a>标准调度</h4><p>Python的线程之间切换由线程调度机制掌握，python线程调度机制内建在python解释器的核心PyEval_EvalFrameEx中。</p><p>主线程先获得GIL, 并执行PyEval_EvalFrameEx函数代码, 这是子线程在t_bootstrap中调用PyEval_AcquireThread, 通过调用PyThread_acquire_lock申请GIL, 但由于GIL被主线程调用, 子线程被挂起. 主线程不断执行字节码, _Py_Ticker不断减一, 当减到0, 将当前维护线程状态置NULL, 然后释放GIL,此时子线程被操作系统的线程调度唤醒, 从而进入PyEval_EvalFrameEx. 对于主线程虽然失去了GIL, 但是没被挂起, 所以可以被再次切换为活动线程, 再次申请GIL, 由于被子线程占有, 主线程将自身挂起.</p><h4 id="阻塞调度"><a href="#阻塞调度" class="headerlink" title="阻塞调度"></a>阻塞调度</h4><p>线程A通过某些操作(如等待输入), 将自身阻塞, python应将等待GIL的线程B唤醒。</p><h4 id="Python子线程的销毁"><a href="#Python子线程的销毁" class="headerlink" title="Python子线程的销毁"></a>Python子线程的销毁</h4><p>主线程销毁必须要销毁python的运行时环境, 子线程的销毁不需要进行这些动作，对线程状态对象中维护的东西进行引用计数的维护，随后Python释放GIL。</p><h4 id="Python线程的用户级互斥和同步"><a href="#Python线程的用户级互斥和同步" class="headerlink" title="Python线程的用户级互斥和同步"></a>Python线程的用户级互斥和同步</h4><p>Python的线程在GIL的控制之下，线程之间，对整个Python解释器，对Python提供的C API的访问，都是互斥的，这可以看作是Python内核级互斥机制。但这种互斥我们不能控制的，我们还需要另一种可控的互斥机制————用户级互斥。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//threadmodule.c</div><div class="line">/* Lock objects */</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    PyThread_type_lock lock_lock;  //Event内核对象</div><div class="line">    PyObject *in_weakreflist;</div><div class="line">&#125; lockobject;</div><div class="line">static PyObject *</div><div class="line">thread_PyThread_allocate_lock(PyObject *self)</div><div class="line">&#123;</div><div class="line">    return (PyObject *) newlockobject();</div><div class="line">&#125;</div><div class="line">static lockobject *</div><div class="line">newlockobject(void)</div><div class="line">&#123;</div><div class="line">    lockobject *self;</div><div class="line">    self = PyObject_New(lockobject, &amp;Locktype);</div><div class="line">    if (self == NULL)</div><div class="line">        return NULL;</div><div class="line">    self-&gt;lock_lock = PyThread_allocate_lock();</div><div class="line">    self-&gt;in_weakreflist = NULL;</div><div class="line">    if (self-&gt;lock_lock == NULL) &#123;</div><div class="line">        Py_DECREF(self);</div><div class="line">        PyErr_SetString(ThreadError, "can't allocate lock");</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对thread.allocate的调用仅仅通过newlockobject创建了一个lockobject对象，Python整个用户级线程同步机制就在这个对象基础上实现。</li></ul><p>实现：</p><ul><li>同步锁 <a href="https://www.cnblogs.com/xuanan/p/7202492.html" target="_blank" rel="external">参考</a></li><li>可重入锁 <a href="https://segmentfault.com/a/1190000014769953" target="_blank" rel="external">参考</a></li></ul><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> threading</div><div class="line"><span class="keyword">import</span> time</div><div class="line"></div><div class="line">count = <span class="number">0</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">global</span> count</div><div class="line"></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        lock1.acquire()</div><div class="line">        count += <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> count == <span class="number">1</span>:</div><div class="line">            lock2.acquire()</div><div class="line">        lock1.release()</div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'reading...'</span></div><div class="line">        time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line">        lock1.acquire()</div><div class="line">        count -= <span class="number">1</span></div><div class="line">        <span class="keyword">if</span> count == <span class="number">0</span>:</div><div class="line">            lock2.release()</div><div class="line">        lock1.release()</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">        lock2.acquire()</div><div class="line"></div><div class="line">        <span class="keyword">print</span> <span class="string">'writing...'</span></div><div class="line">        time.sleep(<span class="number">2</span>)</div><div class="line"></div><div class="line">        lock2.release()</div><div class="line"></div><div class="line">lock1 = threading.Lock() <span class="comment"># 变量count锁</span></div><div class="line">lock2 = threading.Lock() <span class="comment"># 写锁</span></div><div class="line">t1 = threading.Thread(target=reader)</div><div class="line">t2 = threading.Thread(target=reader)</div><div class="line">t3 = threading.Thread(target=writer)</div><div class="line">t4 = threading.Thread(target=writer)</div><div class="line">t1.start()</div><div class="line">t2.start()</div><div class="line">t3.start()</div><div class="line">t4.start()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对虚拟机的使用。&lt;/p&gt;
&lt;h2 id=&quot;GIL与线程调度&quot;&gt;&lt;a href=&quot;#GIL与线程调度&quot; class=&quot;headerlink&quot; title=&quot;GIL与线程调
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>大疆创新2019届秋招前端笔试题</title>
    <link href="http://yoursite.com/2018/07/15/%E5%A4%A7%E7%96%86%E5%88%9B%E6%96%B02019%E5%B1%8A%E7%A7%8B%E6%8B%9B%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/15/大疆创新2019届秋招前端笔试题/</id>
    <published>2018-07-15T02:34:51.000Z</published>
    <updated>2018-08-12T19:00:23.563Z</updated>
    
    <content type="html"><![CDATA[<p>一、选择题</p><ol><li><p>以下描述不正确的是？<br>A. GET请求不可以携带body<br>B. cache-control: no-cache表示浏览器不存储资源内容<br>C. componentWillReceiveProps在componentShouldUpdate之后执行<br>D. vue的双向绑定对数组不生效<br>解析：ABC。<br>对A，知识点主要是GET方法和POST方法的区别，GET方法可以携带body，不同的库函数和浏览器对其支持不同，一般不使用，参考链接（<a href="https://www.zhihu.com/question/28586791）。" target="_blank" rel="external">https://www.zhihu.com/question/28586791）。</a><br>对B，知识点为HTTP缓存，参考链接（<a href="https://segmentfault.com/a/1190000010775131）。" target="_blank" rel="external">https://segmentfault.com/a/1190000010775131）。</a><br><br></p></li><li><p>以下哪种情况会产生死锁？<br>A. 竞争不可抢占性资源引起死锁<br>B. 进程产生死循环<br>C. 竞争可消耗资源引起死锁<br>D. 进程推进顺序不当引起死锁<br>解析：ACD。<br>死锁：多个进程在运行过程中因竞争资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。<br>产生死锁的原因归结为两点：</p></li></ol><ul><li>竞争资源，指的是不可剥夺性资源和临时性资源。</li><li>进程的推进顺序非法。</li></ul><p>死锁的必要条件：</p><ul><li>互斥：进程对所分配到的资源具有排他性使用，即在一段时间内某资源只由一个进程占用。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得资源，在未使用完之前，不能被剥夺只能使用完自己释放。</li><li>环路等待：发生死锁时，必然存在一个进程——资源环形链。<br>死循环，如while True，不会引起死锁。<br><br></li></ul><ol><li><p>异步任务有哪些？<br>A. setTimeout<br>B. setInterval<br>C. Promise.resolve<br>D. localStorage.setItem<br>解析：ABC<br>localStorage.setItem用于本地存储<br><br></p></li><li><p>html5语义化的作用有？<br>A. 让页面内容结构化，便于浏览器搜索引擎解析（SEO）<br>B. 保证页面在无样式时也是容易阅读的<br>C. 用正确的标签做正确的事<br>D. 便于维护理解<br>解析：ABD<br><br></p></li><li><p>下面正则表达式不可以匹配www.dji.com的是？<br>A. ^\w+.\w+-\w+.\w+$<br>B. [w]{0,3}.[a-z-]<em>.[a-z]+<br>C. [c-w.]{3,10}[.][c-w.][.][a]<br>D. ^\w.</em>com$<br>解析：ACD<br><br></p></li><li><p>Math.round(-7.5),Math.round(-7.6)的结果分别是？<br>A. -7,-7<br>B. -7,-8<br>C. -8,-8<br>D. -7,-9<br>解析：B,四舍五入。<br><br></p></li><li><p>用二分法查找长度为20的、排好序的线性表，查找不成功时，最多需要比较多少次？<br>A. 3<br>B. 4<br>C. 5<br>D. 6<br>解析：C,（向上取整）log|<em>20</em>| + 1<br><br></p></li><li><p>[1<2<3, 3<2<1]?="" a.="" [false,true]="" b.="" [false,false]="" c.="" [true,true]="" d.="" [true,false]="" 解析：c,="" <br=""></2<3,></p></li><li><p>2==[[[2]]]的答案是？<br>A. 1<br>B. error<br>C. undefined<br>D. true<br>解析：D,<br><br></p></li><li><p>在浏览器控制台，执行以下代码，运行的结果分别是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.b() <span class="comment">// 2</span></div><div class="line">c=a.b</div><div class="line">c() <span class="comment">// '1'</span></div></pre></td></tr></table></figure></li></ol><p><br></p><ol><li><p>因为浏览器的限制，目前浏览器端html5及js还不能实现的功能是（以60版本chrome为基准）？<br>A. 离线消息推送<br>B. 读写本地文件<br>C. 绘制webgl<br>D. 将视频呢用canvas<em>x0008</em>逐帧绘制<br>解析：A<br><br></p></li><li><p>console.log(1+-+++-+1)答案是：<br>A. 2<br>B. 1<br>C. 0<br>D. error<br>解析：D<br><br></p></li><li><p>-8的二进制反码表示为？<br>A. 01111000<br>B. 11110111<br>C. 11111000<br>D. 11111001<br>解析：C<br><br></p></li><li><p>int l=2;int x=(l++) + (l++) + (l++);执行结束后，x的值是？<br>A. 6<br>B. 7<br>C. 8<br>D. 9<br>解析：D。<a href="https://www.zhihu.com/question/19811087" target="_blank" rel="external">https://www.zhihu.com/question/19811087</a><br><br></p></li></ol><p>二、问答题</p><ol><li>手写快速排序算法？<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">QSort</span><span class="params">(A, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &lt; right:</div><div class="line">        pivot = Median(A, left, right)</div><div class="line">        i = left</div><div class="line">        j = right - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">while</span> A[i] &lt; pivot:</div><div class="line">                i += <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> A[j] &gt; pivot:</div><div class="line">                j -= <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> i &lt; j:</div><div class="line">                swap(A[i], A[j])</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        swap(A[i], A[right])</div><div class="line">        QSort(A, left, i - <span class="number">1</span>)]</div><div class="line">        QSort(S, i + <span class="number">1</span>, right)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Median</span><span class="params">(A, left, right)</span>:</span></div><div class="line">    center = (left + right) / <span class="number">2</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> A[left] &gt; A[right]:</div><div class="line">        swap(A[left], A[right])</div><div class="line">    <span class="keyword">if</span> A[left] &gt; A[center]:</div><div class="line">        swap(A[left], A[center])</div><div class="line">    <span class="keyword">if</span> A[center] &gt; A[right]:</div><div class="line">        swap(A[center], A[right])</div><div class="line">    </div><div class="line">    swap(A[center], A[right])</div><div class="line">    <span class="keyword">return</span> A[right]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    我们假设该swap交换函数的参数是引用类型的，</div><div class="line">    否则由于作用域问题交换例程是无效的。</div><div class="line">    '''</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></li></ol><p><br></p><ol><li><p>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为12,000,000.11？<br><br></p></li><li><p>链表与数组的区别？<br><a href="https://lucky4.github.io/2018/08/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/" target="_blank" rel="external">https://lucky4.github.io/2018/08/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/</a><br><br></p></li><li><p>进程间的通信方式有哪些？<br>进程通信，是指进程之间的信息交换。进程间的同步和互斥属于低级通信；高级通信，指用户可直接利用操作系统提供的一组通信命令高效地传送大量数据的一种通信方式。相比低级通信，效率高，对用户透明，减少通信程序编制的复杂性。高级通信的几种方式：<br>##<strong>管道（pipe）</strong>：指用于连接一个读进程和写进程以实现他们之间通信的一个共享文件。管道的特点是：只支持半双工通信（单向传输），只能在父子进程中使用。<br>##<strong>命名管道（FIFO）</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。<br>##<strong>消息队列（message queue）</strong>：消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。相比于 FIFO，消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。<br>##<strong>信号量</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>##<strong>共享内存</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。<br>##<strong>套接字</strong>：与其它通信机制不同的是，它可用于不同机器间的进程通信。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、选择题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下描述不正确的是？&lt;br&gt;A. GET请求不可以携带body&lt;br&gt;B. cache-control: no-cache表示浏览器不存储资源内容&lt;br&gt;C. componentWillReceiveProps在component
      
    
    </summary>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python内置函数</title>
    <link href="http://yoursite.com/2018/06/03/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/06/03/Python内置函数/</id>
    <published>2018-06-02T17:45:51.000Z</published>
    <updated>2018-08-19T04:40:37.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><p>一些常用的函数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">max()</div><div class="line">min()</div><div class="line">int()</div><div class="line">str()</div><div class="line">len()</div><div class="line">pow(x, y)                <span class="comment"># x的y次幂</span></div><div class="line">bin()                    <span class="comment"># 二进制表示</span></div><div class="line">range(start, end, step)</div><div class="line">xrange(start, end, step) <span class="comment"># 与range函数的区别就是，该函数是一个一个生成值的。</span></div></pre></td></tr></table></figure></p><p><br></p><p>要学会利用range函数生成倒序的序列<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">    <span class="keyword">print</span> i <span class="comment"># 5, 4, 3, 2, 1, 0</span></div></pre></td></tr></table></figure></p><p><br></p><p>生成二维数组<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array = [[<span class="number">0</span>] * col <span class="keyword">for</span> i <span class="keyword">in</span> range(row)]</div></pre></td></tr></table></figure></p><p>不要使用列表乘法的方式如：[[0] <em> col] </em> row因为它只是引用了对方的地址。<br><br></p><h2 id="迭代工具"><a href="#迭代工具" class="headerlink" title="迭代工具"></a>迭代工具</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">filter(function, iterable)</div><div class="line">map(function, iterable)</div><div class="line">reduce(function, iterable)</div></pre></td></tr></table></figure><p><br></p><h2 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h2><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;&gt; <span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line">&gt;&gt;&gt;&gt; help(deque)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span><span class="params">(__builtin__.object)</span>:</span></div><div class="line">    __getitem__(...)</div><div class="line"></div><div class="line">    __setitem__(...)</div><div class="line"></div><div class="line">    __len__(...)</div><div class="line"></div><div class="line">    append(...) <span class="comment"># 入队</span></div><div class="line"></div><div class="line">    appendleft(...) <span class="comment"># 左侧入队</span></div><div class="line"></div><div class="line">    extend(...) <span class="comment"># 扩展队列元素</span></div><div class="line"></div><div class="line">    extendleft(...) <span class="comment"># 左侧扩展队列元素</span></div><div class="line"></div><div class="line">    pop(...) <span class="comment"># 右侧出队</span></div><div class="line"></div><div class="line">    popleft(...) <span class="comment"># 左侧出队</span></div><div class="line"></div><div class="line">    remove(...) <span class="comment"># 删除某个元素</span></div><div class="line"></div><div class="line">    rotate(...) <span class="comment"># 头结点向右移动n个位置</span></div></pre></td></tr></table></figure><p><br></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;&gt; <span class="keyword">from</span> heapq <span class="keyword">import</span> *</div><div class="line">&gt;&gt;&gt;&gt; heap = []</div><div class="line"></div><div class="line">heapify(heap) <span class="comment"># 将一个列表转化为堆</span></div><div class="line"></div><div class="line">heappop(heap) <span class="comment"># 返回小顶堆中最小的元素</span></div><div class="line"></div><div class="line">heappush(heap, x) <span class="comment"># 将元素加入到堆中</span></div><div class="line"></div><div class="line">heapreplace(heap, x) <span class="comment"># 将堆中最小的元素弹出，同时将x入堆</span></div></pre></td></tr></table></figure><p>Python中的堆默认是小顶堆，如果想实现的大顶堆的话（只能是正数），可以像下面这样使用：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建堆</span></div><div class="line">heappush(heap, -x)</div><div class="line"></div><div class="line"><span class="comment"># 获得最大值</span></div><div class="line">-heappop(heap)</div></pre></td></tr></table></figure></p><p><br></p><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>正则表达式是可以匹配文本片段的模式。</p><p>正则需要注意的几点：</p><ol><li>使用原生字符串如：r’python\.org’，避免多次使用’\\.’让re模块转义和解释器两次转义。</li><li>re.match()函数在字符串的开始处匹配模式，如果想匹配整个字符串，可以在结尾家美元符。</li><li>正则默认为贪婪模式，可以在子模式后加?改为非贪婪模式，如：pattern = r’\<em>\</em>(.+?)\<em>\</em>‘。<br><br></li></ol><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>初始化，集合是由序列（或者其他可迭代的对象）构建的。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>set([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line">set([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div></pre></td></tr></table></figure></p><p>性质</p><ul><li>集合中元素的顺序是随意的。</li><li>集合是可变的，不能用做字典中的健。</li><li>集合只能包含不可变的值，所以不能包含其他集合。</li></ul><p>常用方法<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = set([<span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="comment"># 并集</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a | b </div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ,<span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="comment"># 交集</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b</div><div class="line">set([<span class="number">2</span>, <span class="number">3</span>])</div><div class="line"></div><div class="line"><span class="comment"># 差集</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a - b</div><div class="line">set([<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment"># 异或</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b</div><div class="line">set([<span class="number">1</span>, <span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="comment"># 复制</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.copy()</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.copy() <span class="keyword">is</span> a</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure></p><p><br></p><h4 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations, permutations</div><div class="line"></div><div class="line"></div><div class="line">s = <span class="string">'abc'</span></div><div class="line">p = list(permutations(s)) <span class="comment"># [('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), ('b', 'c', 'a'), ('c', 'a','b'), ('c', 'b', 'a')]</span></div><div class="line">c = list(combinations(s, <span class="number">2</span>)) <span class="comment"># [('a', 'b'), ('a', 'c'), ('b', 'c')]</span></div></pre></td></tr></table></figure><p><br></p><h4 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h4><blockquote><p>sys这个模块让你能够访问与Python解释器联系紧密的变量和函数。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sys.stdin</div><div class="line">sys.stdout</div><div class="line">sys.stderr</div></pre></td></tr></table></figure><p>sys.stdin、sys.stdout、sys.stderr模块变量是类文件流对象。它们表示标准UNIX概念中的标准输入、标准输出和标准出错。</p><p>sys.stdin与raw_input的区别是：</p><ul><li>sys.stdin会一直获取输入，可以通过sys.stdin.read(),sys.stdin.readline()等方法获取想要的内容,readline()获取的内容带换行符。</li><li>raw_input获取输入的时候，当输入回车后就停止了输入，raw_input获取的内容不带换行符。</li></ul><p>该知识点在<a href="https://www.nowcoder.com/questionTerminal/c471efdbd33a4a979539a91170c9f1cb" target="_blank" rel="external">此编程题</a>中体现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工具函数&quot;&gt;&lt;a href=&quot;#工具函数&quot; class=&quot;headerlink&quot; title=&quot;工具函数&quot;&gt;&lt;/a&gt;工具函数&lt;/h2&gt;&lt;p&gt;一些常用的函数&lt;br&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解析DBLP数据集</title>
    <link href="http://yoursite.com/2018/04/22/%E8%A7%A3%E6%9E%90DBLP%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2018/04/22/解析DBLP数据集/</id>
    <published>2018-04-21T23:12:07.000Z</published>
    <updated>2018-04-26T17:54:34.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>放弃了找实习的念头后，决心搞论文。冥思苦想了好长时间，终于决定了方向，和学者合作网络相关。于是开始了提取dblp数据集，在刚开始运行脚本的时候总是报一个错误，“IOError: [Errno 2] : ‘dblp.dtd’”。</p><p>以下是xml文件格式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE dblp SYSTEM "dblp.dtd"&gt;</span></div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure></p><p>思考了好久后终于明白，是因为项目中缺少dtd文件，导致程序找不到报错。接下来是关于xml方面的知识，之后讲解dblp解析数据。<br><br></p><h2 id="关于XML"><a href="#关于XML" class="headerlink" title="关于XML"></a>关于XML</h2><h4 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML?"></a>什么是 XML?</h4><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）。</li><li>XML 是一种标记语言，很类似 HTML。</li><li>XML 的设计宗旨是传输数据，而非显示数据。<br><br></li></ul><h4 id="XML验证"><a href="#XML验证" class="headerlink" title="XML验证"></a>XML验证</h4><p>形式良好的XML文档会遵守前几章介绍过的 XML 语法规则：</p><ul><li>XML 文档必须有根元素</li><li>XML 文档必须有关闭标签</li><li>XML 标签对大小写敏感</li><li>XML 元素必须被正确的嵌套</li><li>XML 属性必须加引号</li></ul><p>合法的 XML 文档是“形式良好”的 XML 文档，同样遵守文档类型定义 (DTD) 的语法规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</div><div class="line">&lt;!DOCTYPE note SYSTEM &quot;Note.dtd&quot;&gt;</div><div class="line">&lt;note&gt;</div><div class="line">&lt;to&gt;George&lt;/to&gt;</div><div class="line">&lt;from&gt;John&lt;/from&gt;</div><div class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</div><div class="line">&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;</div><div class="line">&lt;/note&gt;</div></pre></td></tr></table></figure></p><p>DTD(Document Type Definition)的作用是定义 XML 文档的结构。它使用一系列合法的元素来定义文档结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE note [</div><div class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</div><div class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</div><div class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</div><div class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</div><div class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</div><div class="line">]&gt;</div></pre></td></tr></table></figure></p><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2><p>sax是Python提供的一个解析xml文件的库，从它的源码中可以看出它提供了一些事件处理程序，通过实现这些处理程序完成解析功能，实现了C编写的Python处理模块提供的接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;放弃了找实习的念头后，决心搞论文。冥思苦想了好长时间，终于决定了方向，和学者合作网络相关。于是开始了提取dblp数据集，在刚开始运行脚本的时
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>随便记录的笔试题</title>
    <link href="http://yoursite.com/2018/04/19/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E5%BD%95%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/19/随便记录的笔试题/</id>
    <published>2018-04-19T03:28:01.000Z</published>
    <updated>2018-04-26T02:45:18.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018春季百度前端笔试题"><a href="#2018春季百度前端笔试题" class="headerlink" title="2018春季百度前端笔试题"></a>2018春季百度前端笔试题</h2><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ul><li>建立一个堆的复杂度？</li><li>给定一串数字(1, 34, 56, 76, 3, 65)哈希函数H(key) = key % 7，采用链地址法，求查找成功时的平均查找长度？</li><li>HTTP报文相关字段，如cache等。</li><li>‘1’ + 0, ‘1’ - 0, ‘1’ * 0</li><li>时间片轮询调度算法？</li><li>触发进程调度的原因？<br><br></li></ul><h4 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h4><ol><li>一个表有三个字段id，price，sales，下面有多条数据，写一段JavaScript代码，如sort(‘price’, ‘asc’)函数，将表中数据按price升序。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>price<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>900<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>10.0<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>400<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>40.5<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>500<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></div></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><p>现代JavaScript中有哪些方法可以优化回调陷阱的问题？<br><br></p><h4 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h4><p>参照一下性能优化建议，设计一个JavaScript工具库，实现在任意HTML中运行该库可以计算出该页面的性能得分。（如dom元素小于200位100分，大于1000为0分）。</p><ul><li>减少DOM元素数量。</li><li>推迟加载非关键JavaScript(defer,async)。</li><li>减少使用iframe。</li><li>样式表置于顶部，JavaScript置于底部。</li><li>不要在HTML中缩放图像。</li><li>为图片资源响应头指定Expires或者Cache-Control并进行Gzip压缩。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2018春季百度前端笔试题&quot;&gt;&lt;a href=&quot;#2018春季百度前端笔试题&quot; class=&quot;headerlink&quot; title=&quot;2018春季百度前端笔试题&quot;&gt;&lt;/a&gt;2018春季百度前端笔试题&lt;/h2&gt;&lt;h4 id=&quot;选择题&quot;&gt;&lt;a href=&quot;#选择题&quot; c
      
    
    </summary>
    
    
      <category term="笔试题" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
