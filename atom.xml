<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucky4</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-07T23:37:44.509Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lucky4</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JavaScript创建对象的几种方式</title>
    <link href="http://yoursite.com/2018/03/08/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/08/JavaScript创建对象的几种方式/</id>
    <published>2018-03-07T22:33:11.000Z</published>
    <updated>2018-03-07T23:37:44.509Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">29</span>,</div><div class="line">  <span class="attr">job</span>: <span class="string">"Software Engineer"</span>,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>缺点是使用同一接口创建很多对象，会产生大量重复的代码。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.job = job;</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure><p>缺点是不能识别对象的类型(即怎样知道一个对象的类型，即使用instanceof识别)。</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure><p>这里在复习一下使用new操作符后的执行过程：</p><ol><li>创建一个新对象。</li><li>将构造函数作用域执行新对象（this指向了新对象）。</li><li>执行构造函数中的代码。</li><li>返回新对象。</li></ol><p>构造函数中的缺点就是，当创建的对象中包含Function时，实例上的同名函数是不相等的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.ag = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="组合构造函数模式和原型模式"><a href="#组合构造函数模式和原型模式" class="headerlink" title="组合构造函数模式和原型模式"></a>组合构造函数模式和原型模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure><p>实例的属性都是在构造函数中定义的，所有实例共享原型链中定义的constructor方法和sayName()方法，而修改其中一个friends并不会影响另一个friends。</p><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">person1.sayName();</div></pre></td></tr></table></figure><p>这段代码只会在初次调用构造函数时才会执行。此后，原型已经初始化，不需要做什么修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象字面量&quot;&gt;&lt;a href=&quot;#对象字面量&quot; class=&quot;headerlink&quot; title=&quot;对象字面量&quot;&gt;&lt;/a&gt;对象字面量&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的this理解</title>
    <link href="http://yoursite.com/2018/03/03/JavaScript%E7%9A%84this%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/03/JavaScript的this理解/</id>
    <published>2018-03-03T03:35:55.000Z</published>
    <updated>2018-03-12T17:14:33.275Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this理解"><a href="#this理解" class="headerlink" title="this理解"></a>this理解</h2><p>this对象是在运行时基于函数的执行环境的定的。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在浏览器中, window 对象同时也是全局对象：</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line">a = <span class="number">37</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.b = <span class="string">"MDN"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// "MDN"</span></div></pre></td></tr></table></figure></p><p>在全局上下文下调用函数，函数中的this，在严格模式下为全局对象，在非严格模式下为undefined。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//在浏览器中：</span></div><div class="line">f1() === <span class="built_in">window</span>;   <span class="comment">//在浏览器中，全局对象是window</span></div><div class="line"></div><div class="line"><span class="comment">//在Node中：</span></div><div class="line">f1() === global;</div></pre></td></tr></table></figure></p><h4 id="函数作为对象的一个属性"><a href="#函数作为对象的一个属性" class="headerlink" title="函数作为对象的一个属性"></a>函数作为对象的一个属性</h4><p>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getName() <span class="comment">// "My Object"</span></div></pre></td></tr></table></figure></p><p>匿名函数的this略有不同，通常指向window。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getNameFunc()(); <span class="comment">// "The Window"</span></div></pre></td></tr></table></figure></p><p>匿名函数的在搜索活动对象this和arguments的时候会在作用域链上搜索，匿名函数外的执行环境为getNameFunc的执行环境getNameFunc的执行环境中的活动对象并没有this.name，就会停止搜索，直接将this指向window。</p><p>解决这种问题的方式是把this保存作为活动对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getNameFunc()(); <span class="comment">// "My Object"</span></div></pre></td></tr></table></figure></p><h4 id="函数用call或者apply调用"><a href="#函数用call或者apply调用" class="headerlink" title="函数用call或者apply调用"></a>函数用call或者apply调用</h4><p>如果要想把 this 的值从一个上下文传到另一个，就要用 call 或者apply 方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个对象可以作为call和apply的第一个参数，并且this会被绑定到这个对象。</span></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Custom'</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这个属性是在global对象定义的。</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'Global'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsThis</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;  <span class="comment">// this的值取决于函数的调用方式</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">whatsThis();          <span class="comment">// 'Global'</span></div><div class="line">whatsThis.call(obj);  <span class="comment">// 'Custom'</span></div><div class="line">whatsThis.apply(obj); <span class="comment">// 'Custom'</span></div></pre></td></tr></table></figure></p><h4 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h4><p>通过new Foo()一个对象的方式调用构造函数，那么在函数中访问this的时候，this指向的是新对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'lucky4'</span>;</div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1993</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Foo &#123; name: "lucky4", year: 1993 &#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p><p>this指向新创造对象的原因是，在使用new操作符后，调用构造函数会经历一下4个步骤：</p><ol><li>创建一个新对象。</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。</li><li>执行构造函数中的代码。</li><li>返回新对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'lucky4'</span>;</div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1993</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window &#123;...&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo();</div></pre></td></tr></table></figure><p>如果未通过new的方式访问构造函数，那么this将指向Window。</p><h4 id="arrow-function-中的this"><a href="#arrow-function-中的this" class="headerlink" title="arrow function 中的this"></a>arrow function 中的this</h4><p>在箭头函数中，this与封闭词法上下文的this保持一致。在全局代码中，它将被设置为全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globalObject = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</div><div class="line"><span class="built_in">console</span>.log(foo() === globalObject); <span class="comment">// true</span></div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个含有bar方法的obj对象，</span></div><div class="line"><span class="comment">// bar返回一个函数，</span></div><div class="line"><span class="comment">// 这个函数返回this，</span></div><div class="line"><span class="comment">// 这个返回的函数是以箭头函数创建的，</span></div><div class="line"><span class="comment">// 所以它的this被永久绑定到了它外层函数的this。</span></div><div class="line"><span class="comment">// bar的值可以在调用中设置，这反过来又设置了返回函数的值。</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span></div><div class="line"><span class="comment">// 将返回的函数的引用赋值给fn。</span></div><div class="line"><span class="keyword">var</span> fn = obj.bar();</div><div class="line"></div><div class="line"><span class="comment">// 直接调用fn而不设置this，</span></div><div class="line"><span class="comment">// 通常(即不使用箭头函数的情况)默认为全局对象</span></div><div class="line"><span class="comment">// 若在严格模式则为undefined</span></div><div class="line"><span class="built_in">console</span>.log(fn() === obj); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 但是注意，如果你只是引用obj的方法，</span></div><div class="line"><span class="comment">// 而没有调用它</span></div><div class="line"><span class="keyword">var</span> fn2 = obj.bar;</div><div class="line"><span class="comment">// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span></div><div class="line"><span class="built_in">console</span>.log(fn2()() == <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure><h2 id="JavaScript中的this与Java、C-中的this有什么区别"><a href="#JavaScript中的this与Java、C-中的this有什么区别" class="headerlink" title="JavaScript中的this与Java、C++中的this有什么区别?"></a>JavaScript中的this与Java、C++中的this有什么区别?</h2><p>首先看一段Java的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">peel</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaPeel</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[], args)</span> </span>&#123;</div><div class="line">    Banana a = <span class="keyword">new</span> Banana(),</div><div class="line">           b = <span class="keyword">new</span> Banana();</div><div class="line">    a.peel(<span class="number">1</span>);</div><div class="line">    b.peel(<span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在执行代码的时候，编译器做了一些幕后工作，它把所操作对象的应用作为第一个参数传递给了peel()，上面的两个方法的调用变成了这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Banana.peel(a, <span class="number">1</span>);</div><div class="line">Banana.peel(b, <span class="number">2</span>);</div></pre></td></tr></table></figure></p><p>假设你希望在方法内部获得对当前对象的引用。由于上面引用是由编译器传入的，所以没有表示符可用，为此有个专门的关键字：this。this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。</p><p>Java中this的用处有很多包括，返回对当前对象的引用，方便链式调用；将当前对象传递给其他方法；在一个构造器中调用另一个构造器等。</p><p>我认为Java的this和JavaScript的this主要有以下几个区别：</p><ol><li>在调用位置的区别，Java只能在类方法里调用this，JavaScript除可以在方法内外，还可以全局作用域内调用。</li><li>this的值，Java中的this是一个引用，JavaScript中的this是一个类数组对象。</li><li>Java中的this创建后不可改变，JavaScript中的this可以通过使用call，apply，bind等方式改变。</li></ol><p>参考：<br><a href="http://www.cnblogs.com/wangfupeng1988/p/3988422.html" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/3988422.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this</a><br>《JavaScript高级程序设计》<br>《Java编程思想》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;this理解&quot;&gt;&lt;a href=&quot;#this理解&quot; class=&quot;headerlink&quot; title=&quot;this理解&quot;&gt;&lt;/a&gt;this理解&lt;/h2&gt;&lt;p&gt;this对象是在运行时基于函数的执行环境的定的。&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot;
      
    
    </summary>
    
    
      <category term="JavaScipt" scheme="http://yoursite.com/tags/JavaScipt/"/>
    
  </entry>
  
  <entry>
    <title>DOM学习</title>
    <link href="http://yoursite.com/2018/02/27/DOM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/02/27/DOM学习/</id>
    <published>2018-02-26T17:22:19.000Z</published>
    <updated>2018-02-28T17:12:25.312Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。DOM将文档描绘成一个由多层次节点构成的结构。节点分为几种不同类型，每种类型分别表示文档中不同的信息或标记。每个节点拥有自己的特点、数据和方法，另外与其他节点存在某种关系。</p><h2 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h2><p>DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的。</p><p>每个节点都有一个nodeType属性，用于表明节点的类型，由Node类型中定义的12个常量来表示：</p><ul><li>Node.ELEMENT_NODE(1);</li><li>Node.ATTRIBURE_NODE(2);</li><li>Node.TEXT_NODE(3);</li><li>Node.CDATA_SECTION_NODE(4);</li><li>Node.ENTITY_REFERENCE_NODE(5);</li><li>Node.ENTITY_NODE(6);</li><li>Node.PROCESSING_INSTRCTION_NODE(7);</li><li>Node.COMMNET_NODE(8);</li><li>Node.DOCUMENT_NODE(9);</li><li>Node.DOCUMENT_TYPE_NODE(10);</li><li>Node.DOCUMENT_FRAGMENT_NODE(11);</li><li>Node.NOTATION_NODE(12);</li></ul><h4 id="nodeName和nodeValue属性"><a href="#nodeName和nodeValue属性" class="headerlink" title="nodeName和nodeValue属性"></a>nodeName和nodeValue属性</h4><p>使用前最好判断节点类型，对于元素节点，nodeValue值始终为null。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType === <span class="number">1</span>) &#123;</div><div class="line">  value = someNode.nodeName</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>常用的节点关系属性：</p><ul><li>childNodes;</li><li>NodeList;</li><li>parentNode;</li><li>previousSibling;</li><li>nextSibling;</li><li>firstChild;</li><li>lastChild;</li><li>ownerDocument;</li><li>hasChildNodes();</li></ul><p>每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一个类数组对象（有length属性以及内容按序保存），它基于DOM结构动态执行查询的结构，因此DOM结构的变化能够自动反映在NodeList对象中。</p><p>一种将类数组对象转换为数组的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayOfNodes = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes, <span class="number">0</span>)</div></pre></td></tr></table></figure></p><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>常用的操作节点方法：</p><ul><li>appendChild();</li><li>insertBefore(要插入节点，参照节点，如果参照节点为null，则相当于appendChild操作);</li><li>replaceChild(要插入节点，要替换节点);</li><li>removeChild();</li><li>cloneNode();</li></ul><h2 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h2><p>JavaScript通过Document类型表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。Document节点具有下列特征：</p><ul><li>nodeType值为9;</li><li>nodeName值为”#document”;</li><li>nodeValue值为null;</li><li>parentNode值为null;</li><li>ownerDocument值为null;</li></ul><h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><p>Document节点的子节点可以是DocumentType、Element、Comment等，还有两个内置访问子节点的方式:documentElement属性（指向<html>元素），childNodes列表访问文档元素。document.body获得<body>引用，document.doctype获得&lt;!DOCTYPE&gt;的引用。</body></html></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement</div><div class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body</div><div class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype</div></pre></td></tr></table></figure><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>作为HTMLDocument的一个实例，document对象还有一些标准的Document所没有的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得文档标题</span></div><div class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title</div><div class="line"></div><div class="line"><span class="comment">//设置文档标题</span></div><div class="line"><span class="built_in">document</span>.titl = <span class="string">"New page title"</span></div><div class="line"></div><div class="line"><span class="comment">//取得完整的URL</span></div><div class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL</div><div class="line"></div><div class="line"><span class="comment">//取得域名</span></div><div class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain</div><div class="line"></div><div class="line"><span class="comment">//取得来源页面的URL</span></div><div class="line"><span class="keyword">var</span> referrer = <span class="built_in">document</span>.referrer</div></pre></td></tr></table></figure></p><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul><li>getElementById();</li><li>getElementsByTagName();</li><li>getElementsByName();</li></ul><p>后两个方法会返回一个类数组对象HTMLCollection，它与NodeList类似，它有一个特殊的方法,namedItem()，可以通过元素的name特性取得集合中的项，同时还支持按名称访问项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>)</div><div class="line"><span class="keyword">var</span> myImage = images[<span class="string">"myImage"</span>]</div></pre></td></tr></table></figure><h2 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h2><ul><li>document.forms 包含文档中所有<code>&lt;form&gt;</code> 元素，与document.getElementsByTagName(“form”)得到结果相同。</li><li>document.images 包含文档中所有<code>&lt;img&gt;</code> 元素，与document.getElementsByTageName(“img”)得到结果相同。</li></ul><h2 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h2><ul><li>document.write();</li><li>document.writeln();</li><li>document.open();</li><li>document.close();</li></ul><p>如果在文档加载结束后在调用document.write()，那么输出的内容将会重写整个页面。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM&quot;&gt;&lt;a href=&quot;#DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM&quot;&gt;&lt;/a&gt;DOM&lt;/h2&gt;&lt;p&gt;DOM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。DOM将文档描绘成一个由多层次节点构成的结构。节点
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深拷贝</title>
    <link href="http://yoursite.com/2018/02/13/JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/02/13/JavaScript深拷贝/</id>
    <published>2018-02-12T17:28:18.000Z</published>
    <updated>2018-02-12T18:16:01.020Z</updated>
    
    <content type="html"><![CDATA[<p>只针对Object类型的深拷贝，自己总结的三种方式，分别为：递归的方式、广度优先遍历的方式、使用JSON.parse()方法。</p><ol><li><p>递归：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">source</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> key, target</div><div class="line">  <span class="keyword">if</span> (type(source) === <span class="string">"object"</span>) &#123;</div><div class="line">    target = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> source) &#123;</div><div class="line">      <span class="keyword">if</span> (type(source[key]) === <span class="string">"array"</span> || <span class="string">"object"</span>) &#123;</div><div class="line">        target[key] = copy(source[key])</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>广度优先遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> originQueue = [data];</div><div class="line">    <span class="keyword">var</span> copyQueue = [obj];</div><div class="line">    <span class="keyword">while</span>(originQueue.length &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">var</span> _data = originQueue.shift();</div><div class="line">        <span class="keyword">var</span> _obj = copyQueue.shift();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> _data)&#123;</div><div class="line">            <span class="keyword">var</span> _value = _data[key]</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> _value !== <span class="string">'object'</span>)&#123;</div><div class="line">                _obj[key] = _value;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                originQueue.push(_value);</div><div class="line">                _obj[key] = &#123;&#125;;</div><div class="line">                copyQueue.push(_obj[key]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>JSON</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(source))</div></pre></td></tr></table></figure></li></ol><p>参考: <a href="http://blog.csdn.net/sysuzhyupeng/article/details/70340598" target="_blank" rel="external">http://blog.csdn.net/sysuzhyupeng/article/details/70340598</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只针对Object类型的深拷贝，自己总结的三种方式，分别为：递归的方式、广度优先遍历的方式、使用JSON.parse()方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;递归：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript判断变量类型</title>
    <link href="http://yoursite.com/2018/02/09/JavaScript%E5%88%A4%E6%96%AD%E5%8F%98%E9%87%8F%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/02/09/JavaScript判断变量类型/</id>
    <published>2018-02-08T17:44:31.000Z</published>
    <updated>2018-03-08T18:38:32.033Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>6种原始类型(primitives)<ul><li>null</li><li>undefined</li><li>Boolean</li><li>Number</li><li>String</li><li>Symbol(ECMAScript6新定义)</li></ul></li><li>Object</li></ul><h2 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h2><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><blockquote><p>typeof operand</p></blockquote><p>typeof操作符返回一个字符串，代表表达式的类型。</p><h4 id="常见的typeof返回值。"><a href="#常见的typeof返回值。" class="headerlink" title="常见的typeof返回值。"></a>常见的typeof返回值。</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>     === <span class="string">"undefined"</span>; <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> <span class="literal">true</span>          === <span class="string">"boolean"</span>;   <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> <span class="number">42</span>            === <span class="string">"number"</span>;    <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> <span class="string">"42"</span>          === <span class="string">"string"</span>;    <span class="comment">// true</span></div><div class="line"><span class="keyword">typeof</span> &#123; <span class="attr">life</span>: <span class="number">42</span> &#125;  === <span class="string">"object"</span>;    <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// added in ES6!</span></div><div class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>()      === <span class="string">"symbol"</span>;    <span class="comment">// true</span></div></pre></td></tr></table></figure><p>使用typeof操作符的时候有一些特例，上面并没有列出，下面逐个解释。</p><h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="literal">null</span> === <span class="string">"objects"</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure><p>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。ECMAScript提出了一个修复（通过opt-in），但被拒绝。这将导致typeof null === ‘object’。</p><p>如果想要测试为null的value的type，可以使用如下方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = <span class="literal">null</span>;</div><div class="line"></div><div class="line">(!a &amp;&amp; <span class="keyword">typeof</span> a === <span class="string">"object"</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure></p><h4 id="function"><a href="#function" class="headerlink" title="function"></a>function</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123; <span class="comment">/* .. */</span> &#125; === <span class="string">"function"</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure><p>因为[[Call]] 在ECMA-262条款中实现了，function包含[[Call]]属性，它允许function被调用，function可以理解为object的子类型。</p><h4 id="array"><a href="#array" class="headerlink" title="array"></a>array</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typeof</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] === <span class="string">"object"</span>; <span class="comment">// true</span></div></pre></td></tr></table></figure><p>数组同样可以被认为是object的子类型。</p><h4 id="使用new操作符"><a href="#使用new操作符" class="headerlink" title="使用new操作符"></a>使用new操作符</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'String'</span>);</div><div class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">100</span>);</div><div class="line"></div><div class="line"><span class="keyword">typeof</span> str; <span class="comment">// It will return 'object'</span></div><div class="line"><span class="keyword">typeof</span> num; <span class="comment">// It will return 'object'</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>();</div><div class="line"><span class="keyword">typeof</span> func; <span class="comment">// It will return 'function'</span></div></pre></td></tr></table></figure><h2 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h2><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><blockquote><p>object instanceof constructor</p></blockquote><p>instanceof 运算符用来检测 constructor.prototype 是否存在于参数 object 的原型链上。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 定义构造函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">C</span>(<span class="params"></span>)</span>&#123;&#125; </div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">D</span>(<span class="params"></span>)</span>&#123;&#125; </div><div class="line"></div><div class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</div><div class="line"></div><div class="line"></div><div class="line">o <span class="keyword">instanceof</span> C; <span class="comment">// true，因为 Object.getPrototypeOf(o) === C.prototype</span></div><div class="line"></div><div class="line"></div><div class="line">o <span class="keyword">instanceof</span> D; <span class="comment">// false，因为 D.prototype不在o的原型链上</span></div><div class="line"></div><div class="line">o <span class="keyword">instanceof</span> <span class="built_in">Object</span>; <span class="comment">// true,因为Object.prototype.isPrototypeOf(o)返回true</span></div><div class="line">C.prototype <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true,同上</span></div><div class="line"></div><div class="line">C.prototype = &#123;&#125;;</div><div class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> C();</div><div class="line"></div><div class="line">o2 <span class="keyword">instanceof</span> C; <span class="comment">// true</span></div><div class="line"></div><div class="line">o <span class="keyword">instanceof</span> C; <span class="comment">// false,C.prototype指向了一个空对象,这个空对象不在o的原型链上.</span></div><div class="line"></div><div class="line">D.prototype = <span class="keyword">new</span> C(); <span class="comment">// 继承</span></div><div class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> D();</div><div class="line">o3 <span class="keyword">instanceof</span> D; <span class="comment">// true</span></div><div class="line">o3 <span class="keyword">instanceof</span> C; <span class="comment">// true</span></div></pre></td></tr></table></figure></p><p>需要注意的是，如果表达式 obj instanceof Foo 返回true，则并不意味着该表达式会永远返回true，因为Foo.prototype属性的值有可能会改变，改变之后的值很有可能不存在于obj的原型链上，这时原表达式的值就会成为false。另外一种情况下，原表达式的值也会改变，就是改变对象obj的原型链的情况，虽然在目前的ES规范中，我们只能读取对象的原型而不能改变它，但借助于非标准的<strong>proto</strong>魔法属性，是可以实现的。比如执行obj.<strong>proto</strong> = {}之后，obj instanceof Foo就会返回false了。</p><h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isArray = <span class="built_in">Array</span>.isArray ||</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> &#125; ||</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">"[object Array]"</span> &#125; ||</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.isPrototypeOf(obj) &#125;</div></pre></td></tr></table></figure><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> isNumber = <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">typeof</span> obj === <span class="string">"number"</span> &#125; ||</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> obj <span class="keyword">instanceof</span> <span class="built_in">Number</span> &#125; ||</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(obj) === <span class="string">"[object Number]"</span> &#125; ||</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> num = <span class="built_in">Number</span>(val), type = <span class="keyword">typeof</span> val</div><div class="line">    <span class="keyword">return</span> val != <span class="literal">null</span> &amp;&amp; type != <span class="string">'boolean'</span> &amp;&amp;</div><div class="line">      (type != <span class="string">'string'</span> || val.length) &amp;&amp;</div><div class="line">      !<span class="built_in">isNaN</span>(num) &amp;&amp; <span class="built_in">isFinite</span>(num) || <span class="literal">false</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> class2type = &#123;&#125;, toString = class2type.toString</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">likeArray</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj.length ? <span class="literal">true</span> : <span class="literal">false</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">elements, callback</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i, key</div><div class="line">  <span class="keyword">if</span> (likeArray) &#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++) &#123;</div><div class="line">      <span class="keyword">if</span> (callback.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</div><div class="line">    &#125;</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements) &#123;</div><div class="line">      <span class="keyword">if</span> (callback.call(elements[key], i, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> elements</div><div class="line">&#125;</div><div class="line"></div><div class="line">each(<span class="string">"Boolean Number String Function Array Data RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</div><div class="line">  class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase()</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">obj</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> obj == <span class="literal">null</span> ? <span class="built_in">String</span>(obj) :</div><div class="line">    class2type[toString.call(obj)] || <span class="string">"object"</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">obj</span>) </span>&#123; <span class="keyword">return</span> type(obj) == <span class="string">"object"</span> &#125;</div></pre></td></tr></table></figure><p>参考：<br><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch1.md" target="_blank" rel="external">https://github.com/getify/You-Dont-Know-JS/blob/master/types%20%26%20grammar/ch1.md</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof</a><br>《JavaScript高级程序设计》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;数据类型&quot;&gt;&lt;a href=&quot;#数据类型&quot; class=&quot;headerlink&quot; title=&quot;数据类型&quot;&gt;&lt;/a&gt;数据类型&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;6种原始类型(primitives)&lt;ul&gt;
&lt;li&gt;null&lt;/li&gt;
&lt;li&gt;undefined&lt;/li&gt;

      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Zepto.js源码阅读</title>
    <link href="http://yoursite.com/2018/02/03/Zepto-js%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/"/>
    <id>http://yoursite.com/2018/02/03/Zepto-js源码阅读/</id>
    <published>2018-02-02T21:50:56.000Z</published>
    <updated>2018-02-10T17:30:15.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。源码相比jQuery较简单，适合初学者阅读。我们这里从Core模块开始阅读。</p><h2 id="Core模块结构"><a href="#Core模块结构" class="headerlink" title="Core模块结构"></a>Core模块结构</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  ...</div><div class="line">&#125;)()</div><div class="line"></div><div class="line"><span class="built_in">window</span>.Zepto = Zepto</div><div class="line"><span class="built_in">window</span>.$ === undifined &amp;&amp; (<span class="built_in">window</span>.$ = Zepto)</div></pre></td></tr></table></figure><p>我们可以看到，Zepto库提供了一个Zepto全局变量，该变量指向了，块级作用域执行后返回的结果，同时将这个全局变量赋值给window对象的Zepto和$变量作为属性。</p><h2 id="Core模块核心"><a href="#Core模块核心" class="headerlink" title="Core模块核心"></a>Core模块核心</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Zepto = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> <span class="literal">undefined</span>, key, $, classList, ...</div><div class="line">    zepto = &#123;&#125;</div><div class="line">  ...</div><div class="line"></div><div class="line">  function Z(dom, selector) &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line"></div><div class="line">  zepto.Z = <span class="function"><span class="keyword">function</span>(<span class="params">dom, selector</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Z(dom, selector)</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line"></div><div class="line">  zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">    ...</div><div class="line">    return zepto.Z(dom, selector)</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line"></div><div class="line">  $ = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> zepto.init(selector, context)</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line"></div><div class="line">  zepto.qsa = <span class="function"><span class="keyword">function</span>(<span class="params">element, selector</span>)</span>&#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line">  ...</div><div class="line"></div><div class="line">  $.fn = &#123;</div><div class="line">    ...</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  zepto.Z.prototype = Z.prototype = $.fn</div><div class="line"></div><div class="line">  $.zepto = zepto</div><div class="line"></div><div class="line">  <span class="keyword">return</span> $</div><div class="line">&#125;)()</div></pre></td></tr></table></figure><p>Zepto变量指向了模块级作用域返回的$()函数，返回Zepto collection对象，$()函数里调用了zepto局部对象的init()函数，init()函数调用了zepto对象的Z()方法，Z()方法中又创建了Zepto collection对象。同时设置了Z函数显式原型为$.fn对象，并将zepto内部对象设置为$()函数的属性。</p><h2 id="Zepto-collection对象"><a href="#Zepto-collection对象" class="headerlink" title="Zepto collection对象"></a>Zepto collection对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Z</span>(<span class="params">dom, selector</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> i, len = dom ? dom.length : <span class="number">0</span></div><div class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len; i++) <span class="keyword">this</span>[i] = dom[i]</div><div class="line">  <span class="keyword">this</span>.length = len</div><div class="line">  <span class="keyword">this</span>.selector = selector || <span class="string">''</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>Zepto collection对象是一个类数组对象，它包括了dom对象数组、获取到的dom元素的个数以及选择器。同时该函数对象的原型对象被设置为$.fn。</p><p>我个人觉得这个对象较难理解的有以下几点，我会在接下来的博客中解释：</p><ol><li>何为类数组对象。</li><li>原型的设置及隐式原型与显示原型。</li><li>为什么在Chrome console输出Zepto collection对象的时候，对象是被[]数组符号包括的。</li></ol><h2 id="逐个方法解析"><a href="#逐个方法解析" class="headerlink" title="逐个方法解析"></a>逐个方法解析</h2><h4 id="zepto-init"><a href="#zepto-init" class="headerlink" title="zepto.init()"></a>zepto.init()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">zepto.init = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dom</div><div class="line">  <span class="comment">// 未提供参数，返回空的Zepto collection对象</span></div><div class="line">  <span class="keyword">if</span> (!selector) <span class="keyword">return</span> zepto.Z()</div><div class="line">  <span class="comment">// 处理参数为字符串的情况</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">'string'</span>) &#123;</div><div class="line">    selector = selector.trim()</div><div class="line">    <span class="comment">// 如果是一个html片段，那么根据这个片段创建dom元素</span></div><div class="line">    <span class="comment">// 如果是以'&lt;'开头，并且通过fragment正则，通过fragment()方法获取dom</span></div><div class="line">    <span class="comment">// fragment = /^\s*&lt;(\w+|!)[^&gt;]*&gt;/ 匹配空白符等开头，'&lt;&gt;'中间匹配任意字母、下划线或!的匹配项，后面非'&gt;'符号0次或多次</span></div><div class="line">    <span class="keyword">if</span> (selector[<span class="number">0</span>] == <span class="string">'&lt;'</span> &amp;&amp; fragmentRE.test(selector))</div><div class="line">      dom = zepto.fragment(selector, <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></div><div class="line">    <span class="comment">// 有context，根据这个context创建Zepto collection，在该collection上根据selector选择</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</div><div class="line">    <span class="comment">// CSS选择器</span></div><div class="line">    <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// 如果提供了function()，在文档加载时执行function</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (isFunction(selector)) <span class="keyword">return</span> $(<span class="built_in">document</span>).ready(selector)</div><div class="line">  <span class="comment">// 如果Zepto collection已给出，则直接返回</span></div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (zepto.isZ(selector)) <span class="keyword">return</span> selector</div><div class="line">  <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">// 如果选择器是一个数组，将数组中为null的元素去掉</span></div><div class="line">    <span class="keyword">if</span> (isArray(selector)) dom = compact(selector)</div><div class="line">    <span class="comment">// 如果选择器是对象(如dom对象)，则将其用数组封装</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (isObject(selector))</div><div class="line">      dom = [selector], selector = <span class="literal">null</span></div><div class="line">    <span class="comment">// If it's a html fragment, create nodes from it</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (fragmentRE.test(selector))</div><div class="line">      dom = zepto.fragment(selector.trim(), <span class="built_in">RegExp</span>.$<span class="number">1</span>, context), selector = <span class="literal">null</span></div><div class="line">    <span class="comment">// If there's a context, create a collection on that context first, and select</span></div><div class="line">    <span class="comment">// nodes from there</span></div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (context !== <span class="literal">undefined</span>) <span class="keyword">return</span> $(context).find(selector)</div><div class="line">    <span class="comment">// And last but no least, if it's a CSS selector, use it to select nodes.</span></div><div class="line">    <span class="keyword">else</span> dom = zepto.qsa(<span class="built_in">document</span>, selector)</div><div class="line">  &#125;</div><div class="line">  <span class="comment">// create a new Zepto collection from the nodes found</span></div><div class="line">  <span class="keyword">return</span> zepto.Z(dom, selector)</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>上段代码为Zepto选择器功能的逻辑，主要通过以下几种方式进行获取dom：</p><ul><li>选择器为字符串<ul><li>选择器为<html>标签</html></li><li>有context，先获取context，在进行选择</li><li>选择器为CSS选择器</li></ul></li><li>选择器为function()</li><li>选择器为Zepto collection</li><li>选择器为dom、object、数组、html片段等</li></ul><h4 id="each"><a href="#each" class="headerlink" title="$.each()"></a>$.each()</h4><p>$.each(collection, function(index, item){ … })  =&gt;  collection<br>遍历数组元素或以key-value值对方式遍历对象。回调函数返回 false 时停止遍历。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">$.each = <span class="function"><span class="keyword">function</span>(<span class="params">elements, callback</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> i, key</div><div class="line">  <span class="keyword">if</span> (likeArray(elements)) &#123;</div><div class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; elements.length; i++)</div><div class="line">      <span class="keyword">if</span> (callback.call(elements[i], i, elements[i]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> elements)</div><div class="line">      <span class="keyword">if</span> (callback.call(elements[key], key, elements[key]) === <span class="literal">false</span>) <span class="keyword">return</span> elements</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> elements</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>$.each()方法与数组Array.map()方法的区别就是，$.each()方法考虑了集合的情况，使用Array.call()方法对集合内每个元素执行回调函数(i, elements[i]做为参数)，并返回处理后结果。</p><h4 id="contains"><a href="#contains" class="headerlink" title="$.contains()"></a>$.contains()</h4><p>$.contains(parent, node)  =&gt;  boolean<br>检查父节点是否包含给定的dom节点，如果两者是相同的节点，则返回 false。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$.contains = <span class="built_in">document</span>.documentElement.contains ?</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">parent, node</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> parent !== node &amp;&amp; parent.contains(node)</div><div class="line">  &#125; :</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params">parent, node</span>) </span>&#123;</div><div class="line">    <span class="keyword">while</span> (node &amp;&amp; (node = node.parentNode))</div><div class="line">      <span class="keyword">if</span> (node === parent) <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">  &#125;</div></pre></td></tr></table></figure></p><p>方法首先判断了浏览器是否支持Node.contains()方法,如果不支持，则一层一层判断node的父节点和parent是否相等。</p><h4 id="extend"><a href="#extend" class="headerlink" title="$.extend()"></a>$.extend()</h4><p>$.extend(target, [source, [source2, …]])  =&gt;  target<br>$.extend(true, target, [source, …])  =&gt;  target<br>通过源对象扩展目标对象的属性，源对象属性将覆盖目标对象属性。<br>默认情况下为，复制为浅拷贝（浅复制）。如果第一个参数为true表示深度拷贝（深度复制）。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target, source, deep</span>) </span>&#123;</div><div class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> source)</div><div class="line">    <span class="keyword">if</span> (deep &amp;&amp; (isPlainObject(source[key]) || isArray(source[key]))) &#123;</div><div class="line">      <span class="keyword">if</span> (isPlainObject(source[key]) &amp;&amp; !isPlainObject(target[key]))</div><div class="line">        target[key] = &#123;&#125;</div><div class="line">      <span class="keyword">if</span> (isArray(source[key]) &amp;&amp; !isArray(target[key]))</div><div class="line">        target[key] = []</div><div class="line">      extend(target[key], source[key], deep)</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</div><div class="line">&#125;</div><div class="line"></div><div class="line">$.extend = <span class="function"><span class="keyword">function</span>(<span class="params">target</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> deep, args = slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> target == <span class="string">'boolean'</span>) &#123;</div><div class="line">    deep = target</div><div class="line">    target = args.shift()</div><div class="line">  &#125;</div><div class="line">  args.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123; extend(target, arg, deep) &#125;)</div><div class="line">  <span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>$.extend方法处理的是一个可选参数的逻辑，首先假设deep为undifined。</p><ul><li>如果第一个参数是布尔型则将deep设置为true，将args[0]表示未target, source为args[1…]。</li><li>如果第一个参数不是布尔型则deep为undifined，参数target表示target，source为args[0…]。</li><li>执行extend()方法，参数为target和source的组合。</li></ul><p>extend()方法为一个递归深拷贝的方法，其中处理了当目标target[key]存在或者不存在的情况。</p><ul><li>如果存在，则将其覆盖。</li><li>如果不存在，则创建新的空对象/数组，进行存储。</li></ul><h4 id="isNumeric"><a href="#isNumeric" class="headerlink" title="$.isNumeric()"></a>$.isNumeric()</h4><p>$.isNumeric(value)  =&gt;  boolean<br>如果该值为有限数值或一个字符串表示的数字，则返回ture。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">$.isNumeric = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> num = <span class="built_in">Number</span>(val), type = <span class="keyword">typeof</span> val</div><div class="line">  <span class="keyword">return</span> val != <span class="literal">null</span> &amp;&amp; type != <span class="string">'boolean'</span> &amp;&amp;</div><div class="line">    (type != <span class="string">'string'</span> || val.length) &amp;&amp;</div><div class="line">    !<span class="built_in">isNaN</span>(num) &amp;&amp; <span class="built_in">isFinite</span>(num) || <span class="literal">false</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>这个方法应该注意的是使用Number(val)进行类型装换后，非字符串类型会被转换为NaN或者Finite类型。</p><h4 id="zepto-Z-prototype-find"><a href="#zepto-Z-prototype-find" class="headerlink" title="zepto.Z.prototype.find()"></a>zepto.Z.prototype.find()</h4><p>find(selector)  =&gt;  collection<br>find(collection)  =&gt;  collection v1.0+<br>find(element)  =&gt;  collection v1.0+<br>在当对象前集合内查找符合CSS选择器的每个元素的后代元素。<br>如果给定Zepto对象集合或者元素，过滤它们，只有当它们在当前Zepto集合对象中时，才回被返回。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">find: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> result, $<span class="keyword">this</span> = <span class="keyword">this</span></div><div class="line">  <span class="keyword">if</span> (!selector) result = $()</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> selector == <span class="string">'object'</span>)</div><div class="line">    result = $(selector).filter(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      <span class="keyword">var</span> node = <span class="keyword">this</span></div><div class="line">      <span class="keyword">return</span> emptyArray.some.call($<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">parent</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> $.contains(parent, node)</div><div class="line">      &#125;)</div><div class="line">    &#125;)</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.length == <span class="number">1</span>) result = $(zepto.qsa(<span class="keyword">this</span>[<span class="number">0</span>], selector))</div><div class="line">  <span class="keyword">else</span> result = <span class="keyword">this</span>.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> zepto.qsa(<span class="keyword">this</span>, selector) &#125;)</div><div class="line">  <span class="keyword">return</span> result</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>$this代表执行find()方法的Zepto collection对象。选择器为collection/dom时，只有当它们在当前Zepto集合对象中时，才回被返回。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;Zepto是一个轻量级的针对现代高级浏览器的JavaScript库， 它与jquery有着类似的api。源码相比jQuery较简单，适合初学
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Ajax基础</title>
    <link href="http://yoursite.com/2018/01/27/Ajax%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2018/01/27/Ajax基础/</id>
    <published>2018-01-26T18:53:02.000Z</published>
    <updated>2018-02-08T17:50:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是Ajax？"><a href="#什么是Ajax？" class="headerlink" title="什么是Ajax？"></a>什么是Ajax？</h2><blockquote><p>Ajax全称为”Asynchronous JavaScript and XML”(异步的JavaScript和XML),Ajax的核心是XMLHttpRequest对象，它可以和服务器进行通信，发送异步请求，接收服务器发来的数据。其中数据的格式可以包括JSON, XML, HTML和文本等格式。</p></blockquote><p>Ajax的优势：</p><ol><li><p>不需插件支持<br>Ajax不需要任何浏览器插件，就可以被浏览器所支持。</p></li><li><p>优秀的用户体验<br>能在不刷新整个页面的前提下更新数据。</p></li><li><p>提高Web程序的性能<br>传统模式中，数据的提交是通过表单来实现的，而数据获取是靠全页面刷新来重新获取整个页面内容。Ajax只是通过XMLHttpRequest对象向服务器端提交希望提交的数据。</p></li><li><p>减轻服务器和宽带的负担<br>Ajax的工作原理相当于在用户和服务器之间加了一个中间层，使用户操作与服务器响应异步化。它在客户端创建Ajax引擎，把传统方式下的一些服务器负担的工作转移到客户端。</p></li></ol><p>Ajax的不足</p><ol><li>浏览器对XMLHttpRequest对象的支持度不足</li><li>对搜索引擎的支持的不足</li><li>开发和调试工具的缺乏</li></ol><h2 id="核心-XMLHttpRequest"><a href="#核心-XMLHttpRequest" class="headerlink" title="核心:XMLHttpRequest"></a>核心:XMLHttpRequest</h2><p>解释：</p><blockquote><p>XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。</p></blockquote><p>历史：</p><blockquote><p>XMLHttpRequest 最初由微软设计，随后被 Mozilla、Apple 和 Google采纳。如今，该对象已经被 W3C组织标准化。 通过它，你可以很容易的取回一个 URL 上的资源数据。尽管名字里有 XML，但 XMLHttpRequest 可以取回所有类型的数据资源，并不局限于 XML。而且除了 HTTP ，它还支持 file 和 ftp 协议。</p></blockquote><p>构造函数:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">XMLHttpRequest()</div></pre></td></tr></table></figure></p><p>常用属性：</p><ol><li><p>onreadystatechange<br>一个方法（回调函数），当readyState属性改变时会调用它。</p></li><li><p>readyState<br>一个整型数字，代表请求的5种状态。<br>值&emsp;&emsp;状态&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;描述<br>0&emsp;&emsp;UNSENT（未打开）&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;open()方法还未被调用<br>1&emsp;&emsp;OPENED（未发送）&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;open()方法已被调用<br>2&emsp;&emsp;HEADERS_RECEIVED（以获取响应头）&emsp;send()方法已被调用，响应头和响应状态已经返回<br>3&emsp;&emsp;LOADING（正在下载响应体）&emsp;&emsp;&emsp;&emsp;&emsp;响应体下载中；responseText中已经获取了部分数据<br>4&emsp;&emsp;DONE（请求完成）&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;整个请求过程已经完毕</p></li><li><p>response<br>响应实体，多种类型，失败为null。</p></li><li><p>responseText<br>响应实体为文本,失败为null。</p></li><li><p>responseType<br>期待响应的类型。</p></li><li><p>responseXML<br>响应的类型是Document。</p></li><li><p>status<br>响应的状态码。</p></li><li><p>statusText<br>响应的状态信息。</p></li><li><p>timeout<br>代表着一个请求在被自动终止前所消耗的毫秒数。</p></li></ol><p>常用方法:</p><ol><li><p>abort()<br>请求被发送后（send方法调用后），终止请求。</p></li><li><p>open(method, url, async, user, password)<br>初始化请求。（method必须为大写）</p></li><li><p>send(body)<br>发送请求,请求为异步的话方法会立刻返回，请求为同步的话方法会等到响应到达时返回。body为发送内容。</p></li><li><p>setRequestHeader(header, value)<br>设置请求的header，使用原生ajax的时候，发送请求需要设置的包括Access-Control-Allow-Origin，Content-Type头信息。</p></li></ol><p>事件接口：</p><ol><li><p>loadstart<br>Progress has begun.</p></li><li><p>progress<br>In progress.</p></li><li><p>error<br>Progression failed.</p></li><li><p>abort<br>Progression is terminated.</p></li><li><p>timeout<br>Progression is terminated due to preset time expiring.</p></li><li><p>load<br>Progression is successful.</p></li><li><p>loadend<br>Progress has stopped.</p><h2 id="使用XMLHttpRequest对象发送Ajax请求的基本步骤"><a href="#使用XMLHttpRequest对象发送Ajax请求的基本步骤" class="headerlink" title="使用XMLHttpRequest对象发送Ajax请求的基本步骤"></a>使用XMLHttpRequest对象发送Ajax请求的基本步骤</h2></li><li>创建XMLHttpRequest对象。</li><li>告诉XMLHttpRequest对象由哪一个函数处理响应。</li><li>使用XMLHttpRequest对象的open方法，设置请求类型，请求地址以及是否采用异步。</li><li>使用XMLHttpRequest对象的send方法，方法的参数是任何想要发送的内容。如果是GET请求，那么send方法的参数为null；如果是POST请求，那么需要在发送请求前设置请求的MIME类型。</li></ol><h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>这个Ajax例子是一个输入框，输入省份的首字母，在输入框下面会显示省份的所有城市。<br>这里采用了mock的方式生成城市的数据，为了以后扩展扩展这个应用，我们使用模块化的方式编写。</p><p>项目目录：<br>dist<br>&nbsp;&nbsp;&nbsp;&nbsp;bundle.js<br>mock<br>&nbsp;&nbsp;&nbsp;&nbsp;data.js<br>src<br>&nbsp;&nbsp;&nbsp;&nbsp;search.js<br>index.html<br>package.json<br>webpack.config.js</p><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE html&gt;</div><div class="line">&lt;html lang=&quot;en&quot;&gt;</div><div class="line">&lt;head&gt;</div><div class="line">  &lt;meta charset=&quot;UTF-8&quot;&gt;</div><div class="line">  &lt;title&gt;Ajax-Search&lt;/title&gt;</div><div class="line">  &lt;style&gt;</div><div class="line">    .container &#123;</div><div class="line">      overflow: hidden;</div><div class="line">      width: 100%;</div><div class="line">    &#125;</div><div class="line">  &lt;/style&gt;</div><div class="line">&lt;/head&gt;</div><div class="line"></div><div class="line">&lt;body&gt;</div><div class="line">&lt;div class=&quot;container&quot; id=&quot;container&quot;&gt;</div><div class="line">  &lt;input type=&quot;search&quot; id=&quot;province&quot; /&gt;</div><div class="line">  &lt;div id=&quot;city-container&quot;&gt;&lt;/div&gt;</div><div class="line">&lt;/div&gt;</div><div class="line">&lt;/body&gt;</div><div class="line"></div><div class="line">&lt;script src=&quot;./dist/bundle.js&quot;&gt;&lt;/script&gt;</div><div class="line">&lt;/html&gt;</div></pre></td></tr></table></figure><h4 id="data-js"><a href="#data-js" class="headerlink" title="data.js"></a>data.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Mock = <span class="built_in">require</span>(<span class="string">'mockjs'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> HLJ = Mock.mock(<span class="regexp">/hlj\.json/</span>, &#123;</div><div class="line">  <span class="string">'city'</span>: &#123;</div><div class="line">    <span class="string">'110000'</span>: <span class="string">'哈尔滨市'</span>,</div><div class="line">    <span class="string">'110001'</span>: <span class="string">'齐齐哈尔市'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> LN = Mock.mock(<span class="regexp">/ln\.json/</span>, &#123;</div><div class="line">  <span class="string">'city'</span>: &#123;</div><div class="line">    <span class="string">'220000'</span>: <span class="string">'沈阳市'</span>,</div><div class="line">    <span class="string">'220001'</span>: <span class="string">'大连市'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> JL = Mock.mock(<span class="regexp">/jl\.json/</span>, &#123;</div><div class="line">  <span class="string">'city'</span>: &#123;</div><div class="line">    <span class="string">'330000'</span>: <span class="string">'长春市'</span>,</div><div class="line">    <span class="string">'330001'</span>: <span class="string">'吉林市'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> ZJ = Mock.mock(<span class="regexp">/zj\.json/</span>, &#123;</div><div class="line">  <span class="string">'city'</span>: &#123;</div><div class="line">    <span class="string">'440000'</span>: <span class="string">'杭州市'</span>,</div><div class="line">    <span class="string">'440001'</span>: <span class="string">'舟山市'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">var</span> GZ = Mock.mock(<span class="regexp">/gz\.json/</span>, &#123;</div><div class="line">  <span class="string">'city'</span>: &#123;</div><div class="line">    <span class="string">'550000'</span>: <span class="string">'广州市'</span>,</div><div class="line">    <span class="string">'550001'</span>: <span class="string">'惠州市'</span></div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  HLJ,</div><div class="line">  LN,</div><div class="line">  JL,</div><div class="line">  ZJ,</div><div class="line">  GZ</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="search-js"><a href="#search-js" class="headerlink" title="search.js"></a>search.js</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">require</span>(<span class="string">'../mock/data'</span>);</div><div class="line"></div><div class="line"><span class="keyword">var</span> httpRequest = <span class="literal">null</span>;</div><div class="line"><span class="keyword">var</span> containerElem = <span class="built_in">document</span>.getElementById(<span class="string">'city-container'</span>);</div><div class="line"><span class="keyword">var</span> inputElem = <span class="built_in">document</span>.getElementById(<span class="string">'province'</span>);</div><div class="line">inputElem.addEventListener(<span class="string">'input'</span>, getCity);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCity</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> province = e.target.value;</div><div class="line">  makeRequest(province);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeRequest</span>(<span class="params">keyword</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</div><div class="line">    httpRequest = <span class="keyword">new</span> XMLHttpRequest();</div><div class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</div><div class="line">    httpRequest = <span class="keyword">new</span> ActiveXObject();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (!httpRequest) &#123;</div><div class="line">    alert(<span class="string">'Giving up : Cannot create an XMLHTTP instance'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  httpRequest.onreadystatechange = resolve;</div><div class="line">  httpRequest.open(<span class="string">'GET'</span>, keyword + <span class="string">'.json'</span>, <span class="literal">true</span>);</div><div class="line">  httpRequest.send(<span class="literal">null</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolve</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> cityContainerElem = <span class="built_in">document</span>.createElement(<span class="string">'ul'</span>);</div><div class="line">  <span class="keyword">var</span> cityData = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> cityElem = <span class="literal">null</span>;</div><div class="line">  <span class="keyword">var</span> city = <span class="string">'no data'</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (httpRequest.readyState === XMLHttpRequest.DONE) &#123;</div><div class="line">    <span class="keyword">if</span> (httpRequest.status === <span class="number">200</span>) &#123;</div><div class="line">      cityData = <span class="built_in">JSON</span>.parse(httpRequest.responseText).city;</div><div class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> cityData) &#123;</div><div class="line">        city = <span class="built_in">document</span>.createTextNode(cityData[item]);</div><div class="line">        cityElem = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line">        cityElem.appendChild(city);</div><div class="line">        cityContainerElem.appendChild(cityElem);</div><div class="line">      &#125;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (httpRequest.status === <span class="number">404</span>) &#123;</div><div class="line">      city = <span class="built_in">document</span>.createTextNode(city);</div><div class="line">      cityElem = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>);</div><div class="line">      cityElem.appendChild(city);</div><div class="line">      cityContainerElem.appendChild(cityElem);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (containerElem.childNodes.length !== <span class="number">0</span>) &#123;</div><div class="line">      containerElem.replaceChild(cityContainerElem, containerElem.firstChild);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      containerElem.appendChild(cityContainerElem);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>同时我写的一个简单弹幕demo地址：<a href="https://github.com/Lucky4/barrage" target="_blank" rel="external">https://github.com/Lucky4/barrage</a></p><p>参考：<br><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX" target="_blank" rel="external">https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX</a><br><a href="https://xhr.spec.whatwg.org/" target="_blank" rel="external">https://xhr.spec.whatwg.org/</a><br>《锋利的JQuery》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是Ajax？&quot;&gt;&lt;a href=&quot;#什么是Ajax？&quot; class=&quot;headerlink&quot; title=&quot;什么是Ajax？&quot;&gt;&lt;/a&gt;什么是Ajax？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Ajax全称为”Asynchronous JavaScript a
      
    
    </summary>
    
    
      <category term="Ajax" scheme="http://yoursite.com/tags/Ajax/"/>
    
  </entry>
  
  <entry>
    <title>babel学习</title>
    <link href="http://yoursite.com/2018/01/08/babel%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/01/08/babel学习/</id>
    <published>2018-01-08T03:50:06.000Z</published>
    <updated>2018-01-08T04:04:13.436Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md" target="_blank" rel="external">https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/thejameskyle/babel-handbook/blob/master/translations/zh-Hans/user-handbook.md&quot; target=&quot;_blank&quot; rel=&quot;external&quot;
      
    
    </summary>
    
    
      <category term="JavaScript babel" scheme="http://yoursite.com/tags/JavaScript-babel/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript一个困惑已久的语法</title>
    <link href="http://yoursite.com/2017/12/19/JavaScript%E4%B8%80%E4%B8%AA%E5%9B%B0%E6%83%91%E5%B7%B2%E4%B9%85%E7%9A%84%E8%AF%AD%E6%B3%95/"/>
    <id>http://yoursite.com/2017/12/19/JavaScript一个困惑已久的语法/</id>
    <published>2017-12-19T04:09:41.000Z</published>
    <updated>2018-02-08T17:52:07.471Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>之前在写React的时候，关于state的一种写法一直没有看懂。</p><p>正常这样写：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>() &#123;</div><div class="line">    <span class="keyword">this</span>.state = &#123;</div><div class="line">      <span class="attr">x</span>: <span class="number">1</span>,</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.aa = <span class="keyword">this</span>.aa.bind(<span class="keyword">this</span>)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">aa</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.x)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>困惑的情形：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">component</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  state = &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">1</span>,</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  aa = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.state.x);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>经过我的一番搜索，终于找到了答案，这是ES的一种新提案，并没有普及，使用的时候需要使用插件，叫做babel-plugin-transform-class-properties，它将原来将类属性写在constructor的写法简化为写在类中就可以了。</p><p>相关参考：</p><ul><li><a href="http://babeljs.io/docs/plugins/transform-class-properties" target="_blank" rel="external">http://babeljs.io/docs/plugins/transform-class-properties</a></li><li><a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="external">https://github.com/tc39/proposal-class-fields</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;之前在写React的时候，关于state的一种写法一直没有看懂。&lt;/p&gt;
&lt;p&gt;正常这样写：&lt;br&gt;&lt;figure class=&quot;highl
      
    
    </summary>
    
    
      <category term="ES6" scheme="http://yoursite.com/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>React-ref属性</title>
    <link href="http://yoursite.com/2017/12/18/React-ref%E5%B1%9E%E6%80%A7/"/>
    <id>http://yoursite.com/2017/12/18/React-ref属性/</id>
    <published>2017-12-18T04:13:15.000Z</published>
    <updated>2018-02-08T17:52:28.886Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ref属性介绍"><a href="#ref属性介绍" class="headerlink" title="ref属性介绍"></a>ref属性介绍</h2><p>在React典型的数据流中，修改子组件都是通过重新渲染新的props来完成的。但是，当你想要在数据流之外修改子组件，就需要React提供的ref属性。</p><p>ref在元素中声明，代表着该元素提供了可以操作的DOM操作（React组件中提供的是虚拟DOM操作）。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li>处理focus、text selection</li><li>处理交互动画</li><li>与第三方DOM库集成</li></ul><h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ol><li>使用回调函数<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(props) &#123;</div><div class="line">    <span class="keyword">super</span>(props);</div><div class="line">    <span class="keyword">this</span>.focusTextInput = <span class="keyword">this</span>.focusTextInput.bind(<span class="keyword">this</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  focusTextInput() &#123;</div><div class="line">    <span class="keyword">this</span>.textInput.focus();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  render() &#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;input</div><div class="line">          type="text"</div><div class="line">          ref=&#123;(input) =&gt; &#123; this.textInput = input; &#125;&#125; /&gt;</div><div class="line">        &lt;input</div><div class="line">          type="button"</div><div class="line">          value="Focus the text input"</div><div class="line">          onClick=&#123;this.focusTextInput&#125;</div><div class="line">        /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li></ol><p>点击按钮后，input输入框会focus。</p><p>React会在组件加载后调用ref回调函数，在componentDidMount函数周期之前invoke或在componentDidUpdate周期中执行。</p><p>需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错。</p><ol><li>使用ref属性名<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MyComponent = React.createClass(&#123;</div><div class="line">  <span class="attr">handleClick</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.refs.myTextInput.focus();</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> (</div><div class="line">      &lt;div&gt;</div><div class="line">        &lt;input type="text" ref="myTextInput" /&gt;</div><div class="line">        &lt;input type="button" value="Focus the text input" onClick=&#123;this.handleClick&#125; /&gt;</div><div class="line">      &lt;/div&gt;</div><div class="line">    );</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure></li></ol><p>React不建议用refs，因为有许多弊端。<a href="https://github.com/facebook/react/pull/8333#issuecomment-271648615" target="_blank" rel="external">https://github.com/facebook/react/pull/8333#issuecomment-271648615</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;ref属性介绍&quot;&gt;&lt;a href=&quot;#ref属性介绍&quot; class=&quot;headerlink&quot; title=&quot;ref属性介绍&quot;&gt;&lt;/a&gt;ref属性介绍&lt;/h2&gt;&lt;p&gt;在React典型的数据流中，修改子组件都是通过重新渲染新的props来完成的。但是，当你想要在数据流
      
    
    </summary>
    
    
      <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript事件对象中e.target和e.currentTarget区别</title>
    <link href="http://yoursite.com/2017/12/15/JavaScript%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E4%B8%ADe-target%E5%92%8Ce-currentTarget%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2017/12/15/JavaScript事件对象中e-target和e-currentTarget区别/</id>
    <published>2017-12-14T17:41:43.000Z</published>
    <updated>2018-02-08T17:59:51.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在网页中，点击在多个导航栏切换，被点击的那个导航栏与其他样式不同。然而，看似简答的问题，里面的坑还是有的。</p><p>下面是关键代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">function TopicItem(props) &#123;</div><div class="line">  &lt;li</div><div class="line">    key=&#123;props.id&#125;</div><div class="line">    id=&#123;props.id&#125;</div><div class="line">    calssName=&#123;props.activeTopicId === props.id ? &quot;active&quot;: &quot;&quot;&#125;</div><div class="line">    onClick=&#123;props.togleTopic&#125;</div><div class="line">  &gt;</div><div class="line">    &lt;Link to=&#123;props.hash&#125;&gt;</div><div class="line">      &#123;props.title&#125;</div><div class="line">    &lt;/Link&gt;</div><div class="line">  &lt;/li&gt;</div><div class="line">&#125;</div><div class="line"></div><div class="line">class component extends React.Component &#123;</div><div class="line">  state = &#123;</div><div class="line">    activeTopicId: TOPICS[0].id,</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  togleTopic = (e) =&gt; &#123;</div><div class="line">    this.setState(&#123;</div><div class="line">      activeTopicId: e.currentTarget.id    // 这里是关键</div><div class="line">    &#125;);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>可以看到我们的导航栏结构是li标签里面嵌套着a标签，我想通过点击导航栏，获得点击li标签的id来判断，设置样式，但我么有一点要注意：事件对象有两个类似的属性,target和currentTarget。</p><blockquote><p>A reference to the object that dispatched the event. It is different from event.currentTarget when the event handler is called during the bubbling or capturing phase of the event.</p></blockquote><p>从MDN的官网上说明可以看出它们都是指向事件对象的一个引用，一个是在事件捕获的时候调用，一个是在事件冒泡的时候调用。</p><p>所以，如果我使用e.target.id来获得activeTopicId是不可能获得的，因为e.target指向的对象时a标签，没有id。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在网页中，点击在多个导航栏切换，被点击的那个导航栏与其他样式不同。然而，看似简答的问题，里面的坑还是有的。&lt;/p&gt;
&lt;p&gt;下面是关键代码：&lt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>BOM学习</title>
    <link href="http://yoursite.com/2017/12/10/BOM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/12/10/BOM学习/</id>
    <published>2017-12-09T18:04:35.000Z</published>
    <updated>2018-02-08T17:50:39.907Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>JavaScript由三个核心部分组成，分别是ECMAScript、BOM、DOM。</p><h2 id="文档对象模型BOM"><a href="#文档对象模型BOM" class="headerlink" title="文档对象模型BOM"></a>文档对象模型BOM</h2><p>BOM提供了很多访问浏览器窗口的接口，包括window对象、location对象、navigator对象、history对象。</p><h3 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h3><p>我的上一篇博客记录了关于setInterval和setTimeout的使用，它们都是window对象的方法。</p><ul><li>setTimeout(arg0, arg1) 超时调用</li><li>setInterval(arg0, arg1) 间歇调用</li></ul><p>它们都接受两个参数，第一个是要执行的代码，第二个是以毫秒形式表示的时间。</p><p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure></p><p>第二个参数表示等待的时间毫秒数，但经过该时间后指定的代码不一定会执行。JavaScript是一个单线程的解释器，因此一定时间内只能执行一段代码。为了控制要执行的代码，就有一个JavaScript任务队列。这些任务会按照将它们添加到队列的顺序执行。setTimeout()的第二个参数告诉JavaScript在过多长时间把当前任务添加到队列中。如果队列是空的，那么添加的代码会立即执行；如果队列不是空的，那么它就要等前面的代码执行完了以后再执行。</p><p>调用setTimeout()会返回一个ID，通过调用clearTimeout()，并将ID作为参数，可以取消未执行的调用计划。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  alert(<span class="string">"Hello world!"</span>);</div><div class="line">&#125;, <span class="number">1000</span>);</div><div class="line"></div><div class="line">clearTimeout(timeoutId);</div></pre></td></tr></table></figure><p>setInterval()的返回参数同样返回ID，通过clearInterval()，将ID作为参数，来取消未执行的间歇调用。</p><p>在使用这两个函数时我们最需要学到的就是setTimeout()和setInterval()之间的相互转化。那就是在使用setTimeout()的时候采用递归调用自己的方式来实现setInterval()的效果。</p><p>最后避免使用间歇调用，推荐超时调用。</p><p>参考：《JavaScript高级程序设计》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;JavaScript由三个核心部分组成，分别是ECMAScript、BOM、DOM。&lt;/p&gt;
&lt;h2 id=&quot;文档对象模型BOM&quot;&gt;&lt;a h
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>刚学就用上了之闭包</title>
    <link href="http://yoursite.com/2017/12/09/%E5%88%9A%E5%AD%A6%E5%B0%B1%E7%94%A8%E4%B8%8A%E4%BA%86%E4%B9%8B%E9%97%AD%E5%8C%85/"/>
    <id>http://yoursite.com/2017/12/09/刚学就用上了之闭包/</id>
    <published>2017-12-09T01:56:15.000Z</published>
    <updated>2018-02-08T17:54:04.303Z</updated>
    
    <content type="html"><![CDATA[<h2 id="说来也巧"><a href="#说来也巧" class="headerlink" title="说来也巧"></a>说来也巧</h2><p>最近投了一个实习岗位，约在周三笔试，之前一天扫了一眼闭包，结果第二天就遇到了，一个很简单的问题，但答得并不是尽如人意，可见编程这东西看永远是不行的。</p><p>描述：</p><blockquote><p>定义这样一个函数</p><p>function doRepeat(func, times, wait) {}</p><p>调用这个函数能返回一个新的函数，比如传入的是alert，这个函数的调用就是var repeatFunc = doRepeat(alert, 10, 5000);</p><p>调用返回的这个新函数，如：repeatFun(“hello world”);</p><p>那么hello world会显示10次，每次间隔5秒。</p></blockquote><p>方法一：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doRepeat</span>(<span class="params">func, times, wait</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params">aa</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      func(aa);</div><div class="line">      count++;</div><div class="line">      <span class="keyword">if</span> (count &lt; times) &#123;</div><div class="line">        f();</div><div class="line">      &#125;</div><div class="line">    &#125;, wait);</div><div class="line">  &#125;;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> f;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>方法二：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doRepeat</span>(<span class="params">func, times, wait</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> count = <span class="number">0</span>;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">aa</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> id = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      func(aa);</div><div class="line">      count++;</div><div class="line">      <span class="keyword">if</span> (count == times) &#123;</div><div class="line">        clearInterval(id);</div><div class="line">      &#125;</div><div class="line">    &#125;, wait);</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>分析：由于昨天刚看完闭包，所以第一眼看这题就想到用闭包的方式去做，之所以没答好的原因主要是因为，对setTimeout和setInterval这两个函数的使用不熟练，唉，js的东西实在太多了，后悔入坑。我会在之后的博客中介绍相关知识。</p><p>了解闭包，我们先介绍匿名，因为很多闭包中返回的函数包括匿名函数。</p><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0, arg1, arg2</span>) </span>&#123;</div><div class="line">  <span class="comment">//函数体</span></div><div class="line">&#125;</div></pre></td></tr></table></figure><p>如上面的例子，function关键字后没有标识符，这种情况下的函数叫做匿名函数。<br>匿名函数有多重用法，上面把匿名函数赋值给了变量functionName(函数可以理解为指向函数对象的指针),这种情况下也叫做拉姆达表达式。还可以将匿名函数用一对括号包裹，之后调用如(function{})();形式，构造一个块级作用域。</p><p>说明：</p><ul><li>使用匿名函数时注意函数声明提升。</li><li>在匿名函数中定义的任何变量，都会在执行结束时被销毁。</li></ul><p>匿名函数的一个应用之一就是闭包。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>描述：闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式，就是在一个函数内部创建另一个函数。</p><p>示例：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComparisonFunction</span>(<span class="params">propertyName</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">object1, object2</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> value1 = object1[propertyName];</div><div class="line">    <span class="keyword">var</span> value2 = object2[propertyName];</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (value1 &lt; value2) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2) &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">      <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>要理解闭包的执行原理，就必须理解JavaScript中的执行环境、作用域链以及活动对象，全局变量对象，这里不表。</p><h2 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h2><p>JavaScript没有块级作用域的概念（注意回想那个经典的面试例子变量i），不过可以使用闭包来实现块级作用域。</p><p>块级作用域的语法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;)();</div></pre></td></tr></table></figure></p><p>一个例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputNumbers</span>(<span class="params">count</span>) </span>&#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">      alert(i);</div><div class="line">    &#125;</div><div class="line">  &#125;)();</div><div class="line"></div><div class="line">  alert(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>运行时会报错，说明i在块级作用域中。</p><h2 id="模块模式-单例模式"><a href="#模块模式-单例模式" class="headerlink" title="模块模式(单例模式)"></a>模块模式(单例模式)</h2><p>所谓单例，指的就是只有一个实例的对象。实现如下：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">publicProperty</span>: <span class="literal">true</span>,</div><div class="line"></div><div class="line">    <span class="attr">publicMethod</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      privateVariable++;</div><div class="line">      <span class="keyword">return</span> privateFunction();</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;();</div></pre></td></tr></table></figure></p><p>这种模式在需要对单例进行某些初始化，同时需要维护其私有变量时是非常有用的。</p><p>内容参考：《JavaScript高级程序设计》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;说来也巧&quot;&gt;&lt;a href=&quot;#说来也巧&quot; class=&quot;headerlink&quot; title=&quot;说来也巧&quot;&gt;&lt;/a&gt;说来也巧&lt;/h2&gt;&lt;p&gt;最近投了一个实习岗位，约在周三笔试，之前一天扫了一眼闭包，结果第二天就遇到了，一个很简单的问题，但答得并不是尽如人意，可见编
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>处理Django中session小记</title>
    <link href="http://yoursite.com/2017/12/02/%E5%A4%84%E7%90%86Django%E4%B8%ADsession%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/12/02/处理Django中session小记/</id>
    <published>2017-12-01T22:42:36.000Z</published>
    <updated>2018-02-08T17:53:28.399Z</updated>
    
    <content type="html"><![CDATA[<h2 id="来龙去脉"><a href="#来龙去脉" class="headerlink" title="来龙去脉"></a>来龙去脉</h2><p>每个网站的用户在登录之后都会有重置密码的功能，如果有两个用户同时登录到一个账号，并且用户A在登录后重置了密码，而用户B却没有退出登陆的情况下，用户B就可以在继续操做账号，所以我们就要在A执行操作后，让B不能够访问账号，那么如何解决这个问题呢？</p><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>HTTP协议是无状态的，服务器判断一个用户是否为登录状态的方法就是通过判断客户端请求的cookie中的sessionid，如果sessionid和服务器端保存的session中的id相同，那么这个客户端就可以被认为是合法的用户。（注意：服务器端保存的某个账号的session有很多个，session中的许多信息是相同的，比如user_id，username等，但是sessionid确实不同的。）</p><p>那么我们的解决方法就可以分为以下几步：</p><ol><li>某个用户重置密码</li><li>立即将数据库中session表进行过滤，删除userid为这个重置用户的id的所有session</li><li>根据请求信息，重写生成session，响应返回</li></ol><h2 id="Django中处理session的坑"><a href="#Django中处理session的坑" class="headerlink" title="Django中处理session的坑"></a>Django中处理session的坑</h2><p>Django中session model：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Session</span><span class="params">(AbstractBaseSession)</span>:</span></div><div class="line">    objects = SessionManager()</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_session_store_class</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">from</span> django.contrib.sessions.backends.db <span class="keyword">import</span> SessionStore</div><div class="line">        <span class="keyword">return</span> SessionStore</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span><span class="params">(AbstractBaseSession.Meta)</span>:</span></div><div class="line">        db_table = <span class="string">'django_session'</span></div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseSessionManager</span><span class="params">(models.Manager)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">encode</span><span class="params">(self, session_dict)</span>:</span></div><div class="line">        <span class="string">"""</span></div><div class="line">        Return the given session dictionary serialized and encoded as a string.</div><div class="line">        """</div><div class="line">        session_store_class = self.model.get_session_store_class()</div><div class="line">        <span class="keyword">return</span> session_store_class().encode(session_dict)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save</span><span class="params">(self, session_key, session_dict, expire_date)</span>:</span></div><div class="line">        s = self.model(session_key, self.encode(session_dict), expire_date)</div><div class="line">        <span class="keyword">if</span> session_dict:</div><div class="line">            s.save()</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            s.delete()  <span class="comment"># Clear sessions with no data.</span></div><div class="line">        <span class="keyword">return</span> s</div><div class="line"></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractBaseSession</span><span class="params">(models.Model)</span>:</span></div><div class="line">    session_key = models.CharField(_(<span class="string">'session key'</span>), max_length=<span class="number">40</span>, primary_key=<span class="keyword">True</span>)</div><div class="line">    session_data = models.TextField(_(<span class="string">'session data'</span>))</div><div class="line">    expire_date = models.DateTimeField(_(<span class="string">'expire date'</span>), db_index=<span class="keyword">True</span>)</div><div class="line"></div><div class="line">    objects = BaseSessionManager()</div><div class="line"></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></div><div class="line">        abstract = <span class="keyword">True</span></div><div class="line">        verbose_name = _(<span class="string">'session'</span>)</div><div class="line">        verbose_name_plural = _(<span class="string">'sessions'</span>)</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></div><div class="line">        <span class="keyword">return</span> self.session_key</div><div class="line"></div><div class="line"><span class="meta">    @classmethod</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_session_store_class</span><span class="params">(cls)</span>:</span></div><div class="line">        <span class="keyword">raise</span> NotImplementedError</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_decoded</span><span class="params">(self)</span>:</span></div><div class="line">        session_store_class = self.get_session_store_class()</div><div class="line">        <span class="keyword">return</span> session_store_class().decode(self.session_data)</div></pre></td></tr></table></figure></p><p>从session的模型中我们可以看出，session_data是通过编码后保存的，session_data中就包含请求的user_id，当我们要删除所有请求user的session的时候就需要根据这个user_id来查找，即session模型不支持反向查询，所以我们在处理这的时候需要查询出所有session，然后对每个session执行get_decoded方法来查找判断user_id。这个放下效率肯定会很低下，不过暂时也没有想到更好的方法。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;来龙去脉&quot;&gt;&lt;a href=&quot;#来龙去脉&quot; class=&quot;headerlink&quot; title=&quot;来龙去脉&quot;&gt;&lt;/a&gt;来龙去脉&lt;/h2&gt;&lt;p&gt;每个网站的用户在登录之后都会有重置密码的功能，如果有两个用户同时登录到一个账号，并且用户A在登录后重置了密码，而用户B却没有
      
    
    </summary>
    
    
      <category term="Seesion" scheme="http://yoursite.com/tags/Seesion/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript引用类型之RegExp正则</title>
    <link href="http://yoursite.com/2017/11/26/JavaScript%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E4%B9%8BRegExp%E6%AD%A3%E5%88%99/"/>
    <id>http://yoursite.com/2017/11/26/JavaScript引用类型之RegExp正则/</id>
    <published>2017-11-26T03:47:14.000Z</published>
    <updated>2017-12-01T22:15:55.118Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>两种写法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">字面量对象形式</div><div class="line">var expression = /pattern/flags;</div><div class="line">构造函数形式</div><div class="line">var expression = new RegExp(pattern, flags);</div></pre></td></tr></table></figure></p><p>pattern<br>正则表达式的文本<br>flag<br>如果指定，标志可以具有以下值的任意组合：</p><ul><li>g<br>  全局匹配;找到所有匹配，而不是在第一个匹配后停止</li><li>i<br>  忽略大小写</li><li>m<br>  多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。</li></ul><p>使用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var expression = /ab+c/i;</div><div class="line">var expression = new RegExp(&quot;ab+c&quot;, &apos;i&apos;);</div></pre></td></tr></table></figure></p><p>两种写法区别：</p><ul><li>正则文本的写法<br>  使用字面量的方式不需写引号。<br>  对于.等需要转义字符，使用构造函数方式需要两次转义（new RegExp(“\\a+c”, “i”)）。</li><li>编译<br>  使用字面量正则对象提供表达式编译状态，表达式不会再每一次迭代中都被重新编译。而使用构造函数方式的正则对象，提供运行时编译即每次迭代会重新编译，导致每次正则对象的执行结果都是相同的。</li></ul><h2 id="正则表达式中特殊字符的含义"><a href="#正则表达式中特殊字符的含义" class="headerlink" title="正则表达式中特殊字符的含义"></a>正则表达式中特殊字符的含义</h2><p>字符类别</p><ul><li>字符”.”——匹配任意字符。</li><li>字符”\d”——匹配任意阿拉伯数字。等价于[0-9]。</li><li>字符”\D”——匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。</li><li>字符”\w”——匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。</li><li>字符”\W”——匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9_]。</li><li>字符”\s”——匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。</li><li>等</li></ul><p>字符集合</p><ul><li>字符”[xyz]”——一个字符集合，也叫字符组。匹配集合中的任意一个字符。你可以使用连字符’-‘指定一个范围。</li><li>字符”[^xyz]”——一个反义或补充字符集，也叫反义字符组。也就是说，它匹配任意不在括号内的字符。你也可以通过使用连字符 ‘-‘ 指定一个范围内的字符。</li></ul><p>边界</p><ul><li>字符”^”——匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。</li><li>字符”$”——匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。</li></ul><p>分组</p><ul><li>字符”(x)”——匹配 x 并且捕获匹配项。被匹配的子字符串可以在结果数组的元素 [1], …, [n] 中找到，或在被定义的 RegExp 对象的属性 $1, …, $9 中找到。</li><li>字符”(?:x)”——捕获括号。匹配项不能够从结果数组的元素 [1], …, [n] 或已被定义的 RegExp 对象的属性 $1, …, $9 再次访问到。</li></ul><p>数量词</p><ul><li>字符”x*”——匹配前面的模式 x 0 或多次。</li><li>字符”x+”——匹配前面的模式 x 1 或多次。等价于 {1,}。</li><li><p>字符”x?”——匹配前面的模式 x 0 或 1 次。如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化。反之，默认情况下，是贪婪的（greedy），即匹配次数最大化。</p></li><li><p>字符”x|y”——匹配 x 或 y。</p></li><li>字符”x{n}”——n 是一个正整数。前面的模式 x 连续出现 n 次时匹配。</li><li>字符”x{n,}”——n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。</li><li>字符”x{n,m}”——n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。</li></ul><h2 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h2><p>由于应用中使用较少，这里不赘述。</p><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li>RegExp.prototype.exec()<br>  在目标字符串中执行一次正则匹配操作。返回匹配结果。</li><li>RegExp.prototype.test()<br>  测试当前正则是否能匹配目标字符串。返回true or false。</li></ul><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><p>RegExp.$1, …, RegExp.$9</p><ul><li>是包含括号子串匹配的正则表达式的静态和只读属性。</li><li>相关链接<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp/n</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语法&quot;&gt;&lt;a href=&quot;#语法&quot; class=&quot;headerlink&quot; title=&quot;语法&quot;&gt;&lt;/a&gt;语法&lt;/h2&gt;&lt;p&gt;两种写法&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>开始使用JavaScript环境包管理工具之npm</title>
    <link href="http://yoursite.com/2017/10/28/%E5%BC%80%E5%A7%8B%E4%BD%BF%E7%94%A8JavaScript%E7%8E%AF%E5%A2%83%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7%E4%B9%8Bnpm/"/>
    <id>http://yoursite.com/2017/10/28/开始使用JavaScript环境包管理工具之npm/</id>
    <published>2017-10-28T06:55:42.000Z</published>
    <updated>2017-10-28T07:08:51.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是npm"><a href="#什么是npm" class="headerlink" title="什么是npm"></a>什么是npm</h2><p>npm 是一个js包管理工具，可以帮助分享你的代码、使用别人分享的代码，并且提供简单的方式管理不同版本的代码。</p><h2 id="安装Node-js和更新npm"><a href="#安装Node-js和更新npm" class="headerlink" title="安装Node.js和更新npm"></a>安装Node.js和更新npm</h2><p>使用npm工具需要首先安装Node.js环境，Node环境可以到官方网站下载，下载后环境内就可以使用npm命令管理js包代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">更新npm：</div><div class="line">npm install npm@latest –g</div><div class="line">查看npm版本：</div><div class="line">npm –v</div></pre></td></tr></table></figure></p><h2 id="npm安装包的方式"><a href="#npm安装包的方式" class="headerlink" title="npm安装包的方式"></a>npm安装包的方式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">本地安装：</div><div class="line">npm install &lt;package_name&gt; 通过类似require的方式使用</div><div class="line">全局安装：</div><div class="line">npm install –g &lt;package_name&gt;</div></pre></td></tr></table></figure><h2 id="管理本地安装包package-json"><a href="#管理本地安装包package-json" class="headerlink" title="管理本地安装包package.json"></a>管理本地安装包package.json</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">创建package.json:</div><div class="line">npm init –yes 根据当前文件夹生成package.json</div><div class="line">设置package.json初始信息：</div><div class="line">npm set init.license &quot;MIT&quot;</div></pre></td></tr></table></figure><h2 id="指明项目依赖到package-json"><a href="#指明项目依赖到package-json" class="headerlink" title="指明项目依赖到package.json"></a>指明项目依赖到package.json</h2><p>dependencies：应用需要依赖的包<br>devDependencies：开发环境需要依赖的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">在package.json的dependencies添加入口：</div><div class="line">npm install &lt;package_name&gt; --save</div><div class="line">在package.json的devDependencies添加入口：</div><div class="line">npm install &lt;package_name&gt; --save-dev</div><div class="line">按照package.json安装依赖：</div><div class="line">npm install</div></pre></td></tr></table></figure></p><h2 id="更新安装包"><a href="#更新安装包" class="headerlink" title="更新安装包"></a>更新安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">更新package.json中的依赖包：</div><div class="line">npm update</div><div class="line">更新全局安装的包：</div><div class="line">npm update –g</div></pre></td></tr></table></figure><h2 id="卸载安装包"><a href="#卸载安装包" class="headerlink" title="卸载安装包"></a>卸载安装包</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">卸载：</div><div class="line">npm uninstall &lt;package_name&gt;</div><div class="line">卸载同时在package.json中移除依赖：</div><div class="line">npm uninstall –save &lt;package_name&gt;</div><div class="line">卸载全局安装的包：</div><div class="line">npm uninstall –g &lt;package_name&gt;</div></pre></td></tr></table></figure><h2 id="CLI-Commands"><a href="#CLI-Commands" class="headerlink" title="CLI Commands"></a>CLI Commands</h2><p>npm 提供了命令行界面命令来管理使用npm<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">查看已安装包：</div><div class="line">npm ls &lt;scope&gt;</div></pre></td></tr></table></figure></p><p>未完待续，之后会把学习中遇到的命令以及npm的理念的等核心内容整理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是npm&quot;&gt;&lt;a href=&quot;#什么是npm&quot; class=&quot;headerlink&quot; title=&quot;什么是npm&quot;&gt;&lt;/a&gt;什么是npm&lt;/h2&gt;&lt;p&gt;npm 是一个js包管理工具，可以帮助分享你的代码、使用别人分享的代码，并且提供简单的方式管理不同版本的代码
      
    
    </summary>
    
    
      <category term="npm" scheme="http://yoursite.com/tags/npm/"/>
    
  </entry>
  
  <entry>
    <title>简单谈谈callback</title>
    <link href="http://yoursite.com/2017/10/14/%E7%AE%80%E5%8D%95%E8%B0%88%E8%B0%88callback/"/>
    <id>http://yoursite.com/2017/10/14/简单谈谈callback/</id>
    <published>2017-10-13T22:46:01.000Z</published>
    <updated>2018-02-08T17:55:12.233Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在看ES6新特性Promise的时候，看到了Callback这个概念，我以较表面的层次，理解下callback。</p><blockquote><p>Callback是异步执行或晚一些执行的函数。异步编程是根据之前函数的执行速度，在不同的时间，执行不同函数，而非按照程序代码的顺序执行，之前函数可以是比如http请求或文件读取。</p></blockquote><p>下面的示例代码使用node。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">var</span> myNumber = <span class="literal">undefined</span> </div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  fs.readFile(<span class="string">'number.txt'</span>, <span class="function"><span class="keyword">function</span> <span class="title">doneReading</span>(<span class="params">err, fileContents</span>) </span>&#123;</div><div class="line">    myNumber = <span class="built_in">parseInt</span>(fileContents)</div><div class="line">    myNumber++</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line">addOne()</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(myNumber)</div></pre></td></tr></table></figure><p>上面的代码会输出undefined，这是因为fs.readFile方法是一个异步方法。它会访问硬盘或者进行网络请求，这些都会是异步的。此时如果恰巧正在处理的程序在访问呢内存或访问CPU，那么其他程序工作就是异步的。因为I/O访问真的非常慢。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>)</div><div class="line"><span class="keyword">var</span> myNumber = <span class="literal">undefined</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">callback</span>) </span>&#123;</div><div class="line">  fs.readFile(<span class="string">'number.txt'</span>, <span class="function"><span class="keyword">function</span> <span class="title">doneReading</span>(<span class="params">err, fileContents</span>) </span>&#123;</div><div class="line">    myNumber = <span class="built_in">parseInt</span>(fileContents)</div><div class="line">    myNumber++</div><div class="line">    callback()</div><div class="line">  &#125;)</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">logMyNumber</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(myNumber)</div><div class="line">&#125;</div><div class="line"></div><div class="line">addOne(logMyNumber)</div></pre></td></tr></table></figure><p>上面的代码会成功输出结果，我们在addOne函数中传入了一个callback函数，在执行fs.readFile的时候该函数会检查该函数是否完成，如果完成，那么那么就执行后面的function里面的内容，这时我们的callback函数就会被系统回调，所以说编写callback时我们并不需要知道异步行为什么时候完成，而只需要知道在哪里完成。</p><p>参考链接：<a href="https://github.com/maxogden/art-of-node#callbacks" target="_blank" rel="external">https://github.com/maxogden/art-of-node#callbacks</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在看ES6新特性Promise的时候，看到了Callback这个概念，我以较表面的层次，理解下callback。&lt;/p&gt;
&lt;blockq
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>网站前后端分离模式下国际化问题小记</title>
    <link href="http://yoursite.com/2017/09/26/%E7%BD%91%E7%AB%99%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%9B%BD%E9%99%85%E5%8C%96%E9%97%AE%E9%A2%98%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/09/26/网站前后端分离模式下国际化问题小记/</id>
    <published>2017-09-26T03:36:05.000Z</published>
    <updated>2018-02-08T17:58:33.338Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>一个大型网站的构建中，国际化是一个不可或缺的部分，它可以提供对不同语言、时区的支持。</p><ul><li>国际化：是指为了该软件在任何地区的潜在使用而进行程序设计的过程。 它包括了为将来翻译而标记的文本（比如用户界面要素和错误信息等）、日期和时间的抽象显示以便保证不同地区的标准得到遵循、为不同时区提供支持，并且一般确保代码中不会存在关于使用者所在地区的假设。 您会经常看到国际化被缩写为“I18N”(18表示Internationlization这个单词首字母I和结尾字母N之间的字母有18个)。</li><li>本地化：是指使一个国际化的程序为了在某个特定地区使用而进行实际翻译的过程。 有时，本地化缩写为 L10N(localization) 。</li></ul><p>我们这里讲本地化，对于一个前后端分离的项目结构，如Django+React，那么前端可以使用react-intl模块处理编辑页面中显示的语言内容。但是，在前后端的交互过程中，如前端请求失败,后端返回错误信息，那么这个错误信息前端是无法动态翻译的，此时一种可行的方法是我们就需要在后端将要返回的内容进行翻译，返回给前端显示。</p><h2 id="Django中的翻译"><a href="#Django中的翻译" class="headerlink" title="Django中的翻译"></a>Django中的翻译</h2><p>Django本身是完全国际化了的，所有的字符串均因翻译所需而被标记，您只需要添加少量的挂接代码到您的Python代码和模板中。 这些挂接代码被称为“翻译字符串”。它们告诉Django：如果这段文本的译文可用的话，它应被翻译为终端用户指定的语言。对Django应用只需进行三步:</p><ol><li>指定翻译字符串</li><li>创建语言文件</li><li>配置</li></ol><h4 id="指定翻译字符串"><a href="#指定翻译字符串" class="headerlink" title="指定翻译字符串"></a>指定翻译字符串</h4><ul><li><p>标准翻译，使用函数 ugettext() 来指定一个翻译字符串。 作为惯例，使用短别名 _ 来引入这个函数以节省键入时间.</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext <span class="keyword">as</span> _</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_view</span><span class="params">(request)</span>:</span></div><div class="line">    output = _(<span class="string">"Welcome to my site."</span>)</div><div class="line">    <span class="keyword">return</span> HttpResponse(output)</div></pre></td></tr></table></figure></li><li><p>惰性翻译，使用gettext_lazy() 函数，使得其中的值只有在访问时才会被翻译，而不是在 gettext_lazy() 被调用时翻译。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext_lazy</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThing</span><span class="params">(models.Model)</span>:</span></div><div class="line">    name = models.CharField(help_text=ugettext_lazy(<span class="string">'This is the help text'</span>))</div></pre></td></tr></table></figure></li></ul><h4 id="创建语言文件"><a href="#创建语言文件" class="headerlink" title="创建语言文件"></a>创建语言文件</h4><p>当你标记了翻译字符串，你就需要写出（或获取已有的）对应的语言翻译信息。为一种语言创建一个信息文件，信息文件以 .po 为后缀名。</p><ul><li>创建信息文件<br>使用Django工具manage.py，运行命令：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">django-admin.py makemessages -l zh_CN -e py</div></pre></td></tr></table></figure></li></ul><p>zh_CN是所创建信息文件的语言代码，配置文件中配置的是zh-cn，但是使用zn-cn是无效的文件夹名，所以我们使用zh_CN保存语言文件。<br>-e 选项指定文件扩展名来检测。<br>-a 会检验所有的文件名和模板检测。<br>这段脚本遍历你的项目源树或你的应用程序源树并且提取出所有为翻译而被标记的字符串。 它在 locale/LANG/LC_MESSAGES 目录下创建（或更新）了一个信息文件。针对上面的zh_CN，应该是locale/zh_CN/LC_MESSAGES/django.po。</p><ul><li>编译信息文件<br>创建信息文件之后，每次对其做了修改，都需要将它重新编译成一种更有效率的形式，供 gettext 使用。可以使用django-admin.py compilemessages完成。这个工具作用于所有有效的 .po 文件，创建优化过的二进制 .mo 文件供 gettext 使用。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">django-admin.py compilemessages</div></pre></td></tr></table></figure></li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p>略</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>我们这里只是简单的总结了Django中翻译的一般用法，其中还有许多细节，包括 gettext() 的字符串可以接受占位符、在模板中使用翻译等等细节，使用中可以继续深入了解</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;一个大型网站的构建中，国际化是一个不可或缺的部分，它可以提供对不同语言、时区的支持。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;国际化：是指为了该软件在任何
      
    
    </summary>
    
    
      <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>ES6介绍之Arrow-functions</title>
    <link href="http://yoursite.com/2017/07/28/ES6%E4%BB%8B%E7%BB%8D%E4%B9%8BArrow-functions/"/>
    <id>http://yoursite.com/2017/07/28/ES6介绍之Arrow-functions/</id>
    <published>2017-07-27T20:51:15.000Z</published>
    <updated>2018-03-12T17:48:46.927Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Arraw function expression 比function有更简介的语法，它不绑定自己的this,arguments,super,new.target，最适合用作非方法的函数，不能够用做构造函数。接下来介绍一些特性。</p><h2 id="更简洁的语法"><a href="#更简洁的语法" class="headerlink" title="更简洁的语法"></a>更简洁的语法</h2><ol><li>当arrow function只有一个参数的时候可以不写包裹参数括号。</li><li>不需要明确返回return。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> materials = [</div><div class="line">  <span class="string">'Hydrogen'</span>,</div><div class="line">  <span class="string">'Helium'</span>,</div><div class="line">  <span class="string">'Lithium'</span>,</div><div class="line">  <span class="string">'Beryllium'</span></div><div class="line">];</div><div class="line"></div><div class="line">materials.map(<span class="function"><span class="params">material</span> =&gt;</span> material.length); <span class="comment">// [8, 6, 7, 9]</span></div></pre></td></tr></table></figure><h3 id="不绑定this"><a href="#不绑定this" class="headerlink" title="不绑定this"></a>不绑定this</h3><p>先看一个绑定this的例子:<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line">  setInterval(<span class="function"><span class="keyword">function</span> <span class="title">growUp</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.age++;</div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure></p><p>p.age结果是0。growUp()函数调用后会搜索this，setInterval中没有this.age，那么this指向全局对象，默认为0。</p><p>arrow function的this会使用上下文中包含arrow function的外部作用域的this。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.age = <span class="number">0</span>;</div><div class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">this</span>.age++;</div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>p.age结果每隔一秒会增长一位。</p><p>使用call或者apply调用arrow function的时候，绑定的this被忽略。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> adder = &#123;</div><div class="line">  <span class="attr">base</span>: <span class="number">1</span>,</div><div class="line"></div><div class="line">  <span class="attr">add</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</div><div class="line">    <span class="keyword">return</span> f(a);</div><div class="line">  &#125;,</div><div class="line"></div><div class="line">  <span class="attr">addThruCall</span>: <span class="function"><span class="keyword">function</span>(<span class="params">a</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v + <span class="keyword">this</span>.base;</div><div class="line">    <span class="keyword">var</span> b = &#123;</div><div class="line">      <span class="attr">base</span>: <span class="number">2</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> f.call(b, a);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(adder.add(<span class="number">1</span>));         <span class="comment">// This would log to 2</span></div><div class="line"><span class="built_in">console</span>.log(adder.addThruCall(<span class="number">1</span>)); <span class="comment">// This would log to 2 still</span></div></pre></td></tr></table></figure></p><h3 id="不绑定arguments"><a href="#不绑定arguments" class="headerlink" title="不绑定arguments"></a>不绑定arguments</h3><p>如果外部执行环境中有arguments对象，那么在arrow function中访问arguments对象的时候会是外部环境的arguments对象。如果外部执行环境中没有arguments对象，那么在arrow funciton中访问arguments对象的时候会报错。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> <span class="built_in">arguments</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> arr = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>];</div><div class="line">arr(); <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = <span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">arguments</span>[<span class="number">0</span>]</div><div class="line">foo(); <span class="comment">// arguments is not defined</span></div></pre></td></tr></table></figure></p><p>如果想在arrow function中使用类似arguments的对象，那么可以使用ES6中的spead operator。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">n</span>) </span>&#123; </div><div class="line">  <span class="keyword">var</span> f = <span class="function">(<span class="params">...args</span>) =&gt;</span> args[<span class="number">0</span>] + n; </div><div class="line">  <span class="keyword">return</span> f(<span class="number">10</span>); </div><div class="line">&#125;</div><div class="line"></div><div class="line">foo(<span class="number">1</span>); <span class="comment">// 11</span></div></pre></td></tr></table></figure></p><h3 id="用作操作符"><a href="#用作操作符" class="headerlink" title="用作操作符"></a>用作操作符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var Foo = () =&gt; &#123;&#125;;</div><div class="line">var foo = new Foo(); // TypeError: Foo is not a constructor</div></pre></td></tr></table></figure><p>不能用作构造函数。</p><h3 id="用作prototype-property"><a href="#用作prototype-property" class="headerlink" title="用作prototype property"></a>用作prototype property</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var Foo = () =&gt; &#123;&#125;;</div><div class="line">console.log(Foo.prototype); // undefined</div></pre></td></tr></table></figure><p>没有prototype property。</p><h3 id="返回字面对象"><a href="#返回字面对象" class="headerlink" title="返回字面对象"></a>返回字面对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">返回字面对象时使用简明语法不会工作。</div><div class="line">var func = () =&gt; &#123; foo: 1 &#125;;               </div><div class="line">// Calling func() returns undefined!</div><div class="line"></div><div class="line">var func = () =&gt; &#123; foo: function() &#123;&#125; &#125;;   </div><div class="line">// SyntaxError: function statement requires a name</div><div class="line"></div><div class="line">这是因为在(&#123;&#125;)中的代码会被解析为连续的语句(foo会被解析为标签，而不是key)。</div><div class="line">记住要在字面对象外面加一层括号。</div><div class="line">var func = () =&gt; (&#123;foo: 1&#125;);</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;Arraw function expression 比function有更简介的语法，它不绑定自己的this,arguments,super
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Git操作小记</title>
    <link href="http://yoursite.com/2017/06/16/Git%E6%93%8D%E4%BD%9C%E5%B0%8F%E8%AE%B0/"/>
    <id>http://yoursite.com/2017/06/16/Git操作小记/</id>
    <published>2017-06-16T07:15:06.000Z</published>
    <updated>2017-10-21T22:38:47.298Z</updated>
    
    <content type="html"><![CDATA[<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">克隆远程服务器端的代码到本地代码仓库</div><div class="line">git clone [url]</div><div class="line">将本地代码仓库添加到远程仓库</div><div class="line">git remote add [shortname] [url]</div></pre></td></tr></table></figure><h2 id="更新提交"><a href="#更新提交" class="headerlink" title="更新提交"></a>更新提交</h2><p>文件状态: 已跟踪、未跟踪，已跟踪指纳入版本控制的管理的文件，该种文件已经纳入缓冲区，它可又有两种状态为未修改和已修改。而未跟踪文件指未纳入缓冲区的文件。</p><p>![git_state][images/git_state.png]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">跟踪某个文件</div><div class="line">git add &lt;filename&gt;</div><div class="line">.选项会把已修改的和添加的文件放入缓冲区不包括被删除文件</div><div class="line">git add .</div><div class="line">-u会把更新的文件和被删除文件放入缓冲去区</div><div class="line">git add .-u</div><div class="line">-A提交所有变化</div><div class="line">git add -A</div><div class="line">提交更新并加上提交注释</div><div class="line">git commit -m</div><div class="line">修改最后一次提交,比如发现漏掉了几个文件没有加，或者提交信息写错了</div><div class="line">git commit --amend</div></pre></td></tr></table></figure></p><p>当分支与master冲突的文件是.mo二进制文件时，此时我们没法手动rebase，那么我们可以使用如下操作<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git rebase master</div><div class="line">git add -u</div><div class="line">git rebase --continue</div></pre></td></tr></table></figure></p><p>和我们正常的rebase是一样的。</p><h2 id="显示信息"><a href="#显示信息" class="headerlink" title="显示信息"></a>显示信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">确定文件状态</div><div class="line">git status</div><div class="line">查看提交历史，会显示commit id等信息，对于版本回退会有很大帮助，退出按q键</div><div class="line">git log</div><div class="line">--graph 选项可以以一种便于查看的方式显示提交信息</div><div class="line">git log --graph</div><div class="line">查看具体修改了什么地方</div><div class="line">git diff</div></pre></td></tr></table></figure><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">创建并切换分支</div><div class="line">git checkout -b &lt;branchname&gt;</div><div class="line">合并分支一般在master上合并其他分支</div><div class="line">git merge &lt;branchname&gt;</div><div class="line">删除分支</div><div class="line">git branch -d &lt;branchname&gt;</div><div class="line">删除远程分支</div><div class="line">git push [远程名] :&lt;branchname&gt;</div><div class="line">衍合</div><div class="line">git rebase &lt;target branchname&gt;</div><div class="line">等价于（master为target branchname）</div><div class="line">git rebase master server</div></pre></td></tr></table></figure><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">回退到某次提交（即HEAD指针回到某个状态,之前的commit都没有变化）</div><div class="line">git reset &lt;commit id&gt;</div><div class="line">或者</div><div class="line">git reset --hard &lt;commit id前6位&gt;</div><div class="line">回退到某次提交，相当于一次新的commit</div><div class="line">git revert &lt;commit id&gt;</div></pre></td></tr></table></figure><h2 id="保持分支同步更新"><a href="#保持分支同步更新" class="headerlink" title="保持分支同步更新"></a>保持分支同步更新</h2><p>克隆操作会自动使用默认的master 和origin 名字。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">到远程仓库中拉取所有你本地仓库中还没有的数据,但不会自动合并</div><div class="line">git fetch [remote-name]</div><div class="line">到远程仓库中拉取所有你本地仓库中还没有的数据,并自动合并</div><div class="line">git pull</div><div class="line">推送数据到远程仓库</div><div class="line">git push [remote-name] [branch-name]</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;远程仓库&quot;&gt;&lt;a href=&quot;#远程仓库&quot; class=&quot;headerlink&quot; title=&quot;远程仓库&quot;&gt;&lt;/a&gt;远程仓库&lt;/h2&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="Git" scheme="http://yoursite.com/tags/Git/"/>
    
  </entry>
  
</feed>
