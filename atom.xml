<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lucky4</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-09-02T18:18:07.039Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Lucky4</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉平衡树——B-树，B+树与MySQL数据库B-Tree索引</title>
    <link href="http://yoursite.com/2018/09/02/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E2%80%94%E2%80%94B-%E6%A0%91%EF%BC%8CB-%E6%A0%91%E4%B8%8EMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <id>http://yoursite.com/2018/09/02/二叉平衡树——B-树，B-树与MySQL数据库索引/</id>
    <published>2018-09-01T22:44:45.000Z</published>
    <updated>2018-09-02T18:18:07.039Z</updated>
    
    <content type="html"><![CDATA[<h2 id="二叉平衡树"><a href="#二叉平衡树" class="headerlink" title="二叉平衡树"></a>二叉平衡树</h2><blockquote><p>AVL树是带有平衡条件的二叉查找树，该平衡条件是每个节点的左子树和右子树的高度最多差1的二叉查找树。（空树的高度定义为-1。）</p></blockquote><p>在该树上的所有操作的时间复杂度为O(logN)。插入过程中涉及到了单旋转和双旋转，具体实现<a href="https://github.com/Lucky4/Data-Structures-and-Algorithm-Analysis-in-C/blob/master/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.cpp" target="_blank" rel="external">请看</a>。<br><br></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B-树"></a>B-树</h2><p>阶为M的B-树是一棵有下列结构特性的树：</p><ul><li>树的根的儿子数在2和M之间。</li><li>除根外，所有非树叶节点的儿子树在M/2（向上取整）和M之间。</li><li>所有的树叶都在相同的深度上。</li><li>每个节点存放至少2个，至多M个关键字。</li></ul><p><br></p><p>插入的过程中需要自动调层，下面是3阶B-树的完整插入过程。<br><br>插入18，<br><br>插入1，<br><br>插入19，<br><br><br>插入28，<br><br><br><br></p><p>B-树深度最多是logM/2(N)向上取整，Insert和Delete操作复杂度为O(MlogM(N))，Find操作复杂度为O(logN)。<br><br></p><h2 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+树"></a>B+树</h2><p>B+树与B-树向比，增加了以下特性：</p><ul><li>非叶子结点的子树指针与关键字个数相同。每个关键字不保存数据，只用来索引，所有数据都保存在叶子节点。</li><li>为所有叶子结点增加一个链指针。</li><li>所有关键字都在叶子结点出现。<br><br></li></ul><h2 id="MySQL数据库B-Tree索引"><a href="#MySQL数据库B-Tree索引" class="headerlink" title="MySQL数据库B-Tree索引"></a>MySQL数据库B-Tree索引</h2><p><a href="https://blog.csdn.net/no_endless/article/details/77073549" target="_blank" rel="external">MySQL 聚集索引/非聚集索引简述</a><br><a href="https://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="external">MyISAM和InnoDB的索引实现</a><br><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/aqzwss/article/details/53074186" target="_blank" rel="external">参考1</a><br><a href="https://blog.csdn.net/no_endless/article/details/77073549" target="_blank" rel="external">参考2</a><br><a href="https://www.cnblogs.com/zlcxbb/p/5757245.html" target="_blank" rel="external">参考3</a><br>参考4《数据结构与算法分析：C语言描述》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;二叉平衡树&quot;&gt;&lt;a href=&quot;#二叉平衡树&quot; class=&quot;headerlink&quot; title=&quot;二叉平衡树&quot;&gt;&lt;/a&gt;二叉平衡树&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;AVL树是带有平衡条件的二叉查找树，该平衡条件是每个节点的左子树和右子树的高度最多差1的二
      
    
    </summary>
    
    
      <category term="二叉平衡树" scheme="http://yoursite.com/tags/%E4%BA%8C%E5%8F%89%E5%B9%B3%E8%A1%A1%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——Dict对象</title>
    <link href="http://yoursite.com/2018/08/28/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94Dict%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/08/28/Python源码剖析——Dict对象/</id>
    <published>2018-08-28T02:02:32.000Z</published>
    <updated>2018-08-28T22:04:07.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>现代的编程语言都在语言级或标准库中提供某种<code>关联式的容器</code>，容器中的元素通常是以(key,value)的形式存在的。</p><p>关联式容器总会极大地关注键的搜索效率，其实现都会基于良好的数据结构，如C++中的map的实现基于红黑树，搜索时间复杂度为O(logN)。</p><p>Python中的关联容器<code>PyDictObject</code>即dict是基于<code>散列表</code>实现的。Dict对搜索的效率要求很高，因为Python本身的实现中dict被大量的使用，如Python字节码的运行环境，其中存放变量名和变量值，通过查找变量名获得变量值。因此dict的实现没有采用平衡二叉树，而是采用了散列表，最优情况下散列表的搜索复杂度为O(1)。<br><br></p><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>Python在处理哈希冲突的时候采用<code>开放地址法</code>，在删除散列表中的元素的时候，不能进行真正的删除，因为会导致冲突探测链的探测过早的结束，所以Python采用一种<code>伪删除</code>的方式。<br><br></p><h2 id="PyDictObject"><a href="#PyDictObject" class="headerlink" title="PyDictObject"></a>PyDictObject</h2><h4 id="关联容器的entry"><a href="#关联容器的entry" class="headerlink" title="关联容器的entry"></a>关联容器的entry</h4><p>关联容器中的一个(key,value)元素称为一个<code>entry</code>或slot。Python中，一个entry定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dictobject.h</span></div><div class="line"></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></div><div class="line">    <span class="comment">/* Cached hash code of me_key.  Note that hash codes are C longs.</span></div><div class="line">     * We have to use Py_ssize_t instead because dict_popitem() abuses</div><div class="line">     * me_hash to hold a search finger.</div><div class="line">     */</div><div class="line">    Py_ssize_t me_hash;</div><div class="line">    PyObject *me_key;</div><div class="line">    PyObject *me_value;</div><div class="line">&#125; PyDictEntry;</div></pre></td></tr></table></figure><p>PyDictObject存放的是PyObject*，可以存放任何Python对象。<code>me_hash</code>域存储的是<code>me_key</code>的散列值。</p><p>PyDictObject中entry可以在3种状态间转换：</p><ul><li><code>Unused态</code>：该entry从现在到之前都没有存储过(key,value)对。</li><li><code>Active态</code>：存储了一个(key,value)对entry便传化为Active态。</li><li><code>Dummy态</code> ： entry中的(key,value)对被“伪删除”后，进入Dummy态。</li></ul><img src="/2018/08/28/Python源码剖析——Dict对象/pic1.jpg" alt="entry三种状态" title="entry三种状态"><p><br></p><h4 id="关联容器的实现"><a href="#关联容器的实现" class="headerlink" title="关联容器的实现"></a>关联容器的实现</h4><p>关联容器PyDictObject是一大堆entry的集合，集合结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// dictobject.j</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">dictobject</span> &#123;</span></div><div class="line">    PyObject_HEAD</div><div class="line">    Py_ssize_t ma_fill;  <span class="comment">/* # Active + # Dummy */</span></div><div class="line">    Py_ssize_t ma_used;  <span class="comment">/* # Active */</span></div><div class="line"></div><div class="line">    <span class="comment">/* The table contains ma_mask + 1 slots, and that's a power of 2.</span></div><div class="line">     * We store the mask instead of the size because the mask is more</div><div class="line">     * frequently needed.</div><div class="line">     */</div><div class="line">    Py_ssize_t ma_mask;</div><div class="line"></div><div class="line">    <span class="comment">/* ma_table points to ma_smalltable for small tables, else to</span></div><div class="line">     * additional malloc'ed memory.  ma_table is never NULL!  This rule</div><div class="line">     * saves repeated runtime null-tests in the workhorse getitem and</div><div class="line">     * setitem calls.</div><div class="line">     */</div><div class="line">    PyDictEntry *ma_table;</div><div class="line">    PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, <span class="keyword">long</span> hash);</div><div class="line">    PyDictEntry ma_smalltable[PyDict_MINSIZE];</div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p>当PyDictObject中的entry数量超过<code>8</code>个时，Python会认为这是一个大dict了，将会申请额外内存空间，并将<code>ma_table</code>指向这块空间。</p><img src="/2018/08/28/Python源码剖析——Dict对象/pic2.jpg" alt="entry三种状态" title="entry三种状态"><p><br></p><h4 id="PyDictObject中元素搜索"><a href="#PyDictObject中元素搜索" class="headerlink" title="PyDictObject中元素搜索"></a>PyDictObject中元素搜索</h4><p>PyDictObject提供两种搜索策略，<code>lookdict</code>和<code>lookdict_string</code>，Python默认搜索方式为<code>lookdict_string<code>。</code></code></p><p>Python获取冲突链上的第一个entry的过程采用，将hash值（我认为是元素序号）与entry的数量做一个与操作，结果自然会落在entry的数量之下。</p><p><code>freeslot</code>正是用来指向探测序列中第一个处于Dummy态的entry，如果搜索失败，freeslot会提供一个处于Dummy态的entry。<br><br></p><p>根据hash值获得的冲突探测链上<code>第一个entry</code>与待查找的元素的比较：</p><ol><li>根据hash值获得entry的索引，是冲突探测链上的第一个entry的索引。</li><li>在两种情况下搜索结束：<ul><li>entry处于Unused态，表明冲突探测链搜索完成，搜索失败；</li><li>ep-&gt;me_key == key，表明entry的key与待搜索的key匹配，搜索成功。</li></ul></li><li>若当前entry处于Dummy态，这是freeslot。</li><li>检查Active态entry中的key与待查找的key是否“值相同”，若成立，搜索成功。</li></ol><p><code>遍历探测链</code>时发生的lookdict所进行的操作：</p><ol><li>根据Python所采用的探测函数，获得探测链中的下一个待检查的entry。</li><li>检查到一个Unused态entry，表明搜索失败，这时有两种结果：<ul><li>如果freeslot不为空，则返回freeslot所指entry。</li><li>如果freeslot为空，则返回该Unused态entry。</li></ul></li><li>检查entry中的key与带查找的key是否符合“引用相同”规则。</li><li>检查entry中的key与待查找的key是否符合“值相同”规则。</li><li>遍历过程中，如果发现Dummy态entry，且freeslot未设置，则设置freeslot。<br><br></li></ol><h4 id="PyDictObject插入"><a href="#PyDictObject插入" class="headerlink" title="PyDictObject插入"></a>PyDictObject插入</h4><p>搜索成功，返回处于Active的entry，直接替换me_value。<br>搜索失败，返回Unused或Dummy的entry，完整设置me_key、me_hash和me_value。</p><p>如果table的装载率大于<code>2/3</code>时，后续的插入动作遭遇到冲突的可能性会非常大，在装载率大于或等于<code>2/3</code>时需要改变table的大小。<br><br></p><h4 id="PyDictObject的删除"><a href="#PyDictObject的删除" class="headerlink" title="PyDictObject的删除"></a>PyDictObject的删除</h4><p>先计算hash值，搜索相应的entry，删除entry维护的元素，将entry从Active态变换为Dummy态，调整PyDictObject对象中维护table使用情况的变量。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;现代的编程语言都在语言级或标准库中提供某种&lt;code&gt;关联式的容器&lt;/code&gt;，容器中的元素通常是以(key,value)的形式存在的。&lt;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>堆和栈的区别</title>
    <link href="http://yoursite.com/2018/08/21/%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://yoursite.com/2018/08/21/堆和栈的区别/</id>
    <published>2018-08-21T01:44:57.000Z</published>
    <updated>2018-08-26T19:55:24.200Z</updated>
    
    <content type="html"><![CDATA[<h2 id="内存分配中堆和栈的区别"><a href="#内存分配中堆和栈的区别" class="headerlink" title="内存分配中堆和栈的区别"></a>内存分配中堆和栈的区别</h2><p>管理方式：</p><ul><li>栈由编译器自动管理。</li><li>堆由程序员手工管理。</li></ul><p>空间大小：</p><ul><li>栈一般有1~2M。</li><li>32位操作系统堆可以达到4G。</li></ul><p>碎片问题：</p><ul><li>栈的先进后出的方式导致它不会产生碎片。</li><li>堆频繁的malloc/free会产生不连续的空间，造成碎片。</li></ul><p>生长方向不同：</p><ul><li>栈向下生长。</li><li>堆向上生长。</li></ul><p>分配效率：</p><ul><li>栈由于有就是那几底层支持，效率较高。</li><li>堆需要一定算法分配可用内存空间，效率较低。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;内存分配中堆和栈的区别&quot;&gt;&lt;a href=&quot;#内存分配中堆和栈的区别&quot; class=&quot;headerlink&quot; title=&quot;内存分配中堆和栈的区别&quot;&gt;&lt;/a&gt;内存分配中堆和栈的区别&lt;/h2&gt;&lt;p&gt;管理方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;栈由编译器自动管理。&lt;/li&gt;
      
    
    </summary>
    
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——Python内建对象</title>
    <link href="http://yoursite.com/2018/08/15/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94Python%E5%86%85%E5%BB%BA%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2018/08/15/Python源码剖析——Python内建对象/</id>
    <published>2018-08-14T23:18:29.000Z</published>
    <updated>2018-08-15T16:05:29.726Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>在Python的世界中，一切都是对象，包括面向对象中的“类”也是通过Python内的对象来实现的。</p></blockquote><h2 id="Python内的对象"><a href="#Python内的对象" class="headerlink" title="Python内的对象"></a>Python内的对象</h2><p>在Python中，对象就是C的结构体在堆上申请的一块内存。</p><ul><li>Python中所有的内建的类型对象(int, str等对象)都是被静态初始化的。</li><li>对象一旦创建, 内存大小就是不变的(变长的对象内部维护一个指向可变内存的指针)</li></ul><h3 id="对象的基石——PyObject"><a href="#对象的基石——PyObject" class="headerlink" title="对象的基石——PyObject"></a>对象的基石——PyObject</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;在Python的世界中，一切都是对象，包括面向对象中的“类”也是通过Python内的对象来实现的。&lt;/p&gt;
&lt;/b
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——垃圾回收机制</title>
    <link href="http://yoursite.com/2018/08/08/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/08/08/Python源码剖析——垃圾回收机制/</id>
    <published>2018-08-08T05:31:30.000Z</published>
    <updated>2018-08-28T22:03:23.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h4 id="内存管理架构"><a href="#内存管理架构" class="headerlink" title="内存管理架构"></a>内存管理架构</h4><p>在Python中，内存管理机制被抽象成一种层次似的结果。</p><ul><li><code>第0层</code>，是操作系统提供的内存管理接口，比如C运行时所提供的malloc和free接口。这一层由操作系统实现并管理。</li><li><code>第1层</code>，是Python基于第0层操作系统的内存管理接口包装而成的，因为虽然操作系统都提供了ANSI C标准所定义的内存管理接口，但是对于某些特殊的情况不同的操作系统有不同的行为。</li><li><code>第2层</code>，第一层所提供的内存管理接口其功能是有限的，加入要创建一个PyIntObject对象，还需要许多额外的工作，如设置对象的类型，初始化对象的引用计数值等。为了简化Python自身的开发，Python在比第一层更高的抽象层次上提供了第二层管理接口，主要提供了创建Python对象的接口。</li><li><code>第3层</code>，主要是对象缓冲池机制。<br><br></li></ul><h4 id="小块空间的内存池"><a href="#小块空间的内存池" class="headerlink" title="小块空间的内存池"></a>小块空间的内存池</h4><p>在Python中，许多时候申请的内存都是小块的内存，申请后很快又会被释放，它们不是为了创建对象，没有对象一级的内存池机制。意味着会大量执行malloc和free操作，影响Python的执行效率。</p><p>为了提高执行效率，Python引入一个<code>内存池机制</code>，管理小块内存的申请和释放。</p><p>Python默认小块内存与大块内存的分界点定在256个字节，也就是说，当申请的内存小于256字节时PyObject_Malloc会在内存池中申请内存；当申请内存大于256字节时PyObject_Malloc的行为蜕化为malloc的行为。<br><br></p><h2 id="垃圾收集机制"><a href="#垃圾收集机制" class="headerlink" title="垃圾收集机制"></a>垃圾收集机制</h2><p>在Python中，大多数对象的声明周期都是通过对象的<code>引用计数</code>来管理的。但循环引用这种状态不同通过引用计数来回收内存，需要配合另外两种垃圾收集技术，<code>标记——清除</code>和<code>分代收集</code>。<br><br></p><h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>当一个对象的引用被创建或者复制时，对象的引用计数加1；当一个对象的引用被销毁（退出作用域、被del删除）时，对象的引用计数减1。如果对象的引用计数为0，那么释放其所占用的内存。</p><p>引用计数有一个问题，就是可能会产生<code>循环引用</code>，看一段代码：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = []</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1.append(l2)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2.append(l1)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l1</div><div class="line">[[[...]]]</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>l2</div><div class="line">[[[...]]]</div></pre></td></tr></table></figure></p><p>要想回收l1的内存需要先将其引用计数置为0，其引用为l2即需要先释放l2的内存。同时，回收l2的内存需要先将其引用计数置为0，其引用为l1即需要先释放l1的内存，此时造成了循环引用的状态，这些对象所占用内存永远不会被回收。</p><p>Python 中的循环引用总是发发生在container对象之间，所谓container对象即是内部可持有对其他对象引用的对象，比如list、dict、class、instance等等。当Python垃圾回收机制运行时，只会去检查container对象。</p><p>为了解决循环引用这个问题Python引用了标记-清除和分代回收技术。<br><br></p><h4 id="标记——清除"><a href="#标记——清除" class="headerlink" title="标记——清除"></a>标记——清除</h4><p>其简要工作过程如下：</p><ol><li>寻找根对象（root object）的集合，<code>root object</code>即是一些全局引用和函数栈中的引用。这些引用所用的对象是不可被删除的。</li><li>从root object集合出发，沿着root object集合中的每一个引用，如果能到达某个对象A，则A称为<code>可达的</code>，可达的对象也不可删除。这个阶段就是垃圾检测阶段。</li><li>当垃圾检测阶段结束后，所有的对象分为了可达的和<code>不可达的</code>两部分，对所有不可达的对象占用的内存将被回收，这就是垃圾回收阶段。<br><br></li></ol><p>Python中的循环引用总是发生在<code>container</code>对象之间，所谓container对象即是内部可持有对其他对象的引用的对象，如list、dict、class、instance等。Python的垃圾收集机制运行时，只需要去检查这些container对象。</p><p>Python中使用链表来存储可收集对象。<br><br></p><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><p>将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合称为一个<code>“代”</code>，代的存活时间越长，就越可能不是垃圾，应该越少去收集。衡量存活时间的标准就是经过了几次垃圾收集动作。每一个“代”用链表实现。</p><img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc1.jpg" alt="分代清除" title="分代清除"><p><br></p><h4 id="Python中的标记——清除方法"><a href="#Python中的标记——清除方法" class="headerlink" title="Python中的标记——清除方法"></a>Python中的标记——清除方法</h4><p>一个垃圾回收的例子：<br><img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc2.jpg" alt="分代清除" title="分代清除"></p><ol><li>Python采用三代的分代收集机制，如收集第一代，会将比其“年轻”的所有代的内存链表整个连接到当前代链表之后，则会将比其年轻的第0代放在第1代之后。</li><li>寻找root object集合。通过<code>有效引用计数</code>方法将循环引用标记清除<img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc3.jpg" alt="分代清除" title="分代清除"></li><li>垃圾标记。获得不可达的链表。<img src="/2018/08/08/Python源码剖析——垃圾回收机制/gc4.jpg" alt="分代清除" title="分代清除"></li><li>垃圾回收。将不可达的链表中的对象销毁。<br><br></li></ol><h2 id="Python中的垃圾回收机制为什么使用链表数据结构？"><a href="#Python中的垃圾回收机制为什么使用链表数据结构？" class="headerlink" title="Python中的垃圾回收机制为什么使用链表数据结构？"></a>Python中的垃圾回收机制为什么使用链表数据结构？</h2><ul><li>垃圾回收的过程中必然要涉及到频繁的插入（分代回收，如第0代放在第1代之后）、删除（标记清除，删除不可达节点）的过程，使用双向链表等结构可以使插入、删除等操作时间复杂度达到为O(1)；相比于链表，如果使用树型的数据结构，那么插入和删除的时间复杂度会达到O(logN),同时由于树的父子间的复杂关系，在删除的时候会进行大量操作。</li><li>container对象的内存分布中有三部分，一块用于垃圾回收机制，一块是PyObject_HEAD和自身数据，Python使用双向链表结构将container对象连接起来。在标记的过程中，根据链表结构一对一的对关系，一次完全遍历和一次简答的遍历就可以完成标记任务；如果使用树型结构，由于树的性质，每个节点需要保存2个至多个子代信息，需要保存额外的信息，浪费资源。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;h4 id=&quot;内存管理架构&quot;&gt;&lt;a href=&quot;#内存管理架构&quot; class=&quot;headerlink&quot; title=&quot;内存管理架构&quot;&gt;&lt;/a&gt;内
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解析Python的lambda表达式</title>
    <link href="http://yoursite.com/2018/08/08/%E8%A7%A3%E6%9E%90Python%E7%9A%84lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/08/08/解析Python的lambda表达式/</id>
    <published>2018-08-08T01:23:16.000Z</published>
    <updated>2018-08-08T03:34:52.272Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是lambda表达式？"><a href="#什么是lambda表达式？" class="headerlink" title="什么是lambda表达式？"></a>什么是lambda表达式？</h2><p>lambda表达式也叫匿名函数，返回可调用的函数对象。</p><p>匿名函数本质上就是一个函数，它所抽象出来的东西是一组运算，可以配合其他高阶函数使用如map、reduce、filter。<br><br></p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>lambda表达式的定义体必须和声明放在同一行。<br><br></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><p>使用lambda可以省去定义函数的过程，减少了一个污染环境的函数名，让代码更加精简。</p><p>在非多次调用的函数的情况下，lambda表达式即用既得，提高性能<br><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.douban.com/note/311252412/" target="_blank" rel="external">https://www.douban.com/note/311252412/</a><br><a href="https://www.zhihu.com/question/20125256" target="_blank" rel="external">https://www.zhihu.com/question/20125256</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;什么是lambda表达式？&quot;&gt;&lt;a href=&quot;#什么是lambda表达式？&quot; class=&quot;headerlink&quot; title=&quot;什么是lambda表达式？&quot;&gt;&lt;/a&gt;什么是lambda表达式？&lt;/h2&gt;&lt;p&gt;lambda表达式也叫匿名函数，返回可调用的函数对象
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>数组与链表</title>
    <link href="http://yoursite.com/2018/08/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/08/03/数组与链表/</id>
    <published>2018-08-02T18:12:08.000Z</published>
    <updated>2018-08-08T00:03:35.629Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>数组与链表都属于数据结构中线性表结构。同一线性表中的元素必定具有相同特性，且相邻数据元素之间存在着一对一关系（前驱，后继）。</p></blockquote><p>我认为存在线性表这种数据结构的意义是，它可以以一定的顺序进行遍历，方便迭代所有的数据，且在查找的时候可以轻松的利用邻居元素一对一的关系，获取到某个数据。</p><p>动态查找表：不仅仅是顺序查找，动态查找表的特点是表结构本身在查找过程中动态生成,即对给定的关键字key，若表中存在其关键字等于key的记录，则查找成功返回，否则插入关键字等于key的记录。<br><br></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>C中的数组是一种将标量类型数据聚集成更大数据类型的方式。</p><h4 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h4><p>对于数据类型T和整数N，声明<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">T A[N]</div></pre></td></tr></table></figure></p><p>有两个效果。</p><ul><li>首先，在存储器中分配了L*N字节的连续区域（L是数据类型T的大小），我们用a来表示起始位置。</li><li>其次，引入标识符A，作为指向数组开头的指针，指针的值是a。数组元素i的地址为a+L*i。</li></ul><h4 id="动态分配的数组"><a href="#动态分配的数组" class="headerlink" title="动态分配的数组"></a>动态分配的数组</h4><p>在许多应用程序中，我们需要代码能够对动态分配的任意大小的数组进行操作。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * var_matrix;</div><div class="line"><span class="function">var matrix <span class="title">new_var_matrix</span><span class="params">(<span class="keyword">int</span> n)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">return</span> (var_matrix)<span class="built_in">calloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>), n * n)</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>注意：在C中，堆（一个可以用来存放数据结构的存储池）中的存储分配是用的库函数malloc或calloc。它们要求程度用free函数来释放已分配的空间。在Java中是由gc的进程自动完成的。<br><br></p><h2 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h2><p>C中的struct声明创建一个结构数据类型，将可能不同类型的对象聚合到一个对象中。</p><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rec</span> &#123;</span></div><div class="line">    <span class="keyword">int</span> i;</div><div class="line">    <span class="keyword">int</span> j;</div><div class="line">    <span class="keyword">int</span> a[<span class="number">3</span>];</div><div class="line">    <span class="keyword">int</span> *p;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这个结构包含四个域————两个整数、一个数组和一个指针。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="number">0</span>    <span class="number">4</span>    <span class="number">8</span>                <span class="number">20</span></div><div class="line">-----------------------------------</div><div class="line">|  i |  j | a[<span class="number">0</span>] a[<span class="number">1</span>] a[<span class="number">2</span>] |  p   |</div><div class="line">-----------------------------------</div></pre></td></tr></table></figure><p>指向结构的指针就是结构第一个字节的地址，为了访问结构中的域，编译器产生的代码要将结构的地址加上适当的偏移。<br><br></p><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表是由一系列不必在内存中相连的结构组成，每一个结构包含表元素和指向包含该元素后继的结构的指针。</p><p>链表在许多语言的内存管理、垃圾回收策略中有着广泛的应用，如Python的内存管理、标记-清除垃圾回收策略、分代收集策略。<br><br></p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><p>分配内存：</p><ul><li>数组：静态数组内存的分配是由栈完成的，它的内存的分配和释放都是有计算机自己处理。</li><li>链表：链表的内存的分配是由堆完成的，它的内存的分配和释放都是有程序员手动处理。</li></ul><p>内存中的状态：</p><ul><li>数组：在内存中是一段连续的区域。</li><li>链表：在内存中是非连续的。</li></ul><p>大小：</p><ul><li>数组：固定。</li><li>链表：不固定。</li></ul><p>操作：</p><ul><li>数组：查找O(1)，增加、删除O(n)。</li><li>链表：查找O(n)，增加、删除O(1)。<br><br></li></ul><h2 id="跳跃链表"><a href="#跳跃链表" class="headerlink" title="跳跃链表"></a>跳跃链表</h2><p><a href="https://lfkdsk.github.io/2017/09/11/quick-learn-skip-list/" target="_blank" rel="external">https://lfkdsk.github.io/2017/09/11/quick-learn-skip-list/</a><br><br></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>《数据结构——C语言版》严蔚敏<br>《数据机构与算法分析——C语言描述》韦斯<br>《深入理解计算机系统》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;数组与链表都属于数据结构中线性表结构。同一线性表中的元素必定具有相同特性，且相邻数据元素之间存在着一对一关系（前驱
      
    
    </summary>
    
    
      <category term="数组 链表" scheme="http://yoursite.com/tags/%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Python源码剖析——多线程机制</title>
    <link href="http://yoursite.com/2018/07/17/Python%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2018/07/17/Python源码剖析——多线程机制/</id>
    <published>2018-07-17T04:46:24.000Z</published>
    <updated>2018-08-27T17:54:51.983Z</updated>
    
    <content type="html"><![CDATA[<p>Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对虚拟机的使用。</p><h2 id="GIL与线程调度"><a href="#GIL与线程调度" class="headerlink" title="GIL与线程调度"></a>GIL与线程调度</h2><p>在一个线程拥有了GIL，获得解释器的访问权之后，其他线程必须等待它释放解释器的访问权。</p><p>Python的多线程在于拥有一套线程调度机制，默认执行100条指令后启动线程调度机制挂起线程，选择处于等待的下一个线程时，借用底层操作系统提供的线程调度机制决定下一个进入解释器的线程。<br><br></p><h2 id="Python中的Thread"><a href="#Python中的Thread" class="headerlink" title="Python中的Thread"></a>Python中的Thread</h2><p>Python提供两个多线程机制接口：</p><ul><li>thread</li><li>threading</li></ul><p>thread 模块提供方法：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//threadmodule.c</span></div><div class="line"><span class="keyword">static</span> PyMethodDef thread_methods[] = &#123;</div><div class="line">    &#123;<span class="string">"start_new_thread"</span>,        (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">    &#123;<span class="string">"start_new"</span>,               (PyCFunction)thread_PyThread_start_new_thread,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            start_new_doc&#125;,</div><div class="line">    &#123;<span class="string">"allocate_lock"</span>,           (PyCFunction)thread_PyThread_allocate_lock,</div><div class="line">     METH_NOARGS, allocate_doc&#125;,</div><div class="line">    &#123;<span class="string">"allocate"</span>,                (PyCFunction)thread_PyThread_allocate_lock,</div><div class="line">     METH_NOARGS, allocate_doc&#125;,</div><div class="line">    &#123;<span class="string">"exit_thread"</span>,             (PyCFunction)thread_PyThread_exit_thread,</div><div class="line">     METH_NOARGS, exit_doc&#125;,</div><div class="line">    &#123;<span class="string">"exit"</span>,                    (PyCFunction)thread_PyThread_exit_thread,</div><div class="line">     METH_NOARGS, exit_doc&#125;,</div><div class="line">    &#123;<span class="string">"interrupt_main"</span>,          (PyCFunction)thread_PyThread_interrupt_main,</div><div class="line">     METH_NOARGS, interrupt_doc&#125;,</div><div class="line">    &#123;<span class="string">"get_ident"</span>,               (PyCFunction)thread_get_ident,</div><div class="line">     METH_NOARGS, get_ident_doc&#125;,</div><div class="line">    &#123;<span class="string">"_count"</span>,                  (PyCFunction)thread__count,</div><div class="line">     METH_NOARGS, _count_doc&#125;,</div><div class="line">    &#123;<span class="string">"stack_size"</span>,              (PyCFunction)thread_stack_size,</div><div class="line">                            METH_VARARGS,</div><div class="line">                            stack_size_doc&#125;,</div><div class="line">    &#123;<span class="literal">NULL</span>,                      <span class="literal">NULL</span>&#125;           <span class="comment">/* sentinel */</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure></p><p><br></p><h2 id="Python线程创建"><a href="#Python线程创建" class="headerlink" title="Python线程创建"></a>Python线程创建</h2><h4 id="通过start-new-thread创建一个新线程。"><a href="#通过start-new-thread创建一个新线程。" class="headerlink" title="通过start_new_thread创建一个新线程。"></a>通过start_new_thread创建一个新线程。</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> PyObject *</span></div><div class="line"><span class="title">thread_PyThread_start_new_thread</span><span class="params">(PyObject *self, PyObject *fargs)</span></div><div class="line">&#123;</div><div class="line">    PyObject *func, *args, *keyw = <span class="literal">NULL</span>;</div><div class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">bootstate</span> *<span class="title">boot</span>;</span></div><div class="line">    <span class="keyword">long</span> ident;</div><div class="line">    <span class="keyword">if</span> (!PyArg_UnpackTuple(fargs, <span class="string">"start_new_thread"</span>, <span class="number">2</span>, <span class="number">3</span>,</div><div class="line">                           &amp;func, &amp;args, &amp;keyw))</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    <span class="keyword">if</span> (!PyCallable_Check(func)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"first arg must be callable"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!PyTuple_Check(args)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"2nd arg must be a tuple"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (keyw != <span class="literal">NULL</span> &amp;&amp; !PyDict_Check(keyw)) &#123;</div><div class="line">        PyErr_SetString(PyExc_TypeError,</div><div class="line">                        <span class="string">"optional 3rd arg must be a dictionary"</span>);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//1. 创建并初始化bootstate结构, 在boot中保存关于线程的一切信息, </span></div><div class="line">    boot = PyMem_NEW(struct bootstate, <span class="number">1</span>);</div><div class="line">    <span class="keyword">if</span> (boot == <span class="literal">NULL</span>)</div><div class="line">        <span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">    boot-&gt;interp = PyThreadState_GET()-&gt;interp;  <span class="comment">//保存PyInterpreterState对象</span></div><div class="line">    boot-&gt;func = func;</div><div class="line">    boot-&gt;args = args;</div><div class="line">    boot-&gt;keyw = keyw;</div><div class="line">    boot-&gt;tstate = _PyThreadState_Prealloc(boot-&gt;interp);</div><div class="line">    <span class="keyword">if</span> (boot-&gt;tstate == <span class="literal">NULL</span>) &#123;</div><div class="line">        PyMem_DEL(boot);</div><div class="line">        <span class="keyword">return</span> PyErr_NoMemory();</div><div class="line">    &#125;</div><div class="line">    Py_INCREF(func);</div><div class="line">    Py_INCREF(args);</div><div class="line">    Py_XINCREF(keyw);</div><div class="line">    <span class="comment">//2. 初始化多线程环境</span></div><div class="line">    PyEval_InitThreads(); <span class="comment">/* Start the interpreter's thread-awareness */</span></div><div class="line">    <span class="comment">//3. 创建操作系统原生线程</span></div><div class="line">    ident = PyThread_start_new_thread(t_bootstrap, (<span class="keyword">void</span>*) boot);</div><div class="line">    <span class="keyword">if</span> (ident == <span class="number">-1</span>) &#123;</div><div class="line">        PyErr_SetString(ThreadError, <span class="string">"can't start new thread"</span>);</div><div class="line">        Py_DECREF(func);</div><div class="line">        Py_DECREF(args);</div><div class="line">        Py_XDECREF(keyw);</div><div class="line">        PyThreadState_Clear(boot-&gt;tstate);</div><div class="line">        PyMem_DEL(boot);</div><div class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> PyInt_FromLong(ident);</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>在Python虚拟机启动时，多线程机制并没有被激活，它只支持单线程，调用thread.start_new_thread，明确指示Python虚拟机创建新的线程，Python就能意识到用户需要多线程的支持，Python虚拟机会自动建立多线程机制需要的数据机构、环境以及GIL。</li></ul><h4 id="建立多线程环境"><a href="#建立多线程环境" class="headerlink" title="建立多线程环境"></a>建立多线程环境</h4><p>多线程环境的建立，主要就是创建GIL。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//pythread.h</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">void</span> *PyThread_type_lock;</div><div class="line"></div><div class="line"><span class="comment">//ceval.c</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock interpreter_lock = <span class="number">0</span>; <span class="comment">/* This is the GIL */</span></div><div class="line"><span class="keyword">static</span> PyThread_type_lock pending_lock = <span class="number">0</span>; <span class="comment">/* for pending calls */</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">long</span> main_thread = <span class="number">0</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">void</span></span></div><div class="line"><span class="title">PyEval_InitThreads</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (interpreter_lock)</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    interpreter_lock = PyThread_allocate_lock(); <span class="comment">//创建GIL(PNRMUTEX aLock)thread_nt.h</span></div><div class="line">    PyThread_acquire_lock(interpreter_lock, <span class="number">1</span>);</div><div class="line">    main_thread = PyThread_get_thread_ident();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function">PyThread_type_lock</span></div><div class="line"><span class="title">PyThread_allocate_lock</span><span class="params">(<span class="keyword">void</span>)</span></div><div class="line">&#123;</div><div class="line">    PNRMUTEX aLock;</div><div class="line"></div><div class="line">    dprintf((<span class="string">"PyThread_allocate_lock called\n"</span>));</div><div class="line">    <span class="keyword">if</span> (!initialized)</div><div class="line">        PyThread_init_thread();</div><div class="line">    aLock = AllocNonRecursiveMutex() ;</div><div class="line">    dprintf((<span class="string">"%ld: PyThread_allocate_lock() -&gt; %p\n"</span>, PyThread_get_thread_ident(), aLock));</div><div class="line">    <span class="keyword">return</span> (PyThread_type_lock) aLock;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//thread_nt.c</span></div><div class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NRMUTEX</span> &#123;</span></div><div class="line">    LONG   owned ;</div><div class="line">    DWORD  thread_id ;</div><div class="line">    HANDLE hevent ; <span class="comment">//event内核对象</span></div><div class="line">&#125; NRMUTEX, *PNRMUTEX ;</div></pre></td></tr></table></figure></p><ul><li>在PyEval_InitThreads通过PyThread_allocate_lock成功地创建了GIL之后，当前线程就开始遵循Python的多线程机制的规则；调用任何Python C API之前，必须首先获得GIL。因此PyEval_InitThreads紧接着通过PyThread_acquire_lock尝试获得GIL。最后调用PyThead_get_thread_ident()，获得当前Python主线程id，并将其赋给main_thread。</li></ul><h4 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h4><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line">long</div><div class="line">PyThread_start_new_thread(void (*func)(void *), void *arg)</div><div class="line">&#123;</div><div class="line">    HANDLE hThread;</div><div class="line">    unsigned threadID;</div><div class="line">    callobj *obj;</div><div class="line"></div><div class="line">    dprintf(("%ld: PyThread_start_new_thread called\n",</div><div class="line">             PyThread_get_thread_ident()));</div><div class="line">    if (!initialized)</div><div class="line">        PyThread_init_thread();</div><div class="line"></div><div class="line">    obj = (callobj*)HeapAlloc(GetProcessHeap(), 0, sizeof(*obj));</div><div class="line">    if (!obj)</div><div class="line">        return -1;</div><div class="line">    obj-&gt;func = func;</div><div class="line">    obj-&gt;arg = arg;</div><div class="line">#if defined(MS_WINCE)</div><div class="line">    hThread = CreateThread(NULL,</div><div class="line">                           Py_SAFE_DOWNCAST(_pythread_stacksize, Py_ssize_t, SIZE_T),</div><div class="line">                           bootstrap, obj, 0, &amp;threadID);</div><div class="line">#else</div><div class="line">    hThread = (HANDLE)_beginthreadex(0,</div><div class="line">                      Py_SAFE_DOWNCAST(_pythread_stacksize,</div><div class="line">                                       Py_ssize_t, unsigned int),</div><div class="line">                      bootstrap, obj,</div><div class="line">                      0, &amp;threadID);</div><div class="line">#endif</div><div class="line">    if (hThread == 0) &#123;</div><div class="line">#if defined(MS_WINCE)</div><div class="line">        /* Save error in variable, to prevent PyThread_get_thread_ident</div><div class="line">           from clobbering it. */</div><div class="line">        unsigned e = GetLastError();</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread failed, win32 error code %u\n",</div><div class="line">                 PyThread_get_thread_ident(), e));</div><div class="line">#else</div><div class="line">        /* I've seen errno == EAGAIN here, which means "there are</div><div class="line">         * too many threads".</div><div class="line">         */</div><div class="line">        int e = errno;</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread failed, errno %d\n",</div><div class="line">                 PyThread_get_thread_ident(), e));</div><div class="line">#endif</div><div class="line">        threadID = (unsigned)-1;</div><div class="line">        HeapFree(GetProcessHeap(), 0, obj);</div><div class="line">    &#125;</div><div class="line">    else &#123;</div><div class="line">        dprintf(("%ld: PyThread_start_new_thread succeeded: %p\n",</div><div class="line">                 PyThread_get_thread_ident(), (void*)hThread));</div><div class="line">        CloseHandle(hThread);</div><div class="line">    &#125;</div><div class="line">    return (long) threadID;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>主线程为执行程序时操作系统创建，主线程调用PyThread_start_new_thread创建子线程（CreateThread）。Win32下thread的API：_beginThread完成线程创建，bootstrap调用子线程定义（如函数），_beginThreadz在子线程中发生，顺利返回后，主线程挂起，等待obj.done。</li><li>主线程调用用PyThread_start_new_thread需要返回子线程的线程id，这个id只有在子线程被激活后在子线程获取，一旦子线程设置obj-&gt;id，就会设法唤醒主线程。主线程获得id后继续执行之后的字节码，主线程掌握GIL，子线程进入等待GIL状态，等待线程调度。</li><li>子线程创建自身线程状态对象后, 通过_PyGILState_NotrThreadState将这个对象放入线程状态对象链表。当前活动的Python线程不一定是获得了GIL的线程，主线程和子线程都是win32原生线程，操作系统可能在主线程和子线程之间切换。当所有的线程都完成了初始化之后，操作系统线程调度和Python线程调度才会统一，Python线程调度迫使当前活动线程释放GIL，并通知所有等待GIL event内核对象的线程，触发操作系统线程调度。<br><br></li></ul><h2 id="Python线程调度"><a href="#Python线程调度" class="headerlink" title="Python线程调度"></a>Python线程调度</h2><h4 id="标准调度"><a href="#标准调度" class="headerlink" title="标准调度"></a>标准调度</h4><p>Python的线程之间切换由线程调度机制掌握，python线程调度机制内建在python解释器的核心PyEval_EvalFrameEx中。</p><p>主线程先获得GIL, 并执行PyEval_EvalFrameEx函数代码, 这是子线程在t_bootstrap中调用PyEval_AcquireThread, 通过调用PyThread_acquire_lock申请GIL, 但由于GIL被主线程调用, 子线程被挂起. 主线程不断执行字节码, _Py_Ticker不断减一, 当减到0, 将当前维护线程状态置NULL, 然后释放GIL,此时子线程被操作系统的线程调度唤醒, 从而进入PyEval_EvalFrameEx. 对于主线程虽然失去了GIL, 但是没被挂起, 所以可以被再次切换为活动线程, 再次申请GIL, 由于被子线程占有, 主线程将自身挂起.</p><h4 id="阻塞调度"><a href="#阻塞调度" class="headerlink" title="阻塞调度"></a>阻塞调度</h4><p>线程A通过某些操作(如等待输入), 将自身阻塞, python应将等待GIL的线程B唤醒。</p><h4 id="Python子线程的销毁"><a href="#Python子线程的销毁" class="headerlink" title="Python子线程的销毁"></a>Python子线程的销毁</h4><p>主线程销毁必须要销毁python的运行时环境, 子线程的销毁不需要进行这些动作，对线程状态对象中维护的东西进行引用计数的维护，随后Python释放GIL。</p><h4 id="Python线程的用户级互斥和同步"><a href="#Python线程的用户级互斥和同步" class="headerlink" title="Python线程的用户级互斥和同步"></a>Python线程的用户级互斥和同步</h4><p>Python的线程在GIL的控制之下，线程之间，对整个Python解释器，对Python提供的C API的访问，都是互斥的，这可以看作是Python内核级互斥机制。但这种互斥我们不能控制的，我们还需要另一种可控的互斥机制————用户级互斥。</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">//threadmodule.c</div><div class="line">/* Lock objects */</div><div class="line">typedef struct &#123;</div><div class="line">    PyObject_HEAD</div><div class="line">    PyThread_type_lock lock_lock;  //Event内核对象</div><div class="line">    PyObject *in_weakreflist;</div><div class="line">&#125; lockobject;</div><div class="line">static PyObject *</div><div class="line">thread_PyThread_allocate_lock(PyObject *self)</div><div class="line">&#123;</div><div class="line">    return (PyObject *) newlockobject();</div><div class="line">&#125;</div><div class="line">static lockobject *</div><div class="line">newlockobject(void)</div><div class="line">&#123;</div><div class="line">    lockobject *self;</div><div class="line">    self = PyObject_New(lockobject, &amp;Locktype);</div><div class="line">    if (self == NULL)</div><div class="line">        return NULL;</div><div class="line">    self-&gt;lock_lock = PyThread_allocate_lock();</div><div class="line">    self-&gt;in_weakreflist = NULL;</div><div class="line">    if (self-&gt;lock_lock == NULL) &#123;</div><div class="line">        Py_DECREF(self);</div><div class="line">        PyErr_SetString(ThreadError, "can't allocate lock");</div><div class="line">        return NULL;</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure><ul><li>对thread.allocate的调用仅仅通过newlockobject创建了一个lockobject对象，Python整个用户级线程同步机制就在这个对象基础上实现。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Python虚拟机使用一个全局解释器锁（Global Interpreter Lock，GIL）来互斥线程对虚拟机的使用。&lt;/p&gt;
&lt;h2 id=&quot;GIL与线程调度&quot;&gt;&lt;a href=&quot;#GIL与线程调度&quot; class=&quot;headerlink&quot; title=&quot;GIL与线程调
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>大疆创新2019届秋招前端笔试题</title>
    <link href="http://yoursite.com/2018/07/15/%E5%A4%A7%E7%96%86%E5%88%9B%E6%96%B02019%E5%B1%8A%E7%A7%8B%E6%8B%9B%E5%89%8D%E7%AB%AF%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/07/15/大疆创新2019届秋招前端笔试题/</id>
    <published>2018-07-15T02:34:51.000Z</published>
    <updated>2018-08-12T19:00:23.563Z</updated>
    
    <content type="html"><![CDATA[<p>一、选择题</p><ol><li><p>以下描述不正确的是？<br>A. GET请求不可以携带body<br>B. cache-control: no-cache表示浏览器不存储资源内容<br>C. componentWillReceiveProps在componentShouldUpdate之后执行<br>D. vue的双向绑定对数组不生效<br>解析：ABC。<br>对A，知识点主要是GET方法和POST方法的区别，GET方法可以携带body，不同的库函数和浏览器对其支持不同，一般不使用，参考链接（<a href="https://www.zhihu.com/question/28586791）。" target="_blank" rel="external">https://www.zhihu.com/question/28586791）。</a><br>对B，知识点为HTTP缓存，参考链接（<a href="https://segmentfault.com/a/1190000010775131）。" target="_blank" rel="external">https://segmentfault.com/a/1190000010775131）。</a><br><br></p></li><li><p>以下哪种情况会产生死锁？<br>A. 竞争不可抢占性资源引起死锁<br>B. 进程产生死循环<br>C. 竞争可消耗资源引起死锁<br>D. 进程推进顺序不当引起死锁<br>解析：ACD。<br>死锁：多个进程在运行过程中因竞争资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。<br>产生死锁的原因归结为两点：</p></li></ol><ul><li>竞争资源，指的是不可剥夺性资源和临时性资源。</li><li>进程的推进顺序非法。</li></ul><p>死锁的必要条件：</p><ul><li>互斥：进程对所分配到的资源具有排他性使用，即在一段时间内某资源只由一个进程占用。</li><li>请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又已被其他进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。</li><li>不剥夺条件：指进程已获得资源，在未使用完之前，不能被剥夺只能使用完自己释放。</li><li>环路等待：发生死锁时，必然存在一个进程——资源环形链。<br>死循环，如while True，不会引起死锁。<br><br></li></ul><ol><li><p>异步任务有哪些？<br>A. setTimeout<br>B. setInterval<br>C. Promise.resolve<br>D. localStorage.setItem<br>解析：ABC<br>localStorage.setItem用于本地存储<br><br></p></li><li><p>html5语义化的作用有？<br>A. 让页面内容结构化，便于浏览器搜索引擎解析（SEO）<br>B. 保证页面在无样式时也是容易阅读的<br>C. 用正确的标签做正确的事<br>D. 便于维护理解<br>解析：ABD<br><br></p></li><li><p>下面正则表达式不可以匹配www.dji.com的是？<br>A. ^\w+.\w+-\w+.\w+$<br>B. [w]{0,3}.[a-z-]<em>.[a-z]+<br>C. [c-w.]{3,10}[.][c-w.][.][a]<br>D. ^\w.</em>com$<br>解析：ACD<br><br></p></li><li><p>Math.round(-7.5),Math.round(-7.6)的结果分别是？<br>A. -7,-7<br>B. -7,-8<br>C. -8,-8<br>D. -7,-9<br>解析：B,四舍五入。<br><br></p></li><li><p>用二分法查找长度为20的、排好序的线性表，查找不成功时，最多需要比较多少次？<br>A. 3<br>B. 4<br>C. 5<br>D. 6<br>解析：C,（向上取整）log|<em>20</em>| + 1<br><br></p></li><li><p>[1<2<3, 3<2<1]?="" a.="" [false,true]="" b.="" [false,false]="" c.="" [true,true]="" d.="" [true,false]="" 解析：c,="" <br=""></2<3,></p></li><li><p>2==[[[2]]]的答案是？<br>A. 1<br>B. error<br>C. undefined<br>D. true<br>解析：D,<br><br></p></li><li><p>在浏览器控制台，执行以下代码，运行的结果分别是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="number">1</span>,</div><div class="line">  <span class="attr">b</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">this</span>.name++;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">a.b() <span class="comment">// 2</span></div><div class="line">c=a.b</div><div class="line">c() <span class="comment">// '1'</span></div></pre></td></tr></table></figure></li></ol><p><br></p><ol><li><p>因为浏览器的限制，目前浏览器端html5及js还不能实现的功能是（以60版本chrome为基准）？<br>A. 离线消息推送<br>B. 读写本地文件<br>C. 绘制webgl<br>D. 将视频呢用canvas<em>x0008</em>逐帧绘制<br>解析：A<br><br></p></li><li><p>console.log(1+-+++-+1)答案是：<br>A. 2<br>B. 1<br>C. 0<br>D. error<br>解析：D<br><br></p></li><li><p>-8的二进制反码表示为？<br>A. 01111000<br>B. 11110111<br>C. 11111000<br>D. 11111001<br>解析：C<br><br></p></li><li><p>int l=2;int x=(l++) + (l++) + (l++);执行结束后，x的值是？<br>A. 6<br>B. 7<br>C. 8<br>D. 9<br>解析：D。<a href="https://www.zhihu.com/question/19811087" target="_blank" rel="external">https://www.zhihu.com/question/19811087</a><br><br></p></li></ol><p>二、问答题</p><ol><li>手写快速排序算法？<figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">QSort</span><span class="params">(A, left, right)</span>:</span></div><div class="line">    <span class="keyword">if</span> left &lt; right:</div><div class="line">        pivot = Median(A, left, right)</div><div class="line">        i = left</div><div class="line">        j = right - <span class="number">1</span></div><div class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</div><div class="line">            <span class="keyword">while</span> A[i] &lt; pivot:</div><div class="line">                i += <span class="number">1</span></div><div class="line">            <span class="keyword">while</span> A[j] &gt; pivot:</div><div class="line">                j -= <span class="number">1</span></div><div class="line">            <span class="keyword">if</span> i &lt; j:</div><div class="line">                swap(A[i], A[j])</div><div class="line">            <span class="keyword">else</span>:</div><div class="line">                <span class="keyword">break</span></div><div class="line">        swap(A[i], A[right])</div><div class="line">        QSort(A, left, i - <span class="number">1</span>)]</div><div class="line">        QSort(S, i + <span class="number">1</span>, right)</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">Median</span><span class="params">(A, left, right)</span>:</span></div><div class="line">    center = (left + right) / <span class="number">2</span></div><div class="line"></div><div class="line">    <span class="keyword">if</span> A[left] &gt; A[right]:</div><div class="line">        swap(A[left], A[right])</div><div class="line">    <span class="keyword">if</span> A[left] &gt; A[center]:</div><div class="line">        swap(A[left], A[center])</div><div class="line">    <span class="keyword">if</span> A[center] &gt; A[right]:</div><div class="line">        swap(A[center], A[right])</div><div class="line">    </div><div class="line">    swap(A[center], A[right])</div><div class="line">    <span class="keyword">return</span> A[right]</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">swap</span><span class="params">(a, b)</span>:</span></div><div class="line">    <span class="string">'''</span></div><div class="line">    我们假设该swap交换函数的参数是引用类型的，</div><div class="line">    否则由于作用域问题交换例程是无效的。</div><div class="line">    '''</div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure></li></ol><p><br></p><ol><li><p>如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为12,000,000.11？<br><br></p></li><li><p>链表与数组的区别？<br><a href="https://lucky4.github.io/2018/08/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/" target="_blank" rel="external">https://lucky4.github.io/2018/08/03/%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/</a><br><br></p></li><li><p>进程间的通信方式有哪些？<br>进程通信，是指进程之间的信息交换。进程间的同步和互斥属于低级通信；高级通信，指用户可直接利用操作系统提供的一组通信命令高效地传送大量数据的一种通信方式。相比低级通信，效率高，对用户透明，减少通信程序编制的复杂性。高级通信的几种方式：<br>##<strong>管道（pipe）</strong>：指用于连接一个读进程和写进程以实现他们之间通信的一个共享文件。管道的特点是：只支持半双工通信（单向传输），只能在父子进程中使用。<br>##<strong>命名管道（FIFO）</strong> ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。<br>##<strong>消息队列（message queue）</strong>：消息队列是由消息组成的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。相比于 FIFO，消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。<br>##<strong>信号量</strong>：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。<br>##<strong>共享内存</strong>：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号两，配合使用，来实现进程间的同步和通信。<br>##<strong>套接字</strong>：与其它通信机制不同的是，它可用于不同机器间的进程通信。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、选择题&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;以下描述不正确的是？&lt;br&gt;A. GET请求不可以携带body&lt;br&gt;B. cache-control: no-cache表示浏览器不存储资源内容&lt;br&gt;C. componentWillReceiveProps在component
      
    
    </summary>
    
    
      <category term="笔试" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Python内置函数</title>
    <link href="http://yoursite.com/2018/06/03/Python%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/06/03/Python内置函数/</id>
    <published>2018-06-02T17:45:51.000Z</published>
    <updated>2018-08-19T04:40:37.711Z</updated>
    
    <content type="html"><![CDATA[<h2 id="工具函数"><a href="#工具函数" class="headerlink" title="工具函数"></a>工具函数</h2><p>一些常用的函数<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">max()</div><div class="line">min()</div><div class="line">int()</div><div class="line">str()</div><div class="line">len()</div><div class="line">pow(x, y)                <span class="comment"># x的y次幂</span></div><div class="line">bin()                    <span class="comment"># 二进制表示</span></div><div class="line">range(start, end, step)</div><div class="line">xrange(start, end, step) <span class="comment"># 与range函数的区别就是，该函数是一个一个生成值的。</span></div></pre></td></tr></table></figure></p><p><br></p><p>要学会利用range函数生成倒序的序列<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>, <span class="number">-1</span>, <span class="number">-1</span>):</div><div class="line">    <span class="keyword">print</span> i <span class="comment"># 5, 4, 3, 2, 1, 0</span></div></pre></td></tr></table></figure></p><p><br></p><p>生成二维数组<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">array = [[<span class="number">0</span>] * col <span class="keyword">for</span> i <span class="keyword">in</span> range(row)]</div></pre></td></tr></table></figure></p><p>不要使用列表乘法的方式如：[[0] <em> col] </em> row因为它只是引用了对方的地址。<br><br></p><h2 id="迭代工具"><a href="#迭代工具" class="headerlink" title="迭代工具"></a>迭代工具</h2><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">filter(function, iterable)</div><div class="line">map(function, iterable)</div><div class="line">reduce(function, iterable)</div></pre></td></tr></table></figure><p><br></p><h2 id="内置模块"><a href="#内置模块" class="headerlink" title="内置模块"></a>内置模块</h2><h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;&gt; <span class="keyword">from</span> collections <span class="keyword">import</span> deque</div><div class="line">&gt;&gt;&gt;&gt; help(deque)</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">deque</span><span class="params">(__builtin__.object)</span>:</span></div><div class="line">    __getitem__(...)</div><div class="line"></div><div class="line">    __setitem__(...)</div><div class="line"></div><div class="line">    __len__(...)</div><div class="line"></div><div class="line">    append(...) <span class="comment"># 入队</span></div><div class="line"></div><div class="line">    appendleft(...) <span class="comment"># 左侧入队</span></div><div class="line"></div><div class="line">    extend(...) <span class="comment"># 扩展队列元素</span></div><div class="line"></div><div class="line">    extendleft(...) <span class="comment"># 左侧扩展队列元素</span></div><div class="line"></div><div class="line">    pop(...) <span class="comment"># 右侧出队</span></div><div class="line"></div><div class="line">    popleft(...) <span class="comment"># 左侧出队</span></div><div class="line"></div><div class="line">    remove(...) <span class="comment"># 删除某个元素</span></div><div class="line"></div><div class="line">    rotate(...) <span class="comment"># 头结点向右移动n个位置</span></div></pre></td></tr></table></figure><p><br></p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt;&gt; <span class="keyword">from</span> heapq <span class="keyword">import</span> *</div><div class="line">&gt;&gt;&gt;&gt; heap = []</div><div class="line"></div><div class="line">heapify(heap) <span class="comment"># 将一个列表转化为堆</span></div><div class="line"></div><div class="line">heappop(heap) <span class="comment"># 返回小顶堆中最小的元素</span></div><div class="line"></div><div class="line">heappush(heap, x) <span class="comment"># 将元素加入到堆中</span></div><div class="line"></div><div class="line">heapreplace(heap, x) <span class="comment"># 将堆中最小的元素弹出，同时将x入堆</span></div></pre></td></tr></table></figure><p>Python中的堆默认是小顶堆，如果想实现的大顶堆的话（只能是正数），可以像下面这样使用：<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># 构建堆</span></div><div class="line">heappush(heap, -x)</div><div class="line"></div><div class="line"><span class="comment"># 获得最大值</span></div><div class="line">-heappop(heap)</div></pre></td></tr></table></figure></p><p><br></p><h4 id="正则"><a href="#正则" class="headerlink" title="正则"></a>正则</h4><p>正则表达式是可以匹配文本片段的模式。</p><p>正则需要注意的几点：</p><ol><li>使用原生字符串如：r’python\.org’，避免多次使用’\\.’让re模块转义和解释器两次转义。</li><li>re.match()函数在字符串的开始处匹配模式，如果想匹配整个字符串，可以在结尾家美元符。</li><li>正则默认为贪婪模式，可以在子模式后加?改为非贪婪模式，如：pattern = r’\<em>\</em>(.+?)\<em>\</em>‘。<br><br></li></ol><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>初始化，集合是由序列（或者其他可迭代的对象）构建的。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>set([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div><div class="line">set([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>])</div></pre></td></tr></table></figure></p><p>性质</p><ul><li>集合中元素的顺序是随意的。</li><li>集合是可变的，不能用做字典中的健。</li><li>集合只能包含不可变的值，所以不能包含其他集合。</li></ul><p>常用方法<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span>a = set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>b = set([<span class="number">2</span>, <span class="number">3</span> ,<span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="comment"># 并集</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a | b </div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, ,<span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="comment"># 交集</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a &amp; b</div><div class="line">set([<span class="number">2</span>, <span class="number">3</span>])</div><div class="line"></div><div class="line"><span class="comment"># 差集</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a - b</div><div class="line">set([<span class="number">1</span>])</div><div class="line"></div><div class="line"><span class="comment"># 异或</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a ^ b</div><div class="line">set([<span class="number">1</span>, <span class="number">4</span>])</div><div class="line"></div><div class="line"><span class="comment"># 复制</span></div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.copy()</div><div class="line">set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.copy() <span class="keyword">is</span> a</div><div class="line"><span class="keyword">False</span></div></pre></td></tr></table></figure></p><p><br></p><h4 id="排列组合"><a href="#排列组合" class="headerlink" title="排列组合"></a>排列组合</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> itertools <span class="keyword">import</span> combinations, permutations</div><div class="line"></div><div class="line"></div><div class="line">s = <span class="string">'abc'</span></div><div class="line">p = list(permutations(s)) <span class="comment"># [('a', 'b', 'c'), ('a', 'c', 'b'), ('b', 'a', 'c'), ('b', 'c', 'a'), ('c', 'a','b'), ('c', 'b', 'a')]</span></div><div class="line">c = list(combinations(s, <span class="number">2</span>)) <span class="comment"># [('a', 'b'), ('a', 'c'), ('b', 'c')]</span></div></pre></td></tr></table></figure><p><br></p><h4 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h4><blockquote><p>sys这个模块让你能够访问与Python解释器联系紧密的变量和函数。</p></blockquote><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sys.stdin</div><div class="line">sys.stdout</div><div class="line">sys.stderr</div></pre></td></tr></table></figure><p>sys.stdin、sys.stdout、sys.stderr模块变量是类文件流对象。它们表示标准UNIX概念中的标准输入、标准输出和标准出错。</p><p>sys.stdin与raw_input的区别是：</p><ul><li>sys.stdin会一直获取输入，可以通过sys.stdin.read(),sys.stdin.readline()等方法获取想要的内容,readline()获取的内容带换行符。</li><li>raw_input获取输入的时候，当输入回车后就停止了输入，raw_input获取的内容不带换行符。</li></ul><p>该知识点在<a href="https://www.nowcoder.com/questionTerminal/c471efdbd33a4a979539a91170c9f1cb" target="_blank" rel="external">此编程题</a>中体现</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;工具函数&quot;&gt;&lt;a href=&quot;#工具函数&quot; class=&quot;headerlink&quot; title=&quot;工具函数&quot;&gt;&lt;/a&gt;工具函数&lt;/h2&gt;&lt;p&gt;一些常用的函数&lt;br&gt;&lt;figure class=&quot;highlight py&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>解析DBLP数据集</title>
    <link href="http://yoursite.com/2018/04/22/%E8%A7%A3%E6%9E%90DBLP%E6%95%B0%E6%8D%AE%E9%9B%86/"/>
    <id>http://yoursite.com/2018/04/22/解析DBLP数据集/</id>
    <published>2018-04-21T23:12:07.000Z</published>
    <updated>2018-04-26T17:54:34.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>放弃了找实习的念头后，决心搞论文。冥思苦想了好长时间，终于决定了方向，和学者合作网络相关。于是开始了提取dblp数据集，在刚开始运行脚本的时候总是报一个错误，“IOError: [Errno 2] : ‘dblp.dtd’”。</p><p>以下是xml文件格式：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="ISO-8859-1"?&gt;</div><div class="line"><span class="meta">&lt;!DOCTYPE dblp SYSTEM "dblp.dtd"&gt;</span></div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure></p><p>思考了好久后终于明白，是因为项目中缺少dtd文件，导致程序找不到报错。接下来是关于xml方面的知识，之后讲解dblp解析数据。<br><br></p><h2 id="关于XML"><a href="#关于XML" class="headerlink" title="关于XML"></a>关于XML</h2><h4 id="什么是-XML"><a href="#什么是-XML" class="headerlink" title="什么是 XML?"></a>什么是 XML?</h4><ul><li>XML 指可扩展标记语言（EXtensible Markup Language）。</li><li>XML 是一种标记语言，很类似 HTML。</li><li>XML 的设计宗旨是传输数据，而非显示数据。<br><br></li></ul><h4 id="XML验证"><a href="#XML验证" class="headerlink" title="XML验证"></a>XML验证</h4><p>形式良好的XML文档会遵守前几章介绍过的 XML 语法规则：</p><ul><li>XML 文档必须有根元素</li><li>XML 文档必须有关闭标签</li><li>XML 标签对大小写敏感</li><li>XML 元素必须被正确的嵌套</li><li>XML 属性必须加引号</li></ul><p>合法的 XML 文档是“形式良好”的 XML 文档，同样遵守文档类型定义 (DTD) 的语法规则：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</div><div class="line">&lt;!DOCTYPE note SYSTEM &quot;Note.dtd&quot;&gt;</div><div class="line">&lt;note&gt;</div><div class="line">&lt;to&gt;George&lt;/to&gt;</div><div class="line">&lt;from&gt;John&lt;/from&gt;</div><div class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</div><div class="line">&lt;body&gt;Don&apos;t forget the meeting!&lt;/body&gt;</div><div class="line">&lt;/note&gt;</div></pre></td></tr></table></figure></p><p>DTD(Document Type Definition)的作用是定义 XML 文档的结构。它使用一系列合法的元素来定义文档结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;!DOCTYPE note [</div><div class="line">  &lt;!ELEMENT note (to,from,heading,body)&gt;</div><div class="line">  &lt;!ELEMENT to      (#PCDATA)&gt;</div><div class="line">  &lt;!ELEMENT from    (#PCDATA)&gt;</div><div class="line">  &lt;!ELEMENT heading (#PCDATA)&gt;</div><div class="line">  &lt;!ELEMENT body    (#PCDATA)&gt;</div><div class="line">]&gt;</div></pre></td></tr></table></figure></p><h2 id="SAX"><a href="#SAX" class="headerlink" title="SAX"></a>SAX</h2><p>sax是Python提供的一个解析xml文件的库，从它的源码中可以看出它提供了一些事件处理程序，通过实现这些处理程序完成解析功能，实现了C编写的Python处理模块提供的接口。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;放弃了找实习的念头后，决心搞论文。冥思苦想了好长时间，终于决定了方向，和学者合作网络相关。于是开始了提取dblp数据集，在刚开始运行脚本的时
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>随便记录的笔试题</title>
    <link href="http://yoursite.com/2018/04/19/%E9%9A%8F%E4%BE%BF%E8%AE%B0%E5%BD%95%E7%9A%84%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    <id>http://yoursite.com/2018/04/19/随便记录的笔试题/</id>
    <published>2018-04-19T03:28:01.000Z</published>
    <updated>2018-04-26T02:45:18.158Z</updated>
    
    <content type="html"><![CDATA[<h2 id="2018春季百度前端笔试题"><a href="#2018春季百度前端笔试题" class="headerlink" title="2018春季百度前端笔试题"></a>2018春季百度前端笔试题</h2><h4 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h4><ul><li>建立一个堆的复杂度？</li><li>给定一串数字(1, 34, 56, 76, 3, 65)哈希函数H(key) = key % 7，采用链地址法，求查找成功时的平均查找长度？</li><li>HTTP报文相关字段，如cache等。</li><li>‘1’ + 0, ‘1’ - 0, ‘1’ * 0</li><li>时间片轮询调度算法？</li><li>触发进程调度的原因？<br><br></li></ul><h4 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h4><ol><li>一个表有三个字段id，price，sales，下面有多条数据，写一段JavaScript代码，如sort(‘price’, ‘asc’)函数，将表中数据按price升序。<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>id<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>price<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>900<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>10.0<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>400<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>40.5<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>500<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></div></pre></td></tr></table></figure></li></ol><p><br></p><h4 id="问答题"><a href="#问答题" class="headerlink" title="问答题"></a>问答题</h4><p>现代JavaScript中有哪些方法可以优化回调陷阱的问题？<br><br></p><h4 id="设计题"><a href="#设计题" class="headerlink" title="设计题"></a>设计题</h4><p>参照一下性能优化建议，设计一个JavaScript工具库，实现在任意HTML中运行该库可以计算出该页面的性能得分。（如dom元素小于200位100分，大于1000为0分）。</p><ul><li>减少DOM元素数量。</li><li>推迟加载非关键JavaScript(defer,async)。</li><li>减少使用iframe。</li><li>样式表置于顶部，JavaScript置于底部。</li><li>不要在HTML中缩放图像。</li><li>为图片资源响应头指定Expires或者Cache-Control并进行Gzip压缩。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;2018春季百度前端笔试题&quot;&gt;&lt;a href=&quot;#2018春季百度前端笔试题&quot; class=&quot;headerlink&quot; title=&quot;2018春季百度前端笔试题&quot;&gt;&lt;/a&gt;2018春季百度前端笔试题&lt;/h2&gt;&lt;h4 id=&quot;选择题&quot;&gt;&lt;a href=&quot;#选择题&quot; c
      
    
    </summary>
    
    
      <category term="笔试题" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript模块化简介</title>
    <link href="http://yoursite.com/2018/04/08/JavaScript%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/04/08/JavaScript模块化简介/</id>
    <published>2018-04-08T04:49:15.000Z</published>
    <updated>2018-04-17T18:13:47.543Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CommonJS-RequireJS-AMD-CMD之间的关系"><a href="#CommonJS-RequireJS-AMD-CMD之间的关系" class="headerlink" title="CommonJS,RequireJS,AMD/CMD之间的关系"></a>CommonJS,RequireJS,AMD/CMD之间的关系</h2><ul><li>CommonJS是一个JavaScript面向服务端、桌面开发环境提供的API，它提供包括模块化、命令行等特性。其中在模块加载上CommonJS采用同步加载。著名的NodeJS就是采用的CommonJS标准实现的模块加载机制。</li><li>AMD 是 RequireJS 在推广过程中对模块定义的规范，它定义了兼容浏览器应用的异步模块加载方式。</li><li>CMD 是 SeaJS 在推广过程中对模块定义的规范。</li><li>AMD:提前执行（异步加载：依赖先执行）+延迟执行。</li><li>CMD:延迟执行（运行到需加载，根据顺序执行）。</li></ul><p><br></p><h2 id="为什么要模块化？"><a href="#为什么要模块化？" class="headerlink" title="为什么要模块化？"></a>为什么要模块化？</h2><ul><li>网站开发的方式正在转换成Web apps的方式。</li><li>随着网站变大，代码变的越来越复杂。</li><li>配置变的很困难。</li><li>开发者们想要分离式的模块或文件。</li><li>开发者们只想要一部分代码发送HTTP请求。<br><br></li></ul><h2 id="之前如何写？"><a href="#之前如何写？" class="headerlink" title="之前如何写？"></a>之前如何写？</h2><h4 id="Anonymous-Closures"><a href="#Anonymous-Closures" class="headerlink" title="Anonymous Closures"></a>Anonymous Closures</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// ... all vars and functions are in this scope only</span></div><div class="line"><span class="comment">// still maintains access to all globals</span></div><div class="line">&#125;());</div></pre></td></tr></table></figure><h4 id="Global-Import"><a href="#Global-Import" class="headerlink" title="Global Import"></a>Global Import</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">$, YAHOO</span>) </span>&#123;</div><div class="line"><span class="comment">// now have access to globals jQuery (as $) and YAHOO in this code</span></div><div class="line">&#125;(jQuery, YAHOO));</div></pre></td></tr></table></figure><h4 id="Module-Export"><a href="#Module-Export" class="headerlink" title="Module Export"></a>Module Export</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MODULE = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> my = &#123;&#125;,</div><div class="line">privateVariable = <span class="number">1</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">privateMethod</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">my.moduleProperty = <span class="number">1</span>;</div><div class="line">my.moduleMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// ...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><h4 id="Augmentation-耦合"><a href="#Augmentation-耦合" class="headerlink" title="Augmentation(耦合)"></a>Augmentation(耦合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MODULE = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line">my.anotherMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// added method...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125;(MODULE));</div></pre></td></tr></table></figure><h4 id="Loose-Augmentation-松耦合"><a href="#Loose-Augmentation-松耦合" class="headerlink" title="Loose Augmentation(松耦合)"></a>Loose Augmentation(松耦合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MODULE = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line"><span class="comment">// add capabilities...</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125;(MODULE || &#123;&#125;));</div></pre></td></tr></table></figure><h4 id="Tight-Augmentation-紧耦合"><a href="#Tight-Augmentation-紧耦合" class="headerlink" title="Tight Augmentation(紧耦合)"></a>Tight Augmentation(紧耦合)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MODULE = (<span class="function"><span class="keyword">function</span> (<span class="params">my</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> old_moduleMethod = my.moduleMethod;</div><div class="line"></div><div class="line">my.moduleMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// method override, has access to old through old_moduleMethod...</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125;(MODULE));</div></pre></td></tr></table></figure><h4 id="Cloning-and-Inheritance"><a href="#Cloning-and-Inheritance" class="headerlink" title="Cloning and Inheritance"></a>Cloning and Inheritance</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> MODULE_TWO = (<span class="function"><span class="keyword">function</span> (<span class="params">old</span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> my = &#123;&#125;,</div><div class="line">key;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (key <span class="keyword">in</span> old) &#123;</div><div class="line"><span class="keyword">if</span> (old.hasOwnProperty(key)) &#123;</div><div class="line">my[key] = old[key];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> super_moduleMethod = old.moduleMethod;</div><div class="line">my.moduleMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="comment">// override method on the clone, access to super through super_moduleMethod</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125;(MODULE));</div></pre></td></tr></table></figure><h4 id="Sub-modules"><a href="#Sub-modules" class="headerlink" title="Sub-modules"></a>Sub-modules</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">MODULE.sub = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line"><span class="keyword">var</span> my = &#123;&#125;;</div><div class="line"><span class="comment">// ...</span></div><div class="line"></div><div class="line"><span class="keyword">return</span> my;</div><div class="line">&#125;());</div></pre></td></tr></table></figure><p><br></p><p>参考：<br><a href="http://requirejs.org/" target="_blank" rel="external">http://requirejs.org/</a><br><a href="http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html" target="_blank" rel="external">http://www.adequatelygood.com/JavaScript-Module-Pattern-In-Depth.html</a><br><a href="https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs" target="_blank" rel="external">https://stackoverflow.com/questions/16521471/relation-between-commonjs-amd-and-requirejs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CommonJS-RequireJS-AMD-CMD之间的关系&quot;&gt;&lt;a href=&quot;#CommonJS-RequireJS-AMD-CMD之间的关系&quot; class=&quot;headerlink&quot; title=&quot;CommonJS,RequireJS,AMD/CMD之间的关
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript数组常用api</title>
    <link href="http://yoursite.com/2018/04/06/JavaScript%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8api/"/>
    <id>http://yoursite.com/2018/04/06/JavaScript数组常用api/</id>
    <published>2018-04-06T04:26:35.000Z</published>
    <updated>2018-04-06T04:42:07.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sort-方法"><a href="#sort-方法" class="headerlink" title="sort()方法"></a>sort()方法</h2><blockquote><p>语法：arr.sort(compareFunction)</p></blockquote><p>compareFunction可选，用来指定按某种顺序进行排列的函数。</p><p>sort()方法会把数组中元素转换为字符（调用toString()方法），根据每个字符Unicode位点进行排序。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</div><div class="line">values.sort();</div><div class="line">alert(values);       <span class="comment">// 0, 1, 10, 15, 5</span></div></pre></td></tr></table></figure></p><p>比较函数接受两个参数，若第一个参数小于第二个参数则返回负数；若第一个参数等于第二个参数则返回整数；若第一个参数大于第二个参数则返回整数。一个比较函数的例子：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">compareFunction(a, b) &#123;</div><div class="line">  <span class="keyword">if</span> (a &lt; b) <span class="keyword">return</span> <span class="number">-1</span>;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; b) <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">values.sort(compareFunction);</div><div class="line">alert(values);       <span class="comment">// 0, 1, 5, 10, 15</span></div></pre></td></tr></table></figure></p><p>当 compareFunction 较为复杂，使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 需要被排序的数组</span></div><div class="line"><span class="keyword">var</span> list = [<span class="string">'Delta'</span>, <span class="string">'alpha'</span>, <span class="string">'CHARLIE'</span>, <span class="string">'bravo'</span>];</div><div class="line"></div><div class="line"><span class="comment">// 对需要排序的数字和位置的临时存储</span></div><div class="line"><span class="keyword">var</span> mapped = list.map(<span class="function"><span class="keyword">function</span>(<span class="params">el, i</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> &#123; <span class="attr">index</span>: i, <span class="attr">value</span>: el.toLowerCase() &#125;;</div><div class="line">&#125;)</div><div class="line"></div><div class="line"><span class="comment">// 按照多个值排序数组</span></div><div class="line">mapped.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> +(a.value &gt; b.value) || +(a.value === b.value) - <span class="number">1</span>;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 根据索引得到排序的结果</span></div><div class="line"><span class="keyword">var</span> result = mapped.map(<span class="function"><span class="keyword">function</span>(<span class="params">el</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> list[el.index];</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p><p>最后要说的是JavaScript数组中使用的排序算法是in-place类型的，为了节省内存，是不稳定的，因为基于非相邻元素比较的排序算法都是不稳定的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sort-方法&quot;&gt;&lt;a href=&quot;#sort-方法&quot; class=&quot;headerlink&quot; title=&quot;sort()方法&quot;&gt;&lt;/a&gt;sort()方法&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;语法：arr.sort(compareFunction)&lt;/p&gt;
&lt;/
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>igraph报错cannot_import_name_Graph/module_has_no_attribute_Graph</title>
    <link href="http://yoursite.com/2018/03/31/igraph%E6%8A%A5%E9%94%99cannot-import-name-Graph-module-has-no-attribute-Graph/"/>
    <id>http://yoursite.com/2018/03/31/igraph报错cannot-import-name-Graph-module-has-no-attribute-Graph/</id>
    <published>2018-03-31T03:51:32.000Z</published>
    <updated>2018-03-31T17:12:53.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习使用Python的igraph包进行网络分析，在使用igraph.Graph创建图的过程中，总是报错“module has no attribute Graph”，开始以为是windows不行，换了Linux，发现Linux同样不行，最后发现了原因，就是因为我把要运行的代码文件命名为了igraph.py，导致Python解释器认为我的igraph.py是一个模块，igraph.py当然没有Graph模块了，所以会报错。经过这次这个教训，我决定复习下Python的模块机制<br><br></p><h2 id="模块是程序"><a href="#模块是程序" class="headerlink" title="模块是程序"></a>模块是程序</h2><p>任何Python程序都可以作为模块导入。例如，你定义了一个hello.py文件，同时设置了环境变量，那么你就可以导入该模块。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>sys.path.append(<span class="string">'/文件hello.py路径'</span>)</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> hello</div></pre></td></tr></table></figure><p>注意：导入模块“只导入一次”，导入模块并不意味着在导入时执行某些操作，它们主要用于定义，比如变量、函数、类。只导入一次可以避免导入的无线循环。<br><br></p><h2 id="模块用于定义"><a href="#模块用于定义" class="headerlink" title="模块用于定义"></a>模块用于定义</h2><p>模块在第一次导入到程序中时被执行。它们保持自己的作用域，其中定义的类、函数、变量都成为了模块的特性。</p><h4 id="在模块中定义函数"><a href="#在模块中定义函数" class="headerlink" title="在模块中定义函数"></a>在模块中定义函数</h4><p>如我在a.py中定义了helllo函数，同时在b.py中定义了hello函数，我们来看一看调用的区别。</p><p>a.py<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"a.py"</span></div></pre></td></tr></table></figure></p><p>b.py<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"b.py"</span></div></pre></td></tr></table></figure></p><p>体会模块保持自己的作用域<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> a <span class="keyword">import</span> *</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> b <span class="keyword">import</span> *</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>hello()</div><div class="line"><span class="comment"># 输出b.py，b覆盖了a</span></div></pre></td></tr></table></figure></p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> a <span class="keyword">import</span> *</div><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> b <span class="keyword">import</span> *</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>a.hello()</div><div class="line"><span class="comment"># 输出a.py</span></div></pre></td></tr></table></figure><h4 id="在模块中增加测试代码"><a href="#在模块中增加测试代码" class="headerlink" title="在模块中增加测试代码"></a>在模块中增加测试代码</h4><p>我们可以设置模块本身是作为程序运行还是导入到其他程序。</p><p>为此，我们可以使用Python中的变量<strong>name</strong>，在“主程序”（包括解释器的交互提示符在内）中，变量<strong>name</strong>的值是”<strong>main</strong>“，而在导入的模块中，这个值被设定为模块的名字。</p><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></div><div class="line">    <span class="keyword">print</span> <span class="string">"Hello world!"</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></div><div class="line">    hello()</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>: test()</div></pre></td></tr></table></figure><p><br></p><h2 id="让你的模块可用"><a href="#让你的模块可用" class="headerlink" title="让你的模块可用"></a>让你的模块可用</h2><p>导入模块，执行程序时，解释器在sys.path的路径列表中查找模块。有两种方式可以让你的模块被查找。</p><p>1.将模块放置在合适的位置，只需要找出Python解释器在哪里查找模块。可以将模块放到下面输出位置中。<br><figure class="highlight py"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys, pprint</div><div class="line"><span class="meta">&gt;&gt;&gt; </span>pprint.pprint(sys.path)</div><div class="line">[<span class="string">'C:\\Python27\\Lib'</span>,</div><div class="line"><span class="string">'xxx'</span></div><div class="line"><span class="string">'xxx'</span></div><div class="line">]</div></pre></td></tr></table></figure></p><p>2.在PYTHONPATH环境变量中包含模块所在目录。</p><p>3.临时解决方案：sys.pat.append(“/xxx”)</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在学习使用Python的igraph包进行网络分析，在使用igraph.Graph创建图的过程中，总是报错“module has no 
      
    
    </summary>
    
    
      <category term="Python" scheme="http://yoursite.com/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>ECMAScript对象类型</title>
    <link href="http://yoursite.com/2018/03/16/ECMAScript%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2018/03/16/ECMAScript对象类型/</id>
    <published>2018-03-15T19:38:51.000Z</published>
    <updated>2018-03-21T17:56:35.862Z</updated>
    
    <content type="html"><![CDATA[<p>在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有以下几种：本地对象、内置对象、宿主对象、自定义对象。其中本地对象包含内置对象。</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><blockquote><p>“由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就已经存在了。”开发人员不必显示地实例化内置对象，因为它们已经实例化了。</p></blockquote><h2 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h2><p>Global对象是不存在的，ECMAScript中的Global对象在某种意义来说作为一个“兜底对象”。不属于其他对象的属性和方法，最终都是它的属性和方法；所有在全局作用域定义的属性和函数，都是Global对象的属性。Web浏览器实现了承担该角色的window对象。</p><ul><li>isNaN()</li><li>isFinite()</li><li>parseInt()</li><li>parseFloat()</li></ul><p>除此之外Global对象还包含其他一些方法：</p><p><br></p><h4 id="URI编码-解码方法"><a href="#URI编码-解码方法" class="headerlink" title="URI编码/解码方法"></a>URI编码/解码方法</h4><p>包括encodeURI()、encodeURIComponent()、decodeURI()、decodeURIComponent()<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">encodeURI</span>()对无效字符进行编码，如空格，但不会对特殊字符进行编码，如冒号、正斜杠、问号、井号；如果需要编码特殊字符需要使用<span class="built_in">encodeURIComponent</span>()。</div><div class="line"></div><div class="line"><span class="keyword">var</span> uri = <span class="string">"http://www.baidu.com/ abc.html#def"</span>;</div><div class="line"></div><div class="line">alert(<span class="built_in">encodeURI</span>(uri));          <span class="comment">// http://www.baidu.com/%20abc.html#def</span></div><div class="line">alert(<span class="built_in">encodeURIComponent</span>(uri)); <span class="comment">// http%3A%2F%2Fwww.baidu.com%2F%20abc.html%23def</span></div></pre></td></tr></table></figure></p><p><br></p><h4 id="eval-方法"><a href="#eval-方法" class="headerlink" title="eval()方法"></a>eval()方法</h4><p>eval()方法像是一个ECMAScript解析器，参数为JavaScript字符串。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">eval</span>(<span class="string">"alert('hi')"</span>);</div></pre></td></tr></table></figure></p><p>eval()方法可以引用包含环境外的变量，也可以在外部调用eval()内定义的函数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> msg = <span class="string">"hello world"</span>;</div><div class="line"><span class="built_in">eval</span>(<span class="string">"alert(msg)"</span>);</div><div class="line"></div><div class="line"><span class="built_in">eval</span>(<span class="string">"function sayHi() &#123; alert('hi'); &#125;"</span>);</div><div class="line">sayHi();</div></pre></td></tr></table></figure></p><p>eval()函数中创建的任何函数或变量都不会变量提升。</p><p>严格模式下外部访问不到eval()中创建的任何变量或函数，为eval赋值也不行。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">"use strict"</span>;</div><div class="line"><span class="built_in">eval</span> = <span class="string">"hi"</span>;</div></pre></td></tr></table></figure></p><h2 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h2><h4 id="min-和max-方法"><a href="#min-和max-方法" class="headerlink" title="min()和max()方法"></a>min()和max()方法</h4><p>确定一组数值中的最大值和最小值，可以接收任意多个数值参数。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max(<span class="number">3</span>, <span class="number">54</span>, <span class="number">32</span>, <span class="number">16</span>);</div><div class="line">alert(max);    <span class="comment">// 54</span></div></pre></td></tr></table></figure></p><p>也可以使用apply()方法调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</div><div class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</div></pre></td></tr></table></figure></p><h4 id="舍入方法"><a href="#舍入方法" class="headerlink" title="舍入方法"></a>舍入方法</h4><ul><li>Math.ceil()，向上舍入。</li><li>Math.floor()，向下舍入。</li><li>Math.round()，四舍五入最近的整数。<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">alert(<span class="built_in">Math</span>.ceil(<span class="number">25.9</span>));  <span class="comment">// 26</span></div><div class="line">alert(<span class="built_in">Math</span>.floor(<span class="number">25.9</span>)); <span class="comment">// 25</span></div><div class="line">alert(<span class="built_in">Math</span>.round(<span class="number">25.9</span>)); <span class="comment">// 26</span></div></pre></td></tr></table></figure></li></ul><h4 id="random-方法"><a href="#random-方法" class="headerlink" title="random()方法"></a>random()方法</h4><p>Math.random()方法返回大于等于0小于1的一个随机数。</p><blockquote><p>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectFrom</span>(<span class="params">lowerValue, upperValue</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> choices = upperValue = lowervalue + <span class="number">1</span>;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random * choices + lowerValue);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> num = selectFrom(<span class="number">2</span>, <span class="number">10</span>);</div><div class="line">alert(num);</div></pre></td></tr></table></figure><p>用上面的方法可以轻松获得2~10之间的一个整数。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul><li>Math.abs(num)  返回num绝对值</li><li>Math.exp(num)  返回Math.E的num次幂</li><li>Math.log(num)  返回num的自然对数</li><li>Math.pow(num)  返回num的power次幂</li><li>Math.sqrt(num) 返回num的平方根</li></ul><p>参考：<br><a href="http://www.w3school.com.cn/js/pro_js_object_types.asp" target="_blank" rel="external">http://www.w3school.com.cn/js/pro_js_object_types.asp</a><br>《JavaScript高级程序设计》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有以下几种：本地对象、内置对象、宿主对象、自定义对象。其中本地对象包含内置对象。&lt;/p&gt;
&lt;h2 id=&quot;内置对象&quot;&gt;&lt;a href=&quot;#内置对象&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript创建对象的几种方式</title>
    <link href="http://yoursite.com/2018/03/08/JavaScript%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2018/03/08/JavaScript创建对象的几种方式/</id>
    <published>2018-03-07T22:33:11.000Z</published>
    <updated>2018-03-21T17:16:00.042Z</updated>
    
    <content type="html"><![CDATA[<h2 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"Nicholas"</span>,</div><div class="line">  <span class="attr">age</span>: <span class="number">29</span>,</div><div class="line">  <span class="attr">job</span>: <span class="string">"Software Engineer"</span>,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>缺点是使用同一接口创建很多对象，会产生大量重复的代码。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">  o.name = name;</div><div class="line">  o.age = age;</div><div class="line">  o.job = job;</div><div class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;;</div><div class="line">  <span class="keyword">return</span> o;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure><p>缺点是不能识别对象的类型(即怎样知道一个对象的类型，即使用instanceof识别)。</p><h2 id="构造函数模式"><a href="#构造函数模式" class="headerlink" title="构造函数模式"></a>构造函数模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure><p>这里在复习一下使用new操作符后的执行过程：</p><ol><li>创建一个新对象。</li><li>将构造函数作用域执行新对象（this指向了新对象）。</li><li>执行构造函数中的代码。</li><li>返回新对象。</li></ol><p>构造函数中的缺点就是，每个方法都要在每个实例上重新创造一遍，ECMAScript中Function也是对象，因此定义一个函数也就是实例化一个对象，导致不同实例上的同名函数是不等的。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.ag = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.sayName = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"alert(this.name)"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h2 id="组合构造函数模式和原型模式"><a href="#组合构造函数模式和原型模式" class="headerlink" title="组合构造函数模式和原型模式"></a>组合构造函数模式和原型模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line">  <span class="keyword">this</span>.friends = [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">Person.prototype = &#123;</div><div class="line">  <span class="attr">constructor</span>: Person,</div><div class="line">  <span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    alert(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</div></pre></td></tr></table></figure><p>实例的属性都是在构造函数中定义的，所有实例共享原型链中定义的constructor方法和sayName()方法，而修改其中一个friends并不会影响另一个friends。</p><h2 id="动态原型模式"><a href="#动态原型模式" class="headerlink" title="动态原型模式"></a>动态原型模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name;</div><div class="line">  <span class="keyword">this</span>.age = age;</div><div class="line">  <span class="keyword">this</span>.job = job;</div><div class="line"></div><div class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>) &#123;</div><div class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      alert(<span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</div><div class="line">person1.sayName();</div></pre></td></tr></table></figure><p>这段代码只会在初次调用构造函数时才会执行。此后，原型已经初始化，不需要做什么修改。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;对象字面量&quot;&gt;&lt;a href=&quot;#对象字面量&quot; class=&quot;headerlink&quot; title=&quot;对象字面量&quot;&gt;&lt;/a&gt;对象字面量&lt;/h2&gt;&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;p
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript的this理解</title>
    <link href="http://yoursite.com/2018/03/03/JavaScript%E7%9A%84this%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/03/03/JavaScript的this理解/</id>
    <published>2018-03-03T03:35:55.000Z</published>
    <updated>2018-04-03T05:08:20.609Z</updated>
    
    <content type="html"><![CDATA[<h2 id="this理解"><a href="#this理解" class="headerlink" title="this理解"></a>this理解</h2><p>this对象是在运行时基于函数的执行环境的定的。</p><h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h4 id="上下文"><a href="#上下文" class="headerlink" title="上下文"></a>上下文</h4><p>无论是否在严格模式下，在全局执行上下文中（在任何函数体外部）this 都指代全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在浏览器中, window 对象同时也是全局对象：</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">// true</span></div><div class="line"></div><div class="line">a = <span class="number">37</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">// 37</span></div><div class="line"></div><div class="line"><span class="keyword">this</span>.b = <span class="string">"MDN"</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.b)  <span class="comment">// "MDN"</span></div></pre></td></tr></table></figure></p><p>在全局上下文下调用函数，函数中的this，在严格模式下为全局对象，在非严格模式下为undefined。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//在浏览器中：</span></div><div class="line">f1() === <span class="built_in">window</span>;   <span class="comment">//在浏览器中，全局对象是window</span></div><div class="line"></div><div class="line"><span class="comment">//在Node中：</span></div><div class="line">f1() === global;</div></pre></td></tr></table></figure></p><h4 id="函数作为对象的一个属性"><a href="#函数作为对象的一个属性" class="headerlink" title="函数作为对象的一个属性"></a>函数作为对象的一个属性</h4><p>如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getName() <span class="comment">// "My Object"</span></div></pre></td></tr></table></figure></p><p>匿名函数的this略有不同，通常指向window。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getNameFunc()(); <span class="comment">// "The Window"</span></div></pre></td></tr></table></figure></p><p>匿名函数的在搜索活动对象this和arguments的时候会在作用域链上搜索，匿名函数外的执行环境为getNameFunc的执行环境getNameFunc的执行环境中的活动对象并没有this.name，就会停止搜索，直接将this指向window。</p><p>解决这种问题的方式是把this保存作为活动对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</div><div class="line"><span class="keyword">var</span> object = &#123;</div><div class="line">  <span class="attr">name</span>: <span class="string">"My Object"</span>,</div><div class="line">  <span class="attr">getNameFunc</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</div><div class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.name;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">object.getNameFunc()(); <span class="comment">// "My Object"</span></div></pre></td></tr></table></figure></p><h4 id="函数用call或者apply调用"><a href="#函数用call或者apply调用" class="headerlink" title="函数用call或者apply调用"></a>函数用call或者apply调用</h4><p>如果要想把 this 的值从一个上下文传到另一个，就要用 call 或者apply 方法。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 一个对象可以作为call和apply的第一个参数，并且this会被绑定到这个对象。</span></div><div class="line"><span class="keyword">var</span> obj = &#123;<span class="attr">a</span>: <span class="string">'Custom'</span>&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 这个属性是在global对象定义的。</span></div><div class="line"><span class="keyword">var</span> a = <span class="string">'Global'</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">whatsThis</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.a;  <span class="comment">// this的值取决于函数的调用方式</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">whatsThis();          <span class="comment">// 'Global'</span></div><div class="line">whatsThis.call(obj);  <span class="comment">// 'Custom'</span></div><div class="line">whatsThis.apply(obj); <span class="comment">// 'Custom'</span></div></pre></td></tr></table></figure></p><h4 id="作为构造函数"><a href="#作为构造函数" class="headerlink" title="作为构造函数"></a>作为构造函数</h4><p>通过new Foo()一个对象的方式调用构造函数，那么在函数中访问this的时候，this指向的是新对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'lucky4'</span>;</div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1993</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Foo &#123; name: "lucky4", year: 1993 &#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> Foo();</div></pre></td></tr></table></figure></p><p>this指向新创造对象的原因是，在使用new操作符后，调用构造函数会经历一下4个步骤：</p><ol><li>创建一个新对象。</li><li>将构造函数的作用域赋给新对象（因此this就指向了这个新对象）。</li><li>执行构造函数中的代码。</li><li>返回新对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = <span class="string">'lucky4'</span>;</div><div class="line">  <span class="keyword">this</span>.year = <span class="number">1993</span>;</div><div class="line"></div><div class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// Window &#123;...&#125;</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">Foo();</div></pre></td></tr></table></figure><p>如果未通过new的方式访问构造函数，那么this将指向Window。</p><h4 id="arrow-function-中的this"><a href="#arrow-function-中的this" class="headerlink" title="arrow function 中的this"></a>arrow function 中的this</h4><p>在箭头函数中，this与封闭词法上下文的this保持一致。在全局代码中，它将被设置为全局对象。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> globalObject = <span class="keyword">this</span>;</div><div class="line"><span class="keyword">var</span> foo = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</div><div class="line"><span class="built_in">console</span>.log(foo() === globalObject); <span class="comment">// true</span></div></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 创建一个含有bar方法的obj对象，</span></div><div class="line"><span class="comment">// bar返回一个函数，</span></div><div class="line"><span class="comment">// 这个函数返回this，</span></div><div class="line"><span class="comment">// 这个返回的函数是以箭头函数创建的，</span></div><div class="line"><span class="comment">// 所以它的this被永久绑定到了它外层函数的this。</span></div><div class="line"><span class="comment">// bar的值可以在调用中设置，这反过来又设置了返回函数的值。</span></div><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> x = <span class="function">(<span class="params">(</span>) =&gt;</span> <span class="keyword">this</span>);</div><div class="line">    <span class="keyword">return</span> x;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 作为obj对象的一个方法来调用bar，把它的this绑定到obj。</span></div><div class="line"><span class="comment">// 将返回的函数的引用赋值给fn。</span></div><div class="line"><span class="keyword">var</span> fn = obj.bar();</div><div class="line"></div><div class="line"><span class="comment">// 直接调用fn而不设置this，</span></div><div class="line"><span class="comment">// 通常(即不使用箭头函数的情况)默认为全局对象</span></div><div class="line"><span class="comment">// 若在严格模式则为undefined</span></div><div class="line"><span class="built_in">console</span>.log(fn() === obj); <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 但是注意，如果你只是引用obj的方法，</span></div><div class="line"><span class="comment">// 而没有调用它</span></div><div class="line"><span class="keyword">var</span> fn2 = obj.bar;</div><div class="line"><span class="comment">// 那么调用箭头函数后，this指向window，因为它从 bar 继承了this。</span></div><div class="line"><span class="built_in">console</span>.log(fn2()() == <span class="built_in">window</span>); <span class="comment">// true</span></div></pre></td></tr></table></figure><h2 id="JavaScript中的this与Java、C-中的this有什么区别"><a href="#JavaScript中的this与Java、C-中的this有什么区别" class="headerlink" title="JavaScript中的this与Java、C++中的this有什么区别?"></a>JavaScript中的this与Java、C++中的this有什么区别?</h2><p>首先看一段Java的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boolean</span> </span>&#123; <span class="function"><span class="keyword">void</span> <span class="title">peel</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123; <span class="comment">/* ... */</span> &#125; &#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BananaPeel</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[], args)</span> </span>&#123;</div><div class="line">    Banana a = <span class="keyword">new</span> Banana(),</div><div class="line">           b = <span class="keyword">new</span> Banana();</div><div class="line">    a.peel(<span class="number">1</span>);</div><div class="line">    b.peel(<span class="number">2</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><p>在执行代码的时候，编译器做了一些幕后工作，它把所操作对象的应用作为第一个参数传递给了peel()，上面的两个方法的调用变成了这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Banana.peel(a, <span class="number">1</span>);</div><div class="line">Banana.peel(b, <span class="number">2</span>);</div></pre></td></tr></table></figure></p><p>假设你希望在方法内部获得对当前对象的引用。由于上面引用是由编译器传入的，所以没有表示符可用，为此有个专门的关键字：this。this关键字只能在方法内部使用，表示对“调用方法的那个对象”的引用。</p><p>Java中this的用处有很多包括，返回对当前对象的引用，方便链式调用；将当前对象传递给其他方法；在一个构造器中调用另一个构造器等。</p><p>我认为Java的this和JavaScript的this主要有以下几个区别：</p><ol><li>this的值，Java中的this是一个引用，JavaScript中的this是一个类数组对象。</li><li>Java中的this创建后不可改变，JavaScript中的this可以通过使用call，apply，bind等方式改变。也就是回到了对定义的理解Java中的this是编译时绑定的，而JavaScript中的this是基于运行时绑定的。</li></ol><p>参考：<br><a href="http://www.cnblogs.com/wangfupeng1988/p/3988422.html" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/3988422.html</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this</a><br>《JavaScript高级程序设计》<br>《Java编程思想》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;this理解&quot;&gt;&lt;a href=&quot;#this理解&quot; class=&quot;headerlink&quot; title=&quot;this理解&quot;&gt;&lt;/a&gt;this理解&lt;/h2&gt;&lt;p&gt;this对象是在运行时基于函数的执行环境的定的。&lt;/p&gt;
&lt;h2 id=&quot;用法&quot;&gt;&lt;a href=&quot;#用法&quot;
      
    
    </summary>
    
    
      <category term="JavaScipt" scheme="http://yoursite.com/tags/JavaScipt/"/>
    
  </entry>
  
  <entry>
    <title>DOM学习</title>
    <link href="http://yoursite.com/2018/02/27/DOM%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/02/27/DOM学习/</id>
    <published>2018-02-26T17:22:19.000Z</published>
    <updated>2018-03-20T17:54:40.421Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。DOM将文档描绘成一个由多层次节点构成的结构。节点分为几种不同类型，每种类型分别表示文档中不同的信息或标记。每个节点拥有自己的特点、数据和方法，另外与其他节点存在某种关系。</p><h2 id="Node-类型"><a href="#Node-类型" class="headerlink" title="Node 类型"></a>Node 类型</h2><p>DOM1级定义了一个Node接口，该接口将由DOM中的所有节点类型实现。这个Node接口在JavaScript中是作为Node类型实现的。</p><p>每个节点都有一个nodeType属性，用于表明节点的类型，由Node类型中定义的12个常量来表示：</p><ul><li>Node.ELEMENT_NODE(1);</li><li>Node.ATTRIBURE_NODE(2);</li><li>Node.TEXT_NODE(3);</li><li>Node.CDATA_SECTION_NODE(4);</li><li>Node.ENTITY_REFERENCE_NODE(5);</li><li>Node.ENTITY_NODE(6);</li><li>Node.PROCESSING_INSTRCTION_NODE(7);</li><li>Node.COMMNET_NODE(8);</li><li>Node.DOCUMENT_NODE(9);</li><li>Node.DOCUMENT_TYPE_NODE(10);</li><li>Node.DOCUMENT_FRAGMENT_NODE(11);</li><li>Node.NOTATION_NODE(12);</li></ul><h4 id="nodeName和nodeValue属性"><a href="#nodeName和nodeValue属性" class="headerlink" title="nodeName和nodeValue属性"></a>nodeName和nodeValue属性</h4><p>使用前最好判断节点类型，对于元素节点，nodeValue值始终为null。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (someNode.nodeType === <span class="number">1</span>) &#123;</div><div class="line">  value = someNode.nodeName</div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="节点关系"><a href="#节点关系" class="headerlink" title="节点关系"></a>节点关系</h4><p>常用的节点关系属性：</p><ul><li>childNodes;</li><li>NodeList;</li><li>parentNode;</li><li>previousSibling;</li><li>nextSibling;</li><li>firstChild;</li><li>lastChild;</li><li>ownerDocument;</li><li>hasChildNodes();</li></ul><p>每个节点都有一个childNodes属性，其中保存着一个NodeList对象。NodeList是一个类数组对象（有length属性以及内容按序保存），它基于DOM结构动态执行查询的结构，因此DOM结构的变化能够自动反映在NodeList对象中。</p><p>一种将类数组对象转换为数组的方法：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arrayOfNodes = <span class="built_in">Array</span>.prototype.slice.call(someNode.childNodes, <span class="number">0</span>)</div></pre></td></tr></table></figure></p><h4 id="操作节点"><a href="#操作节点" class="headerlink" title="操作节点"></a>操作节点</h4><p>常用的操作节点方法：</p><ul><li>appendChild();</li><li>insertBefore(要插入节点，参照节点，如果参照节点为null，则相当于appendChild操作);</li><li>replaceChild(要插入节点，要替换节点);</li><li>removeChild();</li><li>cloneNode();</li></ul><h2 id="Document-类型"><a href="#Document-类型" class="headerlink" title="Document 类型"></a>Document 类型</h2><p>JavaScript通过Document类型表示文档，在浏览器中，document对象是HTMLDocument的一个实例，表示整个HTML页面。而且，document对象是window对象的一个属性，因此可以将其作为全局对象来访问。Document节点具有下列特征：</p><ul><li>nodeType值为9;</li><li>nodeName值为”#document”;</li><li>nodeValue值为null;</li><li>parentNode值为null;</li><li>ownerDocument值为null;</li></ul><h4 id="文档的子节点"><a href="#文档的子节点" class="headerlink" title="文档的子节点"></a>文档的子节点</h4><p>Document节点的子节点可以是DocumentType、Element、Comment等，还有两个内置访问子节点的方式:documentElement属性（指向<html>元素），childNodes列表访问文档元素。document.body获得<body>引用，document.doctype获得&lt;!DOCTYPE&gt;的引用。</body></html></p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> html = <span class="built_in">document</span>.documentElement</div><div class="line">alert(html === <span class="built_in">document</span>.childNodes[<span class="number">0</span>])</div><div class="line"></div><div class="line"><span class="keyword">var</span> body = <span class="built_in">document</span>.body</div><div class="line"><span class="keyword">var</span> doctype = <span class="built_in">document</span>.doctype</div></pre></td></tr></table></figure><h4 id="文档信息"><a href="#文档信息" class="headerlink" title="文档信息"></a>文档信息</h4><p>作为HTMLDocument的一个实例，document对象还有一些标准的Document所没有的属性。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//取得文档标题</span></div><div class="line"><span class="keyword">var</span> originalTitle = <span class="built_in">document</span>.title</div><div class="line"></div><div class="line"><span class="comment">//设置文档标题</span></div><div class="line"><span class="built_in">document</span>.titl = <span class="string">"New page title"</span></div><div class="line"></div><div class="line"><span class="comment">//取得完整的URL</span></div><div class="line"><span class="keyword">var</span> url = <span class="built_in">document</span>.URL</div><div class="line"></div><div class="line"><span class="comment">//取得域名</span></div><div class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain</div><div class="line"></div><div class="line"><span class="comment">//取得来源页面的URL</span></div><div class="line"><span class="keyword">var</span> referrer = <span class="built_in">document</span>.referrer</div></pre></td></tr></table></figure></p><h4 id="查找元素"><a href="#查找元素" class="headerlink" title="查找元素"></a>查找元素</h4><ul><li>getElementById();</li><li>getElementsByTagName();</li><li>getElementsByName();</li></ul><p>后两个方法会返回一个类数组对象HTMLCollection，它与NodeList类似，它有一个特殊的方法,namedItem()，可以通过元素的name特性取得集合中的项，同时还支持按名称访问项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myImage = images.namedItem(<span class="string">"myImage"</span>)</div><div class="line"><span class="keyword">var</span> myImage = images[<span class="string">"myImage"</span>]</div></pre></td></tr></table></figure><h4 id="特殊集合"><a href="#特殊集合" class="headerlink" title="特殊集合"></a>特殊集合</h4><ul><li>document.forms 包含文档中所有<code>&lt;form&gt;</code> 元素，与document.getElementsByTagName(“form”)得到结果相同。</li><li>document.images 包含文档中所有<code>&lt;img&gt;</code> 元素，与document.getElementsByTageName(“img”)得到结果相同。</li></ul><h4 id="文档写入"><a href="#文档写入" class="headerlink" title="文档写入"></a>文档写入</h4><ul><li>document.write();</li><li>document.writeln();</li><li>document.open();</li><li>document.close();</li></ul><p>如果在文档加载结束后在调用document.write()，那么输出的内容将会重写整个页面。</p><h2 id="Element-类型"><a href="#Element-类型" class="headerlink" title="Element 类型"></a>Element 类型</h2><p>Element类型用于表现XML或HTML元素，Element节点具有以下特征：</p><ul><li>nodeType值为1</li><li>nodeName值为元素的标签名</li><li>nodeValue值为null</li></ul><p>在后的HTML中，标签名始终全以大写表示，所以在使用的时候要注意将其转化为小写的写法比较好。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span> (element.nodeName.toLowerCase() === <span class="string">"div"</span>) &#123;</div><div class="line">  <span class="comment">// 操作</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p><h4 id="HTML元素"><a href="#HTML元素" class="headerlink" title="HTML元素"></a>HTML元素</h4><p>HTML元素由HTMLElement类型表示，HTMLElement类型直接继承自Element并添加了一些属性，包括以下几个：</p><ul><li>id, 元素在文档中的唯一标识符。</li><li>title，有关元素的附加说明信息，一般通过工具提示条显示。</li><li>className，元素的class特性，对应CSS类。</li></ul><h4 id="取得属性"><a href="#取得属性" class="headerlink" title="取得属性"></a>取得属性</h4><p>每个元素都有一个或多个特性，用途是给出响应元素的附加信息，操作特性的方法主要有三个：</p><ul><li>getAttribute()</li><li>setAttribute()</li><li>removeAttribute()</li></ul><p>注意：getAttribute(“style”)返回一个对象，getAttribute(“onclick”)返回一段字符串。</p><h4 id="创建元素"><a href="#创建元素" class="headerlink" title="创建元素"></a>创建元素</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</div></pre></td></tr></table></figure><h2 id="Text类型"><a href="#Text类型" class="headerlink" title="Text类型"></a>Text类型</h2><p>文本节点由Text类型表示，包含的是字面解释的纯文本内容。</p><ul><li>nodeType的值为3。</li><li>nodeName的值为”#text”。</li><li>nodeValue的值为节点所包含的文本。</li></ul><h4 id="创建文本节点"><a href="#创建文本节点" class="headerlink" title="创建文本节点"></a>创建文本节点</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.createTextNode(<span class="string">"Hello World!"</span>)</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;DOM&quot;&gt;&lt;a href=&quot;#DOM&quot; class=&quot;headerlink&quot; title=&quot;DOM&quot;&gt;&lt;/a&gt;DOM&lt;/h2&gt;&lt;p&gt;DOM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。DOM将文档描绘成一个由多层次节点构成的结构。节点
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript深拷贝</title>
    <link href="http://yoursite.com/2018/02/13/JavaScript%E6%B7%B1%E6%8B%B7%E8%B4%9D/"/>
    <id>http://yoursite.com/2018/02/13/JavaScript深拷贝/</id>
    <published>2018-02-12T17:28:18.000Z</published>
    <updated>2018-02-12T18:16:01.020Z</updated>
    
    <content type="html"><![CDATA[<p>只针对Object类型的深拷贝，自己总结的三种方式，分别为：递归的方式、广度优先遍历的方式、使用JSON.parse()方法。</p><ol><li><p>递归：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">source</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> key, target</div><div class="line">  <span class="keyword">if</span> (type(source) === <span class="string">"object"</span>) &#123;</div><div class="line">    target = &#123;&#125;</div><div class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> source) &#123;</div><div class="line">      <span class="keyword">if</span> (type(source[key]) === <span class="string">"array"</span> || <span class="string">"object"</span>) &#123;</div><div class="line">        target[key] = copy(source[key])</div><div class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (source[key] !== <span class="literal">undefined</span>) target[key] = source[key]</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> target</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>广度优先遍历</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">copy</span>(<span class="params">data</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line">    <span class="keyword">var</span> originQueue = [data];</div><div class="line">    <span class="keyword">var</span> copyQueue = [obj];</div><div class="line">    <span class="keyword">while</span>(originQueue.length &gt; <span class="number">0</span>)&#123;</div><div class="line">        <span class="keyword">var</span> _data = originQueue.shift();</div><div class="line">        <span class="keyword">var</span> _obj = copyQueue.shift();</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> _data)&#123;</div><div class="line">            <span class="keyword">var</span> _value = _data[key]</div><div class="line">            <span class="keyword">if</span>(<span class="keyword">typeof</span> _value !== <span class="string">'object'</span>)&#123;</div><div class="line">                _obj[key] = _value;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                originQueue.push(_value);</div><div class="line">                _obj[key] = &#123;&#125;;</div><div class="line">                copyQueue.push(_obj[key]);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure></li><li><p>JSON</p><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(source))</div></pre></td></tr></table></figure></li></ol><p>参考: <a href="http://blog.csdn.net/sysuzhyupeng/article/details/70340598" target="_blank" rel="external">http://blog.csdn.net/sysuzhyupeng/article/details/70340598</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;只针对Object类型的深拷贝，自己总结的三种方式，分别为：递归的方式、广度优先遍历的方式、使用JSON.parse()方法。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;递归：&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
</feed>
